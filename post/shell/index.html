<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>shell | Tomding&#39;s Blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1606293841757">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="shell" />
  <meta name="keywords" content="Linux" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Tomding&#39;s Blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Tomding</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">4</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">1</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">1</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://dingtom.github.io/post/shell/">
      shell
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-11-25 15:16:54">2020-11-25</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://dingtom.github.io/tag/eaRjuF2eR/">
        <span>Linux</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>17<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>4120<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p><code>#!/bin/bash</code> <br>
######! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 <code>chmod +x ./test.sh</code> #使脚本具有执行权限 <code>./test.sh</code> #执行脚本 注意，一定要写成 ./test.sh，而不是 <a href="http://test.sh/">test.sh</a>，运行其它二进制的程序也一样，直接写 <a href="http://test.sh/">test.sh</a>，linux 系统会去 PATH 里寻找有没有叫 <a href="http://test.sh/">test.sh</a> 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <a href="http://test.sh/">test.sh</a> 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
<p><code>/bin/sh test.sh</code> # 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<p>######变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p>#####除了显式地直接赋值，还可以用语句给变量赋值，如： <code>for file in</code>ls /etc`` 或 <code>for file in $(ls /etc)</code> 以上语句将 /etc 下目录的文件名循环出来。</p>
<p>#####使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<pre><code>your_name=&quot;qinjx&quot;
echo $your_name
echo ${your_name}

</code></pre>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<pre><code>for skill in Ada Coffe Action Java; do  echo &quot;I am good at ${skill}Script&quot; ;done

</code></pre>
<p>如果不给skill变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<p>#####使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 readonly myUrl #修改的话执行时会报错</p>
<p>#####使用 unset 命令可以删除变量。unset 命令不能删除只读变量。 unset variable_name 变量被删除后不能再次使用。</p>
<p>#####单引号字符串的限制：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p>
<p>#####双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符</p>
<pre><code>your_name='runoob'
str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;
echo -e $str

</code></pre>
<p>#####拼接字符串</p>
<pre><code>your_name=&quot;runoob&quot;
# 使用双引号拼接
greeting=&quot;hello, &quot;$your_name&quot; !&quot;
greeting_1=&quot;hello, ${your_name} !&quot;
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
输出结果为：

hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !

</code></pre>
<p>#获取字符串长度 string=&quot;abcd&quot; echo ${#string} #输出 4</p>
<p>#提取子字符串 以下实例从字符串第 2 个字符开始截取 4 个字符： string=&quot;runoob is a great site&quot; echo ${string:1:4} # 输出 unoo</p>
<p>#查找子字符串 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： string=&quot;runoob is a great site&quot; <code>echo</code>expr index &quot;$string&quot; io`` # 输出 4</p>
<p>#####定义数组 在 Shell 中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开。 例如： array_name=(value0 value1 value2 value3) 还可以单独定义数组的各个分量： array_name[0]=value0 array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。</p>
<p>#####读取数组元素值的一般格式是：</p>
<pre><code>valuen=${array_name[n]}
使用 @ 符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}

</code></pre>
<p>#####获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<pre><code>length=${#array_name[@]}
或者
length=${#array_name[*]}

</code></pre>
<p>#####遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？ 每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
<p>#####多行注释还可以使用以下格式：</p>
<pre><code>:&lt;&lt;EOF
注释内容...
注释内容...
注释内容...
EOF

</code></pre>
<p>#####Shell 传递参数</p>
<pre><code>echo &quot;Shell 传递参数实例！&quot;
echo &quot;执行的文件名：$0&quot;;！！！！！！！！！！！！！！！！！！！！！！
echo &quot;第一个参数为：$1&quot;;
echo &quot;第二个参数为：$2&quot;;
echo &quot;第三个参数为：$3&quot;;
为脚本设置可执行权限，并执行脚本，输出结果如下所示：
chmod +x test.sh 
./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3

</code></pre>
<pre><code>$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。

</code></pre>
<p>#####另外，还有几个特殊字符用来处理</p>
<pre><code>$# 传递到脚本的参数个数 

$*  以一个单字符串显示所有向脚本传递的参数。如&quot;$*&quot;用「&quot;」
括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。

$$  脚本运行的当前进程ID号 

$!  后台运行的最后一个进程的ID号 

$@  与$*相同，但是使用时加引号，并在引号中返回每个参数。如&quot;$@&quot;用「&quot;」括起来的情况
以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数
 $* 与 $@ 区别：
相同点：都是引用所有参数。
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等
价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。

$- 显示Shell使用的当前选项，与[set命令]
(https://www.runoob.com/linux/linux-comm-set.html)功能相同。 

$?  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 

</code></pre>
<p>#Shell 基本运算符 #####算术运算符</p>
<pre><code>条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成
 [ $a == $b ]。表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，
这与我们熟悉的大多数编程语言不一样。完整的表达式要被 ` ` 包含，注意这个字符不是常用
的单引号，在 Esc 键下边。

</code></pre>
<pre><code>加法	`expr $a + $b` 结果为 30。
减法	`expr $a - $b` 结果为 -10。
乘法	`expr $a \* $b` 结果为  200。!   !  !   !   !
除法	`expr $b / $a` 结果为 2。
取余	`expr $b % $a` 结果为 0。
赋值	a=$b 将把变量 b 的值赋给 a。
相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。
不相等。用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。

</code></pre>
<p>#####关系运算符,关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<pre><code>-eq   检测两个数是否相等，相等返回 true。                 [ $a -eq $b ] 

-ne	检测两个数是否不相等，不相等返回 true。	            [ $a -ne $b ] 

-gt	检测左边的数是否大于右边的，如果是，则返回 true。   	[ $a -gt $b ] 

-lt	检测左边的数是否小于右边的，如果是，则返回 true。   	[ $a -lt $b ] 

-ge	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 

-le	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 

</code></pre>
<p>#####布尔运算符</p>
<pre><code>!	非运算，表达式为 true 则返回 false，否则返回 true。   	[ ! false ] 
-o	或运算，有一个表达式为 true 则返回 true。	                        [ $a -lt 20 -o $b -gt 100 ] 
-a	与运算，两个表达式都为 true 才返回 true。	                        [ $a -lt 20 -a $b -gt 100 ] 

</code></pre>
<p>#####逻辑运算符，表达式外有两个大括号! ! ! ! ! ! ! ! ! ! ! !</p>
<pre><code>&amp;&amp;	逻辑的 AND	[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]     !　！　！！　！！
||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]]   

</code></pre>
<p>##字符串运算符</p>
<pre><code>=	检测两个字符串是否相等，相等返回 true。	        [ $a = $b ] 
!=	检测两个字符串是否相等，不相等返回 true。	     [ $a != $b ] 
-z	检测字符串长度是否为0，为0返回 true。	        [ -z $a ] 
-n	检测字符串长度是否为0，不为0返回 true。	         [ -n &quot;$a&quot; ] 
$	检测字符串是否为空，不为空返回 true。	         [ $a ]   !!!!!!!!!!!

</code></pre>
<p>##文件测试运算符</p>
<pre><code>-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 
-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 
-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 
-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 
-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ]
-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 
-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 
-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 
-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 
-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 
-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 
-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 
-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 
-S: 判断某文件是否 socket。
-L: 检测文件是否存在并且是一个符号链接。

</code></pre>
<p>#echo命令 #####显示变量 read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<pre><code>read name 
echo &quot;$name It is a test&quot;
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出

</code></pre>
<p>#####显示换行 echo -e &quot;OK! \n&quot; # -e 开启转义 echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行 echo -n &quot;haod&quot; #输出后不换行 #####显示结果定向至文件 echo &quot;It is a test&quot; &gt; myfile</p>
<p>#####原样输出字符串，不进行转义或取变量(用单引号) <code>echo '$name\&quot;'</code></p>
<p>##显示命令执行结果 echo <code>date</code> #显示时间</p>
<p>#printf 命令 接下来,我来用一个脚本来体现printf的强大功能：</p>
<pre><code>#!/bin/bash
printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 
printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 
执行脚本，输出结果如下所示：

姓名     性别   体重kg
郭靖     男      66.12
杨过     男      48.65
郭芙     女      47.99

</code></pre>
<p>%s %c %d %f都是格式替代符</p>
<p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
<p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

# format-string为双引号
printf &quot;%d %s\n&quot; 1 &quot;abc&quot;

# 单引号与双引号效果一样 
printf '%d %s\n' 1 &quot;abc&quot; 

# 没有引号也可以输出
printf %s abcdef

# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
printf %s abc def

printf &quot;%s\n&quot; abc def

printf &quot;%s %s %s\n&quot; a b c d e f g h i j

# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
printf &quot;%s and %d \n&quot; 
执行脚本，输出结果如下所示：

1 abc
1 abc
abcdefabcdefabc
def
a b c
d e f
g h i
j  
 and 0

</code></pre>
<p>#####流程控制 <code>if [ $int == $anwser ]; then echo &quot;right&quot;;else echo &quot;wrong&quot;;fi</code></p>
<p><code>for var in item; do command; done</code> item是数组不用写括号</p>
<pre><code>echo '按下 &lt;CTRL-D&gt; 退出'
echo -n '输入你最喜欢的名字: '
while read NAME
do
    echo &quot;是的！$NAME 是一个好名字&quot;
done

</code></pre>
<p>#####while后的条件需要加括号 read 读取键盘输入 <CTRL-D> 退出</p>
<pre><code>#!/bin/bash
int=1
while([ $int -lt 5 ])   ! ! ! !  ! ! ! ! ! !
do
    echo $int
    let int++
done

</code></pre>
<p>let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。 let int++ #case</p>
<pre><code>echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac

</code></pre>
<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<pre><code>funWithReturn(){
    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;
    echo &quot;输入第一个数字: &quot;
    read aNum
    echo &quot;输入第二个数字: &quot;
    read anotherNum
    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;
    return $(($aNum+$anotherNum))
}
funWithReturn
echo &quot;输入的两个数字之和为 $? !&quot;

</code></pre>
<p>#####return返回的值需要两个括号 函数返回值在调用该函数后通过 $? 来获得。 #####输入/输出重定向 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
<pre><code>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：

$ wc -l users
       2 users
也可以将输入重定向到 users 文件：

$  wc -l &lt; users
       2 
注意：上面两个例子的结果不同：第一个例子，会输出文件名；
第二个不会，因为它仅仅知道从标准输入读取内容

</code></pre>
<p>#####重定向深入讲解 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<p>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>如果希望 stderr 重定向到 file，可以这样写：</p>
<p>command &lt; file1 &gt;file2 command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 #Here Document 它的基本的形式如下：</p>
<p>command &lt;&lt; delimiter document delimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<p>注意：</p>
<p>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。</p>
<pre><code>wc -l &lt;&lt; EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行

</code></pre>
<p>#####/dev/null 文件 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-ae38c3e76a5bcb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Tomding
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://dingtom.github.io/post/shell/" title="shell">https://dingtom.github.io/post/shell/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://dingtom.github.io/tag/eaRjuF2eR/"># Linux</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Ubuntu安装Samba分享文件夹" href="https://dingtom.github.io/post/ubuntu-an-zhuang-samba-fen-xiang-wen-jian-jia/">Ubuntu安装Samba分享文件夹</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Ubuntu安装Samba分享文件夹" href="https://dingtom.github.io/post/ubuntu-an-zhuang-samba-fen-xiang-wen-jian-jia/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Linux命令" href="https://dingtom.github.io/post/linux-ming-ling/">Linux命令</a>
        <a class="nav-mobile-next" title="Linux命令" href="https://dingtom.github.io/post/linux-ming-ling/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dingtom.github.io/post/an-zhuang-nvidia-xian-qia-qu-dong/"" data-c="
          &lt;p&gt;查看显卡型号&lt;br&gt;
&lt;code&gt;lsb_release -a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更新PCI ID数据库&lt;br&gt;
&lt;code&gt;update-pciids&lt;/code&gt;&lt;br&gt;
&lt;code&gt;lspci | grep -i nvidia&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;驱动安装&lt;br&gt;
&lt;code&gt;wget https://us.download.nvidia.com/XFree86/Linux-x86_64/455.23.04/NVIDIA-Linux-x86_64-455.23.04.run&lt;/code&gt;&lt;br&gt;
查看TMPDIR目录是否报错&lt;br&gt;
&lt;code&gt;echo $TMPDIR&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装驱动&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo bash NVIDIA-Linux-x86_64-455.23.04.run&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;禁用nouveau&lt;br&gt;
&lt;code&gt;lsmod | grep nouveau&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim /etc/modprobe.d/blacklist.conf&lt;/code&gt;添加&lt;br&gt;
&lt;code&gt;blacklist nouveau&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo update-initramfs -u&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo reboot now&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看显卡信息&lt;br&gt;
&lt;code&gt;nvidia-smi&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;安装cuda&#34;&gt;安装cuda&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;amp;target_arch=x86_64&amp;amp;target_distro=Ubuntu&amp;amp;target_version=1804&amp;amp;target_type=deblocal&#34;&gt;download&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;查看cuda版本&#34;&gt;查看cuda版本&lt;/h6&gt;
&lt;p&gt;&lt;code&gt;nvcc -V&lt;/code&gt;&lt;br&gt;
不显示&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，查看cuda的bin目录下是否有nvcc：&lt;br&gt;
&lt;code&gt;ls /usr/local/cuda/bin&lt;/code&gt;&lt;br&gt;
如果存在，直接将cuda路径加入系统路径即可：&lt;br&gt;
&lt;code&gt;vim ~/.bashrc&lt;/code&gt;进入配置文件；&lt;br&gt;
添加以下两行：&lt;br&gt;
&lt;code&gt;export PATH=/usr/local/cuda/bin:$PATH&lt;/code&gt;&lt;br&gt;
&lt;code&gt;export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH&lt;/code&gt;&lt;br&gt;
然后更新配置文件：&lt;br&gt;
&lt;code&gt;source ~/.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;安装cudnn&#34;&gt;安装cudnn&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.nvidia.com/rdp/cudnn-archive&#34;&gt;download&lt;/a&gt;&lt;br&gt;
&lt;code&gt;tar -xvf cudnn-8.0-linux-x64-v5.1.tgz&lt;/code&gt;&lt;br&gt;
安装cuDNN比较简单，解压后把相应的文件拷贝到对应的CUDA目录下即可&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo cp cuda/include/cudnn.h /usr/local/cuda/include/&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sudo chmod a+r /usr/local/cuda/include/cudnn.h&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sudo chmod a+r /usr/local/cuda/lib64/libcudnn*&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;卸载显卡驱动重新安装&#34;&gt;卸载显卡驱动重新安装&lt;/h1&gt;
&lt;p&gt;命令行界面&lt;br&gt;
Ctrl+Alt+F1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get --purge remove nvidia*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt autoremove&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;To remove CUDA Toolkit:&lt;br&gt;
&lt;code&gt;sudo apt-get --purge remove &amp;quot;*cublas*&amp;quot; &amp;quot;cuda*&amp;quot;&lt;/code&gt;&lt;br&gt;
To remove NVIDIA Drivers:&lt;br&gt;
&lt;code&gt;sudo apt-get --purge remove &amp;quot;*nvidia*&amp;quot;&lt;/code&gt;&lt;/p&gt;
">安装nvidia显卡驱动</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dingtom.github.io/post/ubuntu-an-zhuang-samba-fen-xiang-wen-jian-jia/"" data-c="
          &lt;p&gt;安装samba服务器。&lt;br&gt;
&lt;code&gt;sudo apt-get install samba samba-common&lt;/code&gt;&lt;br&gt;
创建一个用于分享的samba目录。&lt;br&gt;
&lt;code&gt;sudo mkdir /home/zut_csi/tomding/share&lt;/code&gt;&lt;br&gt;
给创建的这个目录设置权限&lt;br&gt;
&lt;code&gt;sudo chmod 777 /home/zut_csi/tomding/share&lt;/code&gt;&lt;br&gt;
添加用户(下面的zut_csi是我的用户名，之后会需要设置samba的密码)。&lt;br&gt;
&lt;code&gt;sudo smbpasswd -a zut_csi&lt;/code&gt;&lt;br&gt;
配置samba的配置文件。&lt;br&gt;
&lt;code&gt;sudo vim /etc/samba/smb.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在配置文件smb.conf的最后添加下面的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[share]
comment = share folder
browseable = yes
path = /home/zut_csi/tomding/share
create mask = 0700
directory mask = 0700
valid users = zut_csi
force user = zut_csi
force group = zut_csi
public = yes
browseable = yes
read only = no
available = yes
writable = yes
security = share
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启samba服务器。&lt;br&gt;
&lt;code&gt;sudo service smbd restart&lt;/code&gt;&lt;/p&gt;
">Ubuntu安装Samba分享文件夹</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dingtom.github.io/post/shell/"" data-c="
          &lt;p&gt;&lt;code&gt;#!/bin/bash&lt;/code&gt; &lt;br&gt;
######! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 &lt;code&gt;chmod +x ./test.sh&lt;/code&gt; #使脚本具有执行权限 &lt;code&gt;./test.sh&lt;/code&gt; #执行脚本 注意，一定要写成 ./test.sh，而不是 &lt;a href=&#34;http://test.sh/&#34;&gt;test.sh&lt;/a&gt;，运行其它二进制的程序也一样，直接写 &lt;a href=&#34;http://test.sh/&#34;&gt;test.sh&lt;/a&gt;，linux 系统会去 PATH 里寻找有没有叫 &lt;a href=&#34;http://test.sh/&#34;&gt;test.sh&lt;/a&gt; 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 &lt;a href=&#34;http://test.sh/&#34;&gt;test.sh&lt;/a&gt; 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/bin/sh test.sh&lt;/code&gt; # 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。&lt;/p&gt;
&lt;p&gt;######变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。&lt;/p&gt;
&lt;p&gt;#####除了显式地直接赋值，还可以用语句给变量赋值，如： &lt;code&gt;for file in&lt;/code&gt;ls /etc`` 或 &lt;code&gt;for file in $(ls /etc)&lt;/code&gt; 以上语句将 /etc 下目录的文件名循环出来。&lt;/p&gt;
&lt;p&gt;#####使用一个定义过的变量，只要在变量名前面加美元符号即可，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;your_name=&amp;quot;qinjx&amp;quot;
echo $your_name
echo ${your_name}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for skill in Ada Coffe Action Java; do  echo &amp;quot;I am good at ${skill}Script&amp;quot; ;done

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不给skill变量加花括号，写成&lt;code&gt;echo &amp;quot;I am good at $skillScript&amp;quot;&lt;/code&gt;，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。&lt;/p&gt;
&lt;p&gt;#####使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 readonly myUrl #修改的话执行时会报错&lt;/p&gt;
&lt;p&gt;#####使用 unset 命令可以删除变量。unset 命令不能删除只读变量。 unset variable_name 变量被删除后不能再次使用。&lt;/p&gt;
&lt;p&gt;#####单引号字符串的限制：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。&lt;/p&gt;
&lt;p&gt;#####双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;your_name=&#39;runoob&#39;
str=&amp;quot;Hello, I know you are \&amp;quot;$your_name\&amp;quot;! \n&amp;quot;
echo -e $str

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####拼接字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;your_name=&amp;quot;runoob&amp;quot;
# 使用双引号拼接
greeting=&amp;quot;hello, &amp;quot;$your_name&amp;quot; !&amp;quot;
greeting_1=&amp;quot;hello, ${your_name} !&amp;quot;
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;
greeting_3=&#39;hello, ${your_name} !&#39;
echo $greeting_2  $greeting_3
输出结果为：

hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#获取字符串长度 string=&amp;quot;abcd&amp;quot; echo ${#string} #输出 4&lt;/p&gt;
&lt;p&gt;#提取子字符串 以下实例从字符串第 2 个字符开始截取 4 个字符： string=&amp;quot;runoob is a great site&amp;quot; echo ${string:1:4} # 输出 unoo&lt;/p&gt;
&lt;p&gt;#查找子字符串 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： string=&amp;quot;runoob is a great site&amp;quot; &lt;code&gt;echo&lt;/code&gt;expr index &amp;quot;$string&amp;quot; io`` # 输出 4&lt;/p&gt;
&lt;p&gt;#####定义数组 在 Shell 中，用括号来表示数组，数组元素用&amp;quot;空格&amp;quot;符号分割开。 例如： array_name=(value0 value1 value2 value3) 还可以单独定义数组的各个分量： array_name[0]=value0 array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。&lt;/p&gt;
&lt;p&gt;#####读取数组元素值的一般格式是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;valuen=${array_name[n]}
使用 @ 符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;length=${#array_name[@]}
或者
length=${#array_name[*]}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？ 每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。&lt;/p&gt;
&lt;p&gt;#####多行注释还可以使用以下格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:&amp;lt;&amp;lt;EOF
注释内容...
注释内容...
注释内容...
EOF

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####Shell 传递参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;Shell 传递参数实例！&amp;quot;
echo &amp;quot;执行的文件名：$0&amp;quot;;！！！！！！！！！！！！！！！！！！！！！！
echo &amp;quot;第一个参数为：$1&amp;quot;;
echo &amp;quot;第二个参数为：$2&amp;quot;;
echo &amp;quot;第三个参数为：$3&amp;quot;;
为脚本设置可执行权限，并执行脚本，输出结果如下所示：
chmod +x test.sh 
./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$10 不能获取第十个参数，获取第十个参数需要${10}。当n&amp;gt;=10时，需要使用${n}来获取参数。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####另外，还有几个特殊字符用来处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$# 传递到脚本的参数个数 

$*  以一个单字符串显示所有向脚本传递的参数。如&amp;quot;$*&amp;quot;用「&amp;quot;」
括起来的情况、以&amp;quot;$1 $2 … $n&amp;quot;的形式输出所有参数。

$$  脚本运行的当前进程ID号 

$!  后台运行的最后一个进程的ID号 

$@  与$*相同，但是使用时加引号，并在引号中返回每个参数。如&amp;quot;$@&amp;quot;用「&amp;quot;」括起来的情况
以&amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot; … &amp;quot;$n&amp;quot; 的形式输出所有参数
 $* 与 $@ 区别：
相同点：都是引用所有参数。
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &amp;quot; * &amp;quot; 等
价于 &amp;quot;1 2 3&amp;quot;（传递了一个参数），而 &amp;quot;@&amp;quot; 等价于 &amp;quot;1&amp;quot; &amp;quot;2&amp;quot; &amp;quot;3&amp;quot;（传递了三个参数）。

$- 显示Shell使用的当前选项，与[set命令]
(https://www.runoob.com/linux/linux-comm-set.html)功能相同。 

$?  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#Shell 基本运算符 #####算术运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成
 [ $a == $b ]。表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，
这与我们熟悉的大多数编程语言不一样。完整的表达式要被 ` ` 包含，注意这个字符不是常用
的单引号，在 Esc 键下边。

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;加法	`expr $a + $b` 结果为 30。
减法	`expr $a - $b` 结果为 -10。
乘法	`expr $a \* $b` 结果为  200。!   !  !   !   !
除法	`expr $b / $a` 结果为 2。
取余	`expr $b % $a` 结果为 0。
赋值	a=$b 将把变量 b 的值赋给 a。
相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。
不相等。用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####关系运算符,关系运算符只支持数字，不支持字符串，除非字符串的值是数字。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-eq   检测两个数是否相等，相等返回 true。                 [ $a -eq $b ] 

-ne	检测两个数是否不相等，不相等返回 true。	            [ $a -ne $b ] 

-gt	检测左边的数是否大于右边的，如果是，则返回 true。   	[ $a -gt $b ] 

-lt	检测左边的数是否小于右边的，如果是，则返回 true。   	[ $a -lt $b ] 

-ge	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 

-le	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####布尔运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;!	非运算，表达式为 true 则返回 false，否则返回 true。   	[ ! false ] 
-o	或运算，有一个表达式为 true 则返回 true。	                        [ $a -lt 20 -o $b -gt 100 ] 
-a	与运算，两个表达式都为 true 才返回 true。	                        [ $a -lt 20 -a $b -gt 100 ] 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####逻辑运算符，表达式外有两个大括号! ! ! ! ! ! ! ! ! ! ! !&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;amp;&amp;amp;	逻辑的 AND	[[ $a -lt 100 &amp;amp;&amp;amp; $b -gt 100 ]]     !　！　！！　！！
||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]]   

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##字符串运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;=	检测两个字符串是否相等，相等返回 true。	        [ $a = $b ] 
!=	检测两个字符串是否相等，不相等返回 true。	     [ $a != $b ] 
-z	检测字符串长度是否为0，为0返回 true。	        [ -z $a ] 
-n	检测字符串长度是否为0，不为0返回 true。	         [ -n &amp;quot;$a&amp;quot; ] 
$	检测字符串是否为空，不为空返回 true。	         [ $a ]   !!!!!!!!!!!

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##文件测试运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 
-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 
-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 
-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 
-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ]
-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 
-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 
-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 
-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 
-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 
-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 
-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 
-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 
-S: 判断某文件是否 socket。
-L: 检测文件是否存在并且是一个符号链接。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#echo命令 #####显示变量 read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;read name 
echo &amp;quot;$name It is a test&amp;quot;
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####显示换行 echo -e &amp;quot;OK! \n&amp;quot; # -e 开启转义 echo -e &amp;quot;OK! \c&amp;quot; # -e 开启转义 \c 不换行 echo -n &amp;quot;haod&amp;quot; #输出后不换行 #####显示结果定向至文件 echo &amp;quot;It is a test&amp;quot; &amp;gt; myfile&lt;/p&gt;
&lt;p&gt;#####原样输出字符串，不进行转义或取变量(用单引号) &lt;code&gt;echo &#39;$name\&amp;quot;&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;##显示命令执行结果 echo &lt;code&gt;date&lt;/code&gt; #显示时间&lt;/p&gt;
&lt;p&gt;#printf 命令 接下来,我来用一个脚本来体现printf的强大功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
printf &amp;quot;%-10s %-8s %-4s\n&amp;quot; 姓名 性别 体重kg  
printf &amp;quot;%-10s %-8s %-4.2f\n&amp;quot; 郭靖 男 66.1234 
printf &amp;quot;%-10s %-8s %-4.2f\n&amp;quot; 杨过 男 48.6543 
printf &amp;quot;%-10s %-8s %-4.2f\n&amp;quot; 郭芙 女 47.9876 
执行脚本，输出结果如下所示：

姓名     性别   体重kg
郭靖     男      66.12
杨过     男      48.65
郭芙     女      47.99

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;%s %c %d %f都是格式替代符&lt;/p&gt;
&lt;p&gt;%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。&lt;/p&gt;
&lt;p&gt;%-4.2f 指格式化为小数，其中.2指保留2位小数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

# format-string为双引号
printf &amp;quot;%d %s\n&amp;quot; 1 &amp;quot;abc&amp;quot;

# 单引号与双引号效果一样 
printf &#39;%d %s\n&#39; 1 &amp;quot;abc&amp;quot; 

# 没有引号也可以输出
printf %s abcdef

# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
printf %s abc def

printf &amp;quot;%s\n&amp;quot; abc def

printf &amp;quot;%s %s %s\n&amp;quot; a b c d e f g h i j

# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
printf &amp;quot;%s and %d \n&amp;quot; 
执行脚本，输出结果如下所示：

1 abc
1 abc
abcdefabcdefabc
def
a b c
d e f
g h i
j  
 and 0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####流程控制 &lt;code&gt;if [ $int == $anwser ]; then echo &amp;quot;right&amp;quot;;else echo &amp;quot;wrong&amp;quot;;fi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for var in item; do command; done&lt;/code&gt; item是数组不用写括号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &#39;按下 &amp;lt;CTRL-D&amp;gt; 退出&#39;
echo -n &#39;输入你最喜欢的名字: &#39;
while read NAME
do
    echo &amp;quot;是的！$NAME 是一个好名字&amp;quot;
done

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####while后的条件需要加括号 read 读取键盘输入 &lt;CTRL-D&gt; 退出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
int=1
while([ $int -lt 5 ])   ! ! ! !  ! ! ! ! ! !
do
    echo $int
    let int++
done

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。 let int++ #case&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &#39;输入 1 到 4 之间的数字:&#39;
echo &#39;你输入的数字为:&#39;
read aNum
case $aNum in
    1)  echo &#39;你选择了 1&#39;
    ;;
    2)  echo &#39;你选择了 2&#39;
    ;;
    3)  echo &#39;你选择了 3&#39;
    ;;
    4)  echo &#39;你选择了 4&#39;
    ;;
    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;
    ;;
esac

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;funWithReturn(){
    echo &amp;quot;这个函数会对输入的两个数字进行相加运算...&amp;quot;
    echo &amp;quot;输入第一个数字: &amp;quot;
    read aNum
    echo &amp;quot;输入第二个数字: &amp;quot;
    read anotherNum
    echo &amp;quot;两个数字分别为 $aNum 和 $anotherNum !&amp;quot;
    return $(($aNum+$anotherNum))
}
funWithReturn
echo &amp;quot;输入的两个数字之和为 $? !&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####return返回的值需要两个括号 函数返回值在调用该函数后通过 $? 来获得。 #####输入/输出重定向 command &amp;gt; file 将输出重定向到 file。 command &amp;lt; file 将输入重定向到 file。 command &amp;gt;&amp;gt; file 将输出以追加的方式重定向到 file。 n &amp;gt; file 将文件描述符为 n 的文件重定向到 file。 n &amp;gt;&amp;gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &amp;gt;&amp;amp; m 将输出文件 m 和 n 合并。 n &amp;lt;&amp;amp; m 将输入文件 m 和 n 合并。 &amp;lt;&amp;lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;接着以上实例，我们需要统计 users 文件的行数,执行以下命令：

$ wc -l users
       2 users
也可以将输入重定向到 users 文件：

$  wc -l &amp;lt; users
       2 
注意：上面两个例子的结果不同：第一个例子，会输出文件名；
第二个不会，因为它仅仅知道从标准输入读取内容

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####重定向深入讲解 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：&lt;/p&gt;
&lt;p&gt;标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &amp;gt; file 将 stdout 重定向到 file，command &amp;lt; file 将stdin 重定向到 file。&lt;/p&gt;
&lt;p&gt;如果希望 stderr 重定向到 file，可以这样写：&lt;/p&gt;
&lt;p&gt;command &amp;lt; file1 &amp;gt;file2 command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 #Here Document 它的基本的形式如下：&lt;/p&gt;
&lt;p&gt;command &amp;lt;&amp;lt; delimiter document delimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wc -l &amp;lt;&amp;lt; EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#####/dev/null 文件 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： command &amp;gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&amp;quot;禁止输出&amp;quot;的效果。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-ae38c3e76a5bcb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">shell</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://dingtom.github.io/post/linux-ming-ling/"" data-c="
          &lt;p&gt;[TOC]&lt;br&gt;
Ctrl+d	键盘输入结束或退出终端&lt;br&gt;
Ctrl+s	暂停当前程序，暂停后按下任意键恢复运行&lt;br&gt;
Ctrl+z	将当前程序放到后台运行，恢复到前台为命令fg&lt;br&gt;
Ctrl+a	将光标移至输入行头，相当于Home键&lt;br&gt;
Ctrl+e	将光标移至输入行末，相当于End键&lt;br&gt;
Ctrl+k	删除从光标所在位置到行末&lt;br&gt;
Alt+Backspace	向前删除一个&lt;strong&gt;单词&lt;/strong&gt;&lt;br&gt;
命令 --help  查看一些它的某个命令具体参数的作用&lt;br&gt;
man 命令   显示系统手册页中的内容&lt;/p&gt;
&lt;p&gt;一行中运行多个命令。&lt;br&gt;
; Command 1 ; Command 2 首先运行Command1，然后运行Command2&lt;br&gt;
&amp;amp;&amp;amp; Command 1 &amp;amp;&amp;amp; Command 2 当Command1运行成功并结束，然后运行Command2&lt;br&gt;
|| Command 1 || Command 2 当Command1运行失败时才运行Command2&lt;/p&gt;
&lt;h1 id=&#34;文件&#34;&gt;文件&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-be4aa0903719bf65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;bin (binaries)存放二进制可执行文件&lt;br&gt;
sbin (super user binaries)存放二进制可执行文件，只有root才能访问&lt;br&gt;
etc (etcetera)存放系统配置文件&lt;br&gt;
usr (unix shared resources)用于存放共享的系统资源&lt;br&gt;
home 存放用户文件的根目录&lt;br&gt;
root 超级用户目录&lt;br&gt;
dev (devices)用于存放设备文件&lt;br&gt;
lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块&lt;br&gt;
mnt (mount)系统管理员安装临时文件系统的安装点&lt;br&gt;
boot 存放用于系统引导时使用的各种文件&lt;br&gt;
tmp (temporary)用于存放各种临时文件&lt;br&gt;
var (variable)用于存放运行时需要改变数据的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;文件增删改查&#34;&gt;文件增删改查&lt;/h1&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;mkdir&#34;&gt;mkdir&lt;/h4&gt;
&lt;p&gt;创建目录和父目录a,b,c,d&lt;br&gt;
&lt;code&gt;mkdir -p a/b/c/d&lt;/code&gt;&lt;br&gt;
-p 建立多级目录&lt;br&gt;
-m 在建立目录的时候给目录赋于权限值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;rmdir&#34;&gt;rmdir&lt;/h4&gt;
&lt;p&gt;删除空目录&lt;br&gt;
-p 删除多级空目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;cp&#34;&gt;cp&lt;/h4&gt;
&lt;p&gt;拷贝文件夹a到/tmp目录&lt;br&gt;
&lt;code&gt;cp -rvf a/ /tmp/&lt;/code&gt;&lt;br&gt;
-R 复制整个目录里的内容&lt;br&gt;
-p 复制完后保持目录的权限值&lt;br&gt;
-v 在复制文件的时候显示进度&lt;br&gt;
-f 在复制的时候如果碰到目的文件名有重复就将原先的删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;mv&#34;&gt;mv&lt;/h4&gt;
&lt;p&gt;重命名 &lt;code&gt;mv a.txt b.txt&lt;/code&gt;&lt;br&gt;
移动文件a到/tmp目录，并重命名为b&lt;br&gt;
&lt;code&gt;mv -vf a /tmp/b&lt;/code&gt;&lt;br&gt;
-i 如果目的地有相同文件名时会出现提示&lt;br&gt;
-v 在搬移文件时显示进度，在移动多文件时非常有用&lt;br&gt;
-u 当移动时只有源文件比目的文件新的时候才会移动&lt;br&gt;
-f 强制覆盖已有的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;touch&#34;&gt;touch&lt;/h4&gt;
&lt;p&gt;创建文件&lt;br&gt;
&lt;code&gt;touch asd.txt&lt;/code&gt;&lt;br&gt;
创建多个文件&lt;br&gt;
&lt;code&gt;touch love_{1..10}_shiyanlou.txt&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;rm&#34;&gt;rm&lt;/h4&gt;
&lt;p&gt;删除机器上的所有文件&lt;br&gt;
rm -rvf /&lt;br&gt;
-i 在删除文件之前需要手工确认&lt;br&gt;
-v 在删除文件的时候显示信息&lt;br&gt;
-r 删除目录&lt;br&gt;
-f 忽略提示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;ls&#34;&gt;ls&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;-a 这个选项能显示.开头的隐藏文件&lt;br&gt;
-l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出&lt;br&gt;
-t 将文件依建立时间之先后次序列出&lt;br&gt;
-i 显示每个文件的inode号&lt;br&gt;
-m 所有项目以逗号分隔，并填满整行行宽&lt;br&gt;
-R 同时列出所有子目录层&lt;br&gt;
-h 将列出文件的大小以人性化格式输出&lt;br&gt;
--color=tty(2个-号)显示文件的时候以色彩提示&lt;br&gt;
-full-time显示文件的详细访问时间&lt;br&gt;
-lc查看文件状态修改时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;cat&#34;&gt;cat&lt;/h4&gt;
&lt;p&gt;查看文本文件&lt;br&gt;
如果文件很大的话，cat命令的输出结果会疯狂在终端上输出，可以多次按ctrl+c终止。&lt;br&gt;
-b 显示文件内容的时候显示行数&lt;br&gt;
-n 显示文件内容包括空行&lt;br&gt;
-s 将多个空行合并成一个空行输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;tr&#34;&gt;tr&lt;/h4&gt;
&lt;p&gt;删除、转换一段文本信息中的某些文字&lt;br&gt;
-d	删除匹配的字符，注意不是全词匹配也不是按字符顺序匹配&lt;br&gt;
-s	去除指定的在输入文本中连续并重复的字符&lt;br&gt;
删除 &amp;quot;hello shiyanlou&amp;quot; 中所有的&#39;o&#39;,&#39;l&#39;,&#39;h&#39;&lt;br&gt;
&lt;code&gt;echo &#39;hello shiyanlou&#39; | tr -d &#39;olh&#39;&lt;/code&gt;&lt;br&gt;
将&amp;quot;hello&amp;quot; 中的ll,去重为一个l&lt;br&gt;
&lt;code&gt;echo &#39;hello&#39; | tr -s &#39;l&#39;&lt;/code&gt;&lt;br&gt;
将输入文本，全部转换为大写或小写输出&lt;br&gt;
&lt;code&gt;echo &#39;input some text here&#39; | tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;&lt;/code&gt;&lt;br&gt;
上面的&#39;[:lower:]&#39; &#39;[:upper:]&#39;你也可以简单的写作&#39;[a-z]&#39; &#39;[A-Z]&#39;,当然反过来将大写变小写也是可以的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;jion&#34;&gt;jion&lt;/h4&gt;
&lt;p&gt;将两个文件中包含相同内容的那一行合并在一起。&lt;br&gt;
-t	指定分隔符，默认为空格&lt;br&gt;
-i	忽略大小写的差异&lt;br&gt;
-1	指明第一个文件要用哪个字段来对比，默认对比第一个字段&lt;br&gt;
-2	指明第二个文件要用哪个字段来对比，默认对比第一个字段&lt;br&gt;
将/etc/passwd与/etc/group两个文件合并，指定以&#39;:&#39;作为分隔符, 分别比对第4和第3个字段&lt;br&gt;
&lt;code&gt;sudo join -t&#39;:&#39; -1 4 /etc/passwd -2 3 /etc/group&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;paste&#34;&gt;paste&lt;/h4&gt;
&lt;p&gt;在不对比数据的情况下，简单地将多个文件合并一起，以Tab隔开。&lt;br&gt;
-d	指定合并的分隔符，默认为 Tab&lt;br&gt;
-s	不合并到一行，每个文件为一行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;less&#34;&gt;less&lt;/h4&gt;
&lt;p&gt;针对比较大的文件，我们就可以使用less命令打开某个文件。&lt;/p&gt;
&lt;p&gt;按n(N)向下(上)查找。&lt;/p&gt;
&lt;h4 id=&#34;more&#34;&gt;more&lt;/h4&gt;
&lt;p&gt;查看文本文件命令&lt;/p&gt;
&lt;p&gt;用空格向下翻页，用b向上翻页&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;+行数直接从给定的行数开始显示&lt;br&gt;
-s 将多个空行压缩成一个空行&lt;br&gt;
-p 清除屏幕后再显示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;nano&#34;&gt;nano&lt;/h4&gt;
&lt;p&gt;文本编辑器&lt;br&gt;
命令格式：nano [选项] [行号] 文件名&lt;/p&gt;
&lt;h4 id=&#34;head&#34;&gt;head&lt;/h4&gt;
&lt;p&gt;查看文件头部&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-n &amp;lt;行数&amp;gt; 显示文件的最前指定的行&lt;br&gt;
-c &amp;lt;字节数&amp;gt; 显示文件前N个字节数里的内容&lt;br&gt;
-q 不输出文件头的内容&lt;br&gt;
-v 输出文件头的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;tail&#34;&gt;tail&lt;/h4&gt;
&lt;p&gt;查看文件尾部&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-f 循环读取&lt;br&gt;
-c &amp;lt;字节数&amp;gt; 显示文件前N个字节数里的内容&lt;br&gt;
-q 不输出文件头的内容&lt;br&gt;
-n &amp;lt;行数&amp;gt; 指定所显示的行数&lt;br&gt;
-v 输出文件头的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;tail -f access.log&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;ln&#34;&gt;ln&lt;/h4&gt;
&lt;p&gt;生成链接文件&lt;/p&gt;
&lt;p&gt;命令格式：ln [选项] 源文件 链接文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-f 删除已存在的目的文件&lt;br&gt;
-i 如果碰到有重复名字的提示如何操作&lt;br&gt;
-v 显示操作信息&lt;br&gt;
-s 软链接选项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;file&#34;&gt;file&lt;/h4&gt;
&lt;p&gt;查看文件的类型&lt;/p&gt;
&lt;h4 id=&#34;stat&#34;&gt;stat&lt;/h4&gt;
&lt;p&gt;显示文件或文件系统状态&lt;/p&gt;
&lt;p&gt;命令格式：stat [选项] &amp;lt;文件/目录&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-f:查看指定的文件系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;stat可查看：&lt;br&gt;
文件名 2. 文件尺寸 3. I节点号 4. 创建时间/访问时间/状态(属 主、组、权限)修改时间 5.权限 6.链接文件个数 7. 属主及属组等&lt;/p&gt;
&lt;h4 id=&#34;whereis&#34;&gt;whereis&lt;/h4&gt;
&lt;p&gt;whereis 只能查找2进制程序，文档和源码。&lt;/p&gt;
&lt;h4 id=&#34;which&#34;&gt;which&lt;/h4&gt;
&lt;p&gt;查找是否安装某个命令&lt;/p&gt;
&lt;h4 id=&#34;find&#34;&gt;find&lt;/h4&gt;
&lt;p&gt;最常用的命令，命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。&lt;br&gt;
&lt;code&gt;sudo find /etc -name sources.list&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;find -size n [c]&lt;br&gt;
查找n值大小的文件,默认单位是块(1块=512字节)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;查找大于1500字节的文件&lt;br&gt;
find ~ -size +1500c&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;查找等于1500字节的文件&lt;br&gt;
find ~ -size 1500c&lt;/li&gt;
&lt;li&gt;查找小于1500字节的文件&lt;br&gt;
find ~ -size -1500c&lt;/li&gt;
&lt;li&gt;查找大于512k字节的文件&lt;br&gt;
find ~ -size +512k&lt;/li&gt;
&lt;li&gt;查找等于1M字节的文件&lt;br&gt;
find ~ -size 1M&lt;/li&gt;
&lt;li&gt;查找小于1G字节的文件&lt;br&gt;
find ~ -size -1G&lt;/li&gt;
&lt;li&gt;查找大于10块的文件&lt;br&gt;
find ~ -size +10&lt;/li&gt;
&lt;li&gt;查找等于10块的文件&lt;br&gt;
find ~ -size -10&lt;/li&gt;
&lt;li&gt;查找大于10M小于20M的文件&lt;br&gt;
find ./ -size +10M -size -20M&lt;/li&gt;
&lt;li&gt;查找小于10块的文件&lt;br&gt;
find ~ -size -10&lt;/li&gt;
&lt;li&gt;查找文件/目录字节为0的文件(即空文件)&lt;br&gt;
find / -empty&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;grep&#34;&gt;grep&lt;/h4&gt;
&lt;p&gt;功能: 通过正则表达式查找文件中的关键字&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-i:忽略大小写&lt;br&gt;
-c:打印匹配的行数&lt;br&gt;
-C:打印出匹配的上下文(上N行,下N行)的多少行-l:列出匹配的文件名&lt;br&gt;
-L:列出不匹配的文件名&lt;br&gt;
-n：打印包含匹配项的行和行标&lt;br&gt;
-w:仅匹配指定的单词而非关键字&lt;br&gt;
-e:索引匹配字串&lt;br&gt;
-r:递归查询&lt;br&gt;
-v:不输出匹配的行&lt;br&gt;
-A &amp;lt;行号&amp;gt;:显示所找的匹配字段，并显示下面指定的行数的信息&lt;br&gt;
-B &amp;lt;行号&amp;gt;:显示所找的匹配字段，并显示上面指定的行数的信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看nginx日志中的POST请求。&lt;br&gt;
&lt;code&gt;grep -rn --color POST access.log&lt;/code&gt;&lt;br&gt;
看某个异常前后相关的内容&lt;br&gt;
&lt;code&gt;grep -rn --color Exception -A10 -B2 error.log&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;正则表达式表示方法&#34;&gt;正则表达式表示方法:&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;\忽略正则表达式中特殊字符的原有含义&lt;br&gt;
^ 匹配正则表达式的开始行&lt;br&gt;
$ 匹配正则表达式的结束行&lt;br&gt;
&amp;lt; 从匹配正则表达式的行开始&lt;br&gt;
到匹配正则表达式的行结束&lt;br&gt;
[ ] 单个字符；如[A] 即A符合要求&lt;br&gt;
[ n - m ] 范围 ；如[A-H]即包含A至H都符合要求&lt;br&gt;
. 所有的单个字符&lt;br&gt;
* 所有字符，长度可以为0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;cut&#34;&gt;cut&lt;/h4&gt;
&lt;p&gt;打印每一行的某一字段&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-d “n”:定义分界符,即点位&lt;br&gt;
-f 取第几位的字符&lt;br&gt;
-c:仅显示行中指定范围的字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印/etc/passwd文件中以:为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录：&lt;br&gt;
&lt;code&gt;cut /etc/passwd -d &#39;:&#39; -f 1,6&lt;/code&gt;&lt;br&gt;
前五个（包含第五个）&lt;br&gt;
&lt;code&gt;cut /etc/passwd -c -5&lt;/code&gt;&lt;br&gt;
前五个之后的（包含第五个）&lt;br&gt;
&lt;code&gt;cut /etc/passwd -c 5-&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;sort&#34;&gt;sort&lt;/h4&gt;
&lt;p&gt;排序&lt;br&gt;
-r反转&lt;br&gt;
-t参数用于指定字段的分隔符&lt;br&gt;
-k 字段号用于指定对哪一个字段进行排序&lt;br&gt;
-n 按照数字排序,默认情况下是以字典序排序的&lt;br&gt;
&lt;code&gt;cat /etc/passwd | sort -t&#39;:&#39; -k 3 -n&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;wc&#34;&gt;wc&lt;/h4&gt;
&lt;p&gt;计数工具&lt;br&gt;
行数&lt;br&gt;
&lt;code&gt;wc -l /etc/passwd&lt;/code&gt;&lt;br&gt;
单词数&lt;br&gt;
&lt;code&gt;wc -w /etc/passwd&lt;/code&gt;&lt;br&gt;
字节数&lt;br&gt;
&lt;code&gt;wc -c /etc/passwd&lt;/code&gt;&lt;br&gt;
字符数&lt;br&gt;
&lt;code&gt;wc -m /etc/passwd&lt;/code&gt;&lt;br&gt;
最长行字节数，西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于 2 个字节的，具体数目是由字符编码决定的&lt;br&gt;
&lt;code&gt;wc -L /etc/passwd&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;uniq&#34;&gt;uniq&lt;/h4&gt;
&lt;p&gt;-c:在数据行前出现的次数&lt;br&gt;
-d:只打印重复的行,重复的行只显示一次&lt;br&gt;
-f:忽略行首的几个字段&lt;br&gt;
-i:忽略大小写&lt;br&gt;
-s:忽略行首的几个字母&lt;br&gt;
-u:只打印唯一的行&lt;/p&gt;
&lt;p&gt;用于过滤或者输出重复行。&lt;br&gt;
因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;history | cut -c 8- | cut -d &#39; &#39; -f 1 | sort | uniq&lt;/code&gt;&lt;br&gt;
使用频率前三的命令&lt;br&gt;
&lt;code&gt;history |cut -c 8-|sort|uniq -dc|sort -rn -k1 |head -3&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;下载&#34;&gt;下载&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;wget url&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install axel&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;axel -n 10 -o /tmp/ [http://testdownload.net/test.tar.gz](http://testdownload.net/test.tar.gz)&lt;/code&gt;&lt;br&gt;
-n 指定线程数&lt;br&gt;
-o 指定另存为目录&lt;br&gt;
-s 指定每秒的最大比特数&lt;br&gt;
-q 静默模式&lt;/p&gt;
&lt;h1 id=&#34;系统&#34;&gt;系统&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;who am i&lt;/code&gt;&lt;br&gt;
查看用户&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-f5fab39403516fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;输出的第一列表示打开当前伪终端的用户的用户名，第二列的 pts/0 中 pts 表示伪终端，所谓伪是相对于 /dev/tty 设备而言的，还记得上一节讲终端时的那七个使用 [Ctrl]+[Alt]+[F1]～[F7] 进行切换的 /dev/tty 设备么，这是“真终端”，伪终端就是当你在图形用户界面使用 /dev/tty7 时每打开一个终端就会产生一个伪终端，pts/0 后面那个数字就表示打开的伪终端序号，第三列则表示当前伪终端的启动时间。&lt;/p&gt;
&lt;h4 id=&#34;用户&#34;&gt;用户&lt;/h4&gt;
&lt;p&gt;sudo passwd lilei  设置用户lilei的密码&lt;br&gt;
sudo adduser lilei 创建新用户lilei，默认为新用户在 /home 目录下创建一个工作目录&lt;br&gt;
su -l lilei   切换到lilei用户&lt;br&gt;
sudo deluser lilei --remove-home  删除用户&lt;/p&gt;
&lt;h4 id=&#34;groups&#34;&gt;groups&lt;/h4&gt;
&lt;p&gt;groups shiyanlou&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-190c8e54549c1881.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其中冒号之前表示用户，后面表示该用户所属的用户组。这里可以看到 shiyanlou 用户属于 shiyanlou 用户组，每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组&lt;br&gt;
&lt;code&gt;cat /etc/group | grep -E &amp;quot;shiyanlou&amp;quot;&lt;/code&gt;&lt;br&gt;
查看自己属于哪些用户组&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-51df186681c8e87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
group_name:password:GID:user_list&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo usermod -G sudo lilei&lt;/code&gt;&lt;br&gt;
将其它用户加入 sudo 用户组&lt;br&gt;
以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。&lt;/p&gt;
&lt;h2 id=&#34;文件权限操作&#34;&gt;文件权限操作&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ls -l a.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;drwxr-xr-x  2 root root 4.0K  3月  23  2017  a.txt&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第1位：文件类型（d 目录，- 普通文件，l 链接文件）&lt;br&gt;
r 可读权限，w可写权限，x可执行权限（也可以用二进制表示 111 110 100 --&amp;gt; 764）&lt;br&gt;
第2-4位：所属用户权限，用u（user）表示&lt;br&gt;
第5-7位：所属组权限，用g（group）表示&lt;br&gt;
第8-10位：其他用户权限，用o（other）表示&lt;br&gt;
第2-10位：表示所有的权限，用a（all）表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2是纯数字 ，表示 文件链接个数&lt;br&gt;
第一个“root” 表示文件的所有者&lt;br&gt;
第二个“root” 表示为文件的所在群组&lt;br&gt;
“4.0K”，表示为文件长度（大小）&lt;br&gt;
“3月  23  2017”，表示文件最后更新（修改）时间&lt;br&gt;
“etc” 表示文件的名称&lt;/p&gt;
&lt;h4 id=&#34;chown&#34;&gt;chown&lt;/h4&gt;
&lt;p&gt;改变文件的所属用户和所属组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-R 修改指定目录及其子目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改a目录的用户和组为 xjj&lt;br&gt;
&lt;code&gt;chown -R xjj:xjj a&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;chmod&#34;&gt;chmod&lt;/h4&gt;
&lt;p&gt;改变文件的访问权限。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;u表示当前用户&lt;br&gt;
g表示同组用户&lt;br&gt;
o表示其他用户&lt;br&gt;
a表示所有用户&lt;br&gt;
r表示可读&lt;br&gt;
w表示可写&lt;br&gt;
x表示可执行&lt;br&gt;
用数字来表示权限（r=4，w=2，x=1，-=0）,7：表示可读可写可执行，4+2+1,6：表示可读可写，4+2&lt;br&gt;
-R 修改指定目录及其子目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给a.sh文件增加执行权限（这个太常用了)&lt;br&gt;
&lt;code&gt;chmod a+x a.sh&lt;/code&gt;&lt;br&gt;
g、o 还有 u 分别表示 group（用户组）、others（其他用户） 和 user（用户），+ 和 - 分别表示增加和去掉相应的权限。&lt;br&gt;
&lt;code&gt;chmod go-rw t.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;####df(report file system disk space usage)&lt;br&gt;
显示文件系统磁盘空间的使用情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-h 以人类可读的方式显示，KD，Mb，GB等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;du-estimate-file-space-usage&#34;&gt;du  (estimate file space usage)&lt;/h4&gt;
&lt;p&gt;显示指定的目录及其子目录已使用的磁盘空间的总和&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-s显示指定目录的总和&lt;br&gt;
-a  显示目录中所有文件的大小。&lt;br&gt;
-h以人类可读的方式显示，Kb，Mb，G8等&lt;br&gt;
-d参数指定查看目录的深度 # 只查看1级目录的信息&lt;br&gt;
-d 0 ~&lt;br&gt;
查看文件大小&lt;br&gt;
&lt;code&gt;du -h file&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;dd&#34;&gt;dd&lt;/h4&gt;
&lt;p&gt;转换和复制文件,也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。&lt;/p&gt;
&lt;p&gt;dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file，输入文件）和of（output file，输出文件）改变。&lt;/p&gt;
&lt;p&gt;bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如&#39;K&#39;，&#39;M&#39;，&#39;G&#39;等单位），&lt;br&gt;
count用于指定块数量。&lt;br&gt;
conv=ucase  将输出的英文字符转换为大写再写入文件&lt;/p&gt;
&lt;p&gt;输出到test文件&lt;br&gt;
&lt;code&gt;dd of=test bs=10 count=1&lt;/code&gt;&lt;br&gt;
输出到标准输出&lt;br&gt;
&lt;code&gt;dd if=/dev/stdin of=/dev/stdout bs=10 count=1&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;mount&#34;&gt;mount&lt;/h4&gt;
&lt;p&gt;-o 操作选项&lt;br&gt;
-t 文件系统类型&lt;br&gt;
-w|--rw|--ro权限&lt;/p&gt;
&lt;p&gt;从/dev/zero设备创建一个容量为 256M 的空文件：&lt;br&gt;
&lt;code&gt;dd if=/dev/zero of=virtual.img bs=1M count=256&lt;/code&gt;&lt;br&gt;
格式化磁盘：&lt;br&gt;
&lt;code&gt;sudo mkfs.ext4 virtual.img&lt;/code&gt;&lt;br&gt;
挂载我们创建的虚拟磁盘镜像到/mnt目录：&lt;br&gt;
&lt;code&gt;mount -o loop -t ext4 virtual.img /mnt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;卸载已挂载磁盘&lt;br&gt;
&lt;code&gt;sudo umount /mnt&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;free&#34;&gt;free&lt;/h4&gt;
&lt;p&gt;显示当前内存和交换空间的使用情况&lt;/p&gt;
&lt;h4 id=&#34;date&#34;&gt;date&lt;/h4&gt;
&lt;p&gt;显示系统当前时间&lt;/p&gt;
&lt;h4 id=&#34;top&#34;&gt;top&lt;/h4&gt;
&lt;p&gt;显示当前系统中耗费资源最多的进程&lt;br&gt;
查看某个进程中的线程状态&lt;br&gt;
&lt;code&gt;top -H -p pid&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;ps&#34;&gt;ps&lt;/h4&gt;
&lt;p&gt;较少单独使用，配参数根据需求，ps ef或者ps-aux&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-e 显示所有选程，环境变量&lt;br&gt;
-f 全格式显示&lt;br&gt;
-a 显示所有用户的所有进程（包括其它用户）&lt;br&gt;
-u 按用户名和启动时间的顺序来显示进程&lt;br&gt;
-x 显示无控制终端的进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;kill&#34;&gt;kill&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;-9 kill -9 pid强制杀死一个进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;ifconfig&#34;&gt;ifconfig&lt;/h4&gt;
&lt;p&gt;网卡网络配置，常用于查看当前IP地址&lt;br&gt;
ifconfig etho 192.168.12.22 修改系统IP（重品后失效）&lt;/p&gt;
&lt;h4 id=&#34;ping&#34;&gt;ping&lt;/h4&gt;
&lt;p&gt;ping baidu.com 测试网络的连通&lt;/p&gt;
&lt;h4 id=&#34;hostname&#34;&gt;hostname&lt;/h4&gt;
&lt;p&gt;查看主机名&lt;/p&gt;
&lt;h4 id=&#34;关机&#34;&gt;关机&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;sudo shutdown now&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sudo reboot now&lt;/code&gt;&lt;br&gt;
&lt;code&gt;shutdown -c&lt;/code&gt;取消关机   &lt;br&gt;
&lt;code&gt;shutdown -p&lt;/code&gt;立即关机，无提示、延时&lt;br&gt;
&lt;code&gt;shutdown -s&lt;/code&gt;关机&lt;br&gt;
&lt;code&gt;shutdown -r&lt;/code&gt;重启&lt;br&gt;
&lt;code&gt;shutdown -f&lt;/code&gt;强行关闭应用程序&lt;br&gt;
&lt;code&gt;shutdown -l&lt;/code&gt;注销当前用户&lt;br&gt;
&lt;code&gt;shutdown -s -t&lt;/code&gt; 设置关机倒计时&lt;br&gt;
&lt;code&gt;shutdown -h&lt;/code&gt;休眠&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;export&#34;&gt;export&lt;/h4&gt;
&lt;p&gt;设定一些环境变量，env命令能看到当前系统中所有的环境变量。比如，下面设置的就是jdk的。&lt;br&gt;
&lt;code&gt;export PATH=$PATH:/home/xjj/jdk/bin&lt;/code&gt;&lt;br&gt;
&lt;code&gt;source&lt;/code&gt;命令来让其立即生效&lt;br&gt;
set	显示当前 Shell 所有变量，包括&lt;strong&gt;其内建环境变量，用户自定义变量及导出的环境变量。&lt;/strong&gt;&lt;br&gt;
env	显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。&lt;br&gt;
export	显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。&lt;/p&gt;
&lt;p&gt;/etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。&lt;br&gt;
&lt;code&gt;unset&lt;/code&gt;&lt;br&gt;
命令删除一个环境变量&lt;/p&gt;
&lt;h1 id=&#34;压-解缩&#34;&gt;压、解缩&lt;/h1&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;gzip&#34;&gt;gzip&lt;/h4&gt;
&lt;p&gt;压缩文件成者文件夹&lt;br&gt;
-d解压缩文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;zip&#34;&gt;zip&lt;/h4&gt;
&lt;p&gt;将目录 /home/shiyanlou/Desktop 打包成一个文件&lt;br&gt;
&lt;code&gt;zip -r -9 -q -o -l shiyanlou.zip /home/shiyanlou/Desktop&lt;/code&gt;&lt;br&gt;
-r 参数表示递归打包包含子目录的全部内容，9 压缩级别最大1 最小,&lt;br&gt;
-q 参数表示为安静模式，即不向屏幕输出信息，&lt;br&gt;
-o，表示输出文件,&lt;br&gt;
-l 参数将 LF 转换为 CR+LF 来达到win/linux兼容。&lt;/p&gt;
&lt;h4 id=&#34;unzip&#34;&gt;unzip&lt;/h4&gt;
&lt;p&gt;将文件解压到指定目录：&lt;br&gt;
&lt;code&gt;unzip -q shiyanlou.zip -d ziptest&lt;/code&gt;&lt;br&gt;
-q 使用安静模式&lt;br&gt;
-d指定路径&lt;br&gt;
-l 不解压只想查看压缩包的内容&lt;br&gt;
-O（英文字母，大写 o）参数指定编码类型：(win默认会采用 GBK , Linux 默认 UTF-8 )&lt;br&gt;
unzip -O GBK 中文压缩文件.zip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;tar&#34;&gt;tar&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;tar -xzf shiyanlou.tar.gz -C tardir&lt;/code&gt;&lt;br&gt;
压缩文件格式&lt;code&gt;-z/*.tar.gz&lt;/code&gt;，&lt;code&gt;-J/*.tar.xz&lt;/code&gt;	，&lt;code&gt;-j/*tar.bz2&lt;/code&gt;&lt;br&gt;
-P 保留绝对路径符&lt;br&gt;
-v压缩的过程中显示文件&lt;br&gt;
-c 表示创建一个 tar 包文件&lt;br&gt;
-f 用于指定创建的文件名，件名必须紧跟在 -f 参数之后&lt;br&gt;
-p在其他主机还原时希望保留文件的属性&lt;br&gt;
-h 备份链接指向的源文件而不是链接本身&lt;br&gt;
-x解包一个文件&lt;br&gt;
-C 指定保存路径&lt;br&gt;
-t只查看不解包文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;vim&#34;&gt;VIM&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-de0ac15d12403184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改文本&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-b6f40fe5095da55e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
定位命令&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-40f8d2a91c245485?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
替换和取消命令&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-3192c0b29770869f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
删除命令&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-52358b7bd810c2b8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
常用快捷键&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/18339009-c8dc68e3552b4958?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;alias&#34;&gt;alias&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;alias a=&#39;find . -size +10M -type f -print0 | xargs -0 ls -Ssh | sort -z&#39;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;关闭防火墙&#34;&gt;关闭防火墙&lt;/h4&gt;
&lt;p&gt;systemctl stop firewalld.service&lt;/p&gt;
&lt;h4 id=&#34;禁止防火墙开机启动&#34;&gt;禁止防火墙开机启动&lt;/h4&gt;
&lt;p&gt;systemctl disable firewalld.service&lt;/p&gt;
&lt;h4 id=&#34;关闭selinux&#34;&gt;关闭SELinux&lt;/h4&gt;
&lt;p&gt;nano -w /etc/selinux/config&lt;br&gt;
将SELINUX=enforcing改为SELINUX=disabled保存并退出:^x-&amp;gt;y-&amp;gt;回车&lt;/p&gt;
&lt;h1 id=&#34;计划任务&#34;&gt;计划任务&lt;/h1&gt;
&lt;p&gt;查看添加了哪些任务&lt;code&gt;crontab -l&lt;/code&gt;&lt;br&gt;
添加一个计划任务&lt;code&gt;crontab -e&lt;/code&gt;&lt;br&gt;
删除任务&lt;code&gt;crontab -r&lt;/code&gt;&lt;br&gt;
&lt;code&gt;分 小时 天 月 星期 user-name command to be executed&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动 rsyslog，以便我们可以通过日志中的信息来了解我们的任务是否真正的被执行了&lt;br&gt;
&lt;code&gt;sudo apt-get install -y rsyslog&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sudo service rsyslog start&lt;/code&gt;( Ubuntu 会默认自行启动不需要手动启动)&lt;br&gt;
&lt;code&gt;sudo cron －f &amp;amp;&lt;/code&gt;(实验环境中 crontab 也是不被默认启动的，同时不能在后台由 upstart 来管理，所以需要我们来启动它)&lt;/p&gt;
&lt;p&gt;每分钟我们会在/home/shiyanlou 目录下创建一个以当前的年月日时分秒为名字的空白文件&lt;br&gt;
&lt;code&gt;*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看到执行任务命令之后在日志中的信息反馈&lt;br&gt;
&lt;code&gt;sudo tail -f /var/log/syslog&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;有选择的执行命令&#34;&gt;有选择的执行命令&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;which cowsay&amp;gt;/dev/null &amp;amp;&amp;amp; echo &amp;quot;exist&amp;quot; || echo &amp;quot;not exist&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;&amp;amp;&amp;amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回 0 则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果&lt;/code&gt;&lt;br&gt;
&lt;code&gt;||在这里就是与&amp;amp;&amp;amp;相反的控制效果，当上一条命令执行结果为 ≠0($?≠0)时则执行它后面的命令&lt;/code&gt;&lt;br&gt;
echo $?&lt;/p&gt;
">Linux命令</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>