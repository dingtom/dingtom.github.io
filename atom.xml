<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dingtom.github.io</id>
    <title>Tomding&apos;s Blog</title>
    <updated>2021-03-29T07:54:11.817Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dingtom.github.io"/>
    <link rel="self" href="https://dingtom.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://dingtom.github.io/images/avatar.png</logo>
    <icon>https://dingtom.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Tomding&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[模型调参]]></title>
        <id>https://dingtom.github.io/post/mo-xing-diao-can/</id>
        <link href="https://dingtom.github.io/post/mo-xing-diao-can/">
        </link>
        <updated>2020-12-01T03:40:40.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-48e19a2cced9c78e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="贪心调参-坐标下降">贪心调参 （坐标下降）</h1>
<p>所谓贪心算法是指，在对问题求解时，总是做出在<s>当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的**局部最优解</s>。</p>
<p><s>选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）</s></p>
<h2 id="贪心算法的基本思路">贪心算法的基本思路</h2>
<blockquote>
<p>1.建立数学模型来描述问题<br>
2.把求解的问题分成若干个子问题<br>
3.对每个子问题求解，得到子问题的局部最优解<br>
4.把子问题的解局部最优解合成原来问题的一个解</p>
</blockquote>
<h2 id="例子">例子</h2>
<p>有一个背包，最多能承载150斤的重量，现在有7个物品，重量分别为[35, 30, 60, 50, 40, 10, 25]，它们的价值分别为[10, 40, 30, 50, 35, 40, 30]</p>
<p>分别求出子问题的最优解再堆叠出全局最优解</p>
<blockquote>
<p>按照制订的规则（价值）进行计算，顺序是：4 2 6 5 。<br>
最终的总重量是：130。<br>
最终的总价值是：165。<br>
按照制订的规则（重量）进行计算，顺序是：6 7 2 1 5 。<br>
最终的总重量是：140。<br>
最终的总价值是：155。<br>
按照制订的规则（单位密度）进行计算，顺序是：6 2 7 4 1。<br>
最终的总重量是：150。<br>
最终的总价值是：170。</p>
</blockquote>
<p>三、该算法存在的问题<br>
不能保证求得的最后解是最佳的<br>
不能用来求最大值或最小值的问题<br>
只能求满足某些约束条件的可行解的范围<br>
四、贪心算法适用的问题</p>
<h2 id="贪心策略适用的前提是">贪心策略适用的前提是：</h2>
<blockquote>
<p>1、原问题复杂度过高；<br>
2、求全局最优解的数学模型难以建立；<br>
3、求全局最优解的计算量过大；<br>
4、没有太大必要一定要求出全局最优解，“比较优”就可以。</p>
</blockquote>
<p>坐标下降法是一类优化算法，其最大的优势在于不用计算待优化的目标函数的梯度。不循环使用各个参数进行调整，而是贪心地选取了对整体模型性能影响最大的参数。参数对整体模型性能的影响力是动态变化的，故每一轮坐标选取的过程中，这种方法在对每个坐标的下降方向进行一次直线搜索（line search）</p>
<pre><code>#  -------------------------------贪心调参 （坐标下降）-----------------------------------
objective = ['regression', 'regression_l1', 'mape', 'huber', 'fair']
num_leaves = [3, 5, 10, 15, 20, 40, 55]
max_depth = [3, 5, 10, 15, 20, 40, 55]
greedy_parameters_lgb = dict()
greedy_score = 100
for o in objective:
    score = np.mean(cross_val_score(LGBMRegressor(objective=o), 
                                    X=x_train_tree, y=y_train_tree, verbose=0, cv=5, 
                                    scoring=make_scorer(mean_absolute_error)))
    if greedy_score &gt; score:
        greedy_parameters_lgb['objective'] = o
        greedy_score = score
greedy_score = 100
for l in num_leaves:
    score = np.mean(cross_val_score(LGBMRegressor(objective=greedy_parameters_lgb['objective'],
                                                  num_leaves=l), 
                                    X=x_train_tree, y=y_train_tree, verbose=0, cv=5, 
                                    scoring=make_scorer(mean_absolute_error)))
    if greedy_score &gt; score:
        greedy_parameter_lgb['num_leaves'] = l
        greedy_score = score
greedy_score = 100
for d in max_depth:
    score = np.mean(cross_val_score(LGBMRegressor(objective=greedy_parameters_lgb['objective'],
                                                  num_leaves=greedy_parameters_lgb['num_leaves'],
                                                  max_depth=d), 
                                    X=x_train_tree, y=y_train_tree, verbose=0, cv=5, 
                                    scoring=make_scorer(mean_absolute_error)))
    if greedy_score &gt; score:
        greedy_parameters_lgb['max_depth'] = d
        greedy_score = score
print(greedy_parameter_lgb)  
print(np.mean(cross_val_score(LGBMRegressor(**greedy_parameter_lgb), 
                        X=x_train_tree, y=y_train_tree, verbose=0, cv=5, scoring=make_scorer(mean_absolute_error))))
</code></pre>
<h1 id="网格调参gridsearchcv">网格调参GridSearchCV</h1>
<p>作用是在指定的范围内可以自动调参，只需将参数输入即可得到最优化的结果和参数。相对于人工调参更省时省力，相对于for循环方法更简洁灵活，不易出错。</p>
<pre><code> # ------------------------------------Grid Search 调参---------------------------------
clf_lgb = GridSearchCV(LGBMRegressor(), cv=5,
                       {'objective': ['regression', 'regression_l1', 'mape', 'huber', 'fair'],
                        'num_leaves': [3, 5, 10, 15, 20, 40, 55], 
                        'max_depth': [3, 5, 10, 15, 20, 40, 55]})
clf_lgb = clf.fit(x_train_tree, y_train_tree)
print(clf_lgb.best_params_)
print(np.mean(cross_val_score(LGBMRegressor(**clf_lgb.best_params_), 
                        X=x_train_tree, y=y_train_tree, verbose=0, cv=5, scoring=make_scorer(mean_absolute_error))))
</code></pre>
<h1 id="贝叶斯调参">贝叶斯调参</h1>
<p>贝叶斯优化<s>通过基于目标函数的过去评估结果建立替代函数（概率模型），来找到最小化目标函数的值</s>。贝叶斯方法与随机或网格搜索的不同之处在于，它~~在尝试下一组超参数时，会参考之前的评估结果，因此可以省去很多无用功。~~超参数的评估代价很大，因为它要求使用待评估的超参数训练一遍模型，而许多深度学习模型动则几个小时几天才能完成训练，并评估模型，因此耗费巨大。贝叶斯调参发使用不断更新的概率模型，通过推断过去的结果来“集中”有希望的超参数。</p>
<pre><code># -----------------------------------------贝叶斯调参--------------------------
def bayes_cv_lgb(num_leaves, max_depth, subsample, min_child_samples):
    val = cross_val_score(LGBMRegressor(objective='regression_l1',
                                        num_leaves=int(num_leaves),  
                                        # 优化只能优化连续超参数加上int()转为离散超参数。
                                        max_depth=int(max_depth),
                                        subsample = subsample,
                                        min_child_samples = int(min_child_samples)),
                          X=x_train_tree, y=y_train_tree, verbose=0, cv=5, 
                          scoring=make_scorer(mean_absolute_error)).mean()
    return 1 - val  # 只支持最大值，需要在前面加上负号，


bo_lgb = BayesianOptimization(bayes_cv,
                             {'num_leaves': (2, 100), 
                              'max_depth': (2, 100),
                              'subsample': (0.1, 1),
                              'min_child_samples' : (2, 100)})
bo_lgb.maximize()
print(bo_lgb.max)
bo_parameters_lgb = bo_lgb.max['params']
for i in ['num_leaves', 'max_depth', 'min_child_samples']:
    bo_parameters_lgb[i] = int(bo_parameters_lgb[i])
print(np.mean(cross_val_score(LGBMRegressor(**bo_parameters), 
                        X=x_train_tree, y=y_train_tree, verbose=0, cv=5, 
                        scoring=make_scorer(mean_absolute_error)))    )
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[特征构造、选择]]></title>
        <id>https://dingtom.github.io/post/te-zheng-gou-zao-xuan-ze/</id>
        <link href="https://dingtom.github.io/post/te-zheng-gou-zao-xuan-ze/">
        </link>
        <updated>2020-12-01T03:36:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="特征构造">特征构造</h1>
<p>统计量特征：计数、求和、比例、标准差等<br>
时间特征：相对时间、绝对时间，节假日，双休日等<br>
地理信息：分桶<br>
非线性变换：取log、平方、根号<br>
数据分桶：等频、等距分桶、Dest-KS分桶、卡方分桶<br>
特征组合、交叉：人、商品</p>
<blockquote>
<p><strong>数据分桶</strong><br>
等频分桶：区间的边界值要经过选择,使得每个区间包含大致相等的实例数量。<br>
等距分桶：从最小值到最大值之间,均分为 N 等份；<br>
Best-KS分桶：类似利用基尼指数进行二分类；<br>
卡方分桶：自底向上的(即基于合并的)数据离散化方法。它依赖于卡方检验：具有最小卡方值的相邻区间合并在一起,直到满足确定的停止准则。<br>
<strong>为什么要做数据分桶呢？</strong><br>
离散后<s>稀疏向量内积乘法运算速度更快，计算结果也方便存储</s>，容易扩展；<br>
离散后的特征<s>对异常值更具鲁棒性</s>，如 age&gt;30 为 1 否则为 0，对于年龄为 200 的也不会对模型造成很大的干扰；<br>
LR 属于广义线性模型，表达能力有限，<s>经过离散化后，每个变量有单独的权重，这相当于引入了非线性，能够提升模型的表达能力，加大拟合</s>；<br>
离散后特征<s>可以进行特征交叉，提升表达能力，由 M+N 个变量编程 M*N 个变量，进一步引入非线形，提升了表达能力</s>；<br>
特征离散后模型更稳定，如用户年龄区间，不会因为用户年龄长了一岁就变化<br>
当然还有很多原因，LightGBM 在改进 XGBoost 时就增加了数据分桶，增强了模型的泛化性。</p>
</blockquote>
<h1 id="特征选择">特征选择</h1>
<h2 id="特征选择主要有两个功能">特征选择主要有两个功能：</h2>
<p>减少特征数量、降维，使模型泛化能力更强，减少过拟合<br>
增强对特征和特征值之间的理解</p>
<h2 id="从两个方面考虑来选择特征">从两个方面考虑来选择特征：</h2>
<p><s>特征是否发散</s>：如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。</p>
<p><s>特征与目标的相关性</s>：这点比较显见，与目标相关性高的特征，应当优选选择。</p>
<h1 id="过滤式filter">过滤式（filter）：</h1>
<p>概述：按照发散性或者相关性<s>对各个特征进行评分</s>，设定阈值或者待选择阈值的个数，<s>选择特征。然后再训练学习器。<s>特征选择过程与</s>后续学习器无关</s></p>
<p>方法： Relief、方差选择、相关系数、卡方检验、互信息</p>
<ul>
<li>
<p>数值型特征，方差很小的特征可不要</p>
</li>
<li>
<p>分类特征,取值个数高度偏斜的那种可以先去掉</p>
</li>
<li>
<p>相关系数排序<br>
选择相关系数大于阈值的部分特征；（当然有时候根据字段含义也可以选）<br>
连续数据，正态分布，线性关系，用pearson相关系数是最恰当，当然用spearman相关系数也可以，效率没有pearon相关系数高。上述任一条件不满足，就用spearman相关系数，不能用pearson相关系数。<br>
两个定序测量数据（顺序变量）之间也用spearman相关系数，不能用pearson相关系数。Pearson相关系数的一个明显缺陷是，作为特征排序机制，他只对线性关系敏感。如果关系是非线性的，即便两个变量具有一一对应的关系，Pearson相关性也可能会接近0。</p>
</li>
<li>
<p>利用假设检验得到特征与输出值之间的相关性<br>
方法有比如卡方检验、t检验、F检验等。<br>
卡方检验一般是检查离散变量与离散变量的相关性，当然离散变量的相关性信息增益和信息增益比也是不错的选择（可以通过决策树模型来评估来看）</p>
</li>
<li>
<p>互信息<br>
利用互信息从信息熵的角度分析相关性</p>
</li>
</ul>
<h2 id="包裹式wrapper">包裹式（wrapper）：</h2>
<p><s>确定模型和评价准则之后，对特征空间的不同子集做交叉验证，进而搜索最佳特征子集</s></p>
<h3 id="方法lvmlas-vegas-wrapper递归特征消除算法-基于机器学习模型的特征排序">方法：LVM（Las Vegas Wrapper）递归特征消除算法, 基于机器学习模型的特征排序</h3>
<h3 id="主要思想">主要思想：</h3>
<p>包裹式从初始特征集合中不断的选择特征子集，训练学习器，根据学习器的性能来对子集进行评价，直到选择出最佳的子集。包裹式特征选择直接针对给定学习器进行优化。</p>
<h3 id="优缺点">优缺点：</h3>
<p>从最终学习器的性能来看，包裹式比过滤式更好；<br>
计算开销通常比过滤式特征选择要大得多。</p>
<p>特征子集的搜索问题，最容易想到的办法是穷举法，还可以在拉斯维加斯方法框架下使用随机策略进行子集搜索（Las Vegas Wrapper，LVW）。但是由于LVW算法中特征子集搜索采用了随机策略，每次特征子集评价都需要训练学习器，计算开销很大，如果初始特征数很多，算法可能运行很长时间都达不到停止条件，若有运行时间限制，可能给不出解。<br>
因此，我们通常使用的是贪心算法：如前向搜索（在最优的子集上逐步增加特征，直到增加特征并不能使模型性能提升为止）、后向搜索、双向搜索（将前向搜索和后向搜索相结合）。</p>
<h2 id="嵌入式embedding">嵌入式（embedding）：</h2>
<p>概述：<s>结合过滤式和包裹式，学习器训练过程中自动进行了特征选择</s>。先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。</p>
<h3 id="方法lrl1-决策树-lasso回归">方法：LR+L1、决策树、lasso回归</h3>
<h3 id="主要思想-2">主要思想：</h3>
<p>在过滤式和包裹式特征选择方法中，特征选择过程与学习器训练过程有明显的分别。而嵌入式特征选择在学习器训练过程中自动地进行特征选择。</p>
<p>嵌入式选择最常用的是L1 正则化和L2正则化</p>
<blockquote>
<p>正则化项越大，模型越简单，系数越小，<s>当正则化项增大到一定程度时，所有的特征系数都会趋于0，在这个过程中，会有一部分特征的系数先变成0。也就实现了特征选择过程</s>。逻辑回归、线性回归、决策树都可以当作正则化选择特征的基学习器，<s>只有可以得到特征系数或者可以得到特征重要度的算法才可以作为嵌入式选择的基学习器。</s></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[异常值检测]]></title>
        <id>https://dingtom.github.io/post/yi-chang-zhi-jian-ce/</id>
        <link href="https://dingtom.github.io/post/yi-chang-zhi-jian-ce/">
        </link>
        <updated>2020-11-30T14:04:55.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="简单统计">简单统计</h1>
<pre><code>df.describe()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-6a679dfcfb9de935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="散点图">散点图</h1>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-6be9fc217cd4afbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="3原则">3∂原则</h1>
<p>**这个原则有个条件：数据需要服从正态分布。**在3∂原则下，**异常值如超过3倍标准差，那么可以将其视为异常值。**正负3∂的概率是99.7%，那么距离平均值3∂之外的值出现的概率为P(|x-u| &gt; 3∂) &lt;= 0.003，属于极个别的小概率事件。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-7248f7ed5f503f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h1 id="箱型图">箱型图</h1>
<p>利用箱型图的四分位距（IQR）对异常值进行检测<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-be96c9561d21b050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
**四分位距(IQR)就是上四分位与下四分位的差值。**而我们通过IQR的1.5倍为标准，**规定：超过（上四分位+1.5倍IQR距离，或者下四分位-1.5倍IQR距离）的点为异常值。**下面是Python中的代码实现，主要使用了numpy的percentile方法。</p>
<pre><code>Percentile = np.percentile(df['length'],[0,25,50,75,100])
IQR = Percentile[3] - Percentile[1]
UpLimit = Percentile[3]+ageIQR*1.5
DownLimit = Percentile[1]-ageIQR*1.5
</code></pre>
<p>也可以使用seaborn的可视化方法boxplot来实现：</p>
<pre><code>f,ax=plt.subplots(figsize=(10,8))
sns.boxplot(y='length',data=df,ax=ax)
plt.show()
</code></pre>
<h1 id="基于模型检测">基于模型检测</h1>
<blockquote>
<p>**构建一个概率分布模型，并计算对象符合该模型的概率，把具有低概率的对象视为异常点。**如果模型是簇的集合，则异常是不显著属于任何簇的对象；如果模型是回归时，异常是相对远离预测值的对象。<br>
离群点的概率定义：离群点是一个对象，关于数据的概率分布模型，它具有低概率。<strong>这种情况的前提是必须知道数据集服从什么分布，如果估计错误就造成了重尾分布。</strong></p>
</blockquote>
<p>优缺点：（1）有坚实的统计学理论基础，当存在充分的数据和所用的检验类型的知识时，这些检验可能非常有效；（2）对于多元数据，可用的选择少一些，并且对于高维数据，这些检测可能性很差。</p>
<h1 id="基于近邻度的离群点检测">基于近邻度的离群点检测</h1>
<p>统计方法是**利用数据的分布来观察异常值，一些方法甚至需要一些分布条件，**而在实际中数据的分布很难达到一些假设条件，在使用上有一定的局限性。</p>
<blockquote>
<p>确定数据集的有意义的邻近性度量比确定它的统计分布更容易。这种方法比统计学方法更一般、更容易使用，因为一个对象的离群点得分由到它的k-最近邻（KNN）的距离给定。<br>
需要注意的是：离群点得分对k的取值高度敏感。**如果k太小，则少量的邻近离群点可能导致较低的离群点得分；**如果K太大，则点数少于k的簇中所有的对象可能都成了离群点。为了使该方案对于k的选取更具有鲁棒性，可以使用k个最近邻的平均距离。</p>
</blockquote>
<p>优缺点：（1）简单；（2）缺点：基于邻近度的方法需要O(m2)时间，大数据集不适用；（3）该方法对参数的选择也是敏感的；（4）不能处理具有不同密度区域的数据集，因为它使用全局阈值，不能考虑这种密度的变化。</p>
<h1 id="基于密度的离群点检测">基于密度的离群点检测</h1>
<blockquote>
<p>从基于密度的观点来说，<strong>离群点是在低密度区域中的对象。基于密度的离群点检测与基于邻近度的离群点检测密切相关，因为密度通常用邻近度定义。</strong></p>
</blockquote>
<p>一种常用的定义密度的方法是，定义密度为到k个最近邻的平均距离的倒数。如果该距离小，则密度高，反之亦然。另一种密度定义是使用<strong>DBSCAN聚类</strong>算法使用的密度定义，即一个对象周围的密度等于该对象指定距离d内对象的个数。</p>
<p>优缺点：（1）给出了对象是离群点的定量度量，并且即使数据具有不同的区域也能够很好的处理；（2）与基于距离的方法一样，这些方法必然具有O(m2)的时间复杂度。对于低维数据使用特定的数据结构可以达到O(mlogm)；（3）参数选择是困难的。虽然LOF算法通过观察不同的k值，然后取得最大离群点得分来处理该问题，但是，仍然需要选择这些值的上下界。</p>
<h1 id="基于聚类的方法来做异常点检测">基于聚类的方法来做异常点检测</h1>
<blockquote>
<p>基于聚类的离群点：一个对象是基于聚类的离群点，如果该对象不强属于任何簇，那么该对象属于离群点。</p>
</blockquote>
<p>离群点对初始聚类的影响：如果通过聚类检测离群点，则由于离群点影响聚类，存在一个问题：结构是否有效。**这也是k-means算法的缺点，对离群点敏感。**为了处理该问题，可以使用如下方法：对象聚类，删除离群点，对象再次聚类（这个不能保证产生最优结果）。</p>
<p>优缺点：（1）基于线性和接近线性复杂度（k均值）的聚类技术来发现离群点可能是高度有效的；（2）簇的定义通常是离群点的补，因此可能同时发现簇和离群点；（3）产生的离群点集和它们的得分可能非常依赖所用的簇的个数和数据中离群点的存在性；（4）聚类算法产生的簇的质量对该算法产生的离群点的质量影响非常大。</p>
<h1 id="专门的离群点检测">专门的离群点检测</h1>
<p>其实以上说到聚类方法的本意是是无监督分类，并不是为了寻找离群点的，只是恰好它的功能可以实现离群点的检测，算是一个衍生的功能。</p>
<p>除了以上提及的方法，还有两个专门用于检测异常点的方法比较常用：<strong>One Class SVM和Isolation Forest</strong></p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="简单统计">简单统计</h1>
<pre><code>df.describe()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-6a679dfcfb9de935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="散点图">散点图</h1>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-6be9fc217cd4afbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="3原则">3∂原则</h1>
<p>**这个原则有个条件：数据需要服从正态分布。**在3∂原则下，**异常值如超过3倍标准差，那么可以将其视为异常值。**正负3∂的概率是99.7%，那么距离平均值3∂之外的值出现的概率为P(|x-u| &gt; 3∂) &lt;= 0.003，属于极个别的小概率事件。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-7248f7ed5f503f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h1 id="箱型图">箱型图</h1>
<p>利用箱型图的四分位距（IQR）对异常值进行检测<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-be96c9561d21b050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
**四分位距(IQR)就是上四分位与下四分位的差值。**而我们通过IQR的1.5倍为标准，**规定：超过（上四分位+1.5倍IQR距离，或者下四分位-1.5倍IQR距离）的点为异常值。**下面是Python中的代码实现，主要使用了numpy的percentile方法。</p>
<pre><code>Percentile = np.percentile(df['length'],[0,25,50,75,100])
IQR = Percentile[3] - Percentile[1]
UpLimit = Percentile[3]+ageIQR*1.5
DownLimit = Percentile[1]-ageIQR*1.5
</code></pre>
<p>也可以使用seaborn的可视化方法boxplot来实现：</p>
<pre><code>f,ax=plt.subplots(figsize=(10,8))
sns.boxplot(y='length',data=df,ax=ax)
plt.show()
</code></pre>
<h1 id="基于模型检测">基于模型检测</h1>
<blockquote>
<p>**构建一个概率分布模型，并计算对象符合该模型的概率，把具有低概率的对象视为异常点。**如果模型是簇的集合，则异常是不显著属于任何簇的对象；如果模型是回归时，异常是相对远离预测值的对象。<br>
离群点的概率定义：离群点是一个对象，关于数据的概率分布模型，它具有低概率。<strong>这种情况的前提是必须知道数据集服从什么分布，如果估计错误就造成了重尾分布。</strong></p>
</blockquote>
<p>优缺点：（1）有坚实的统计学理论基础，当存在充分的数据和所用的检验类型的知识时，这些检验可能非常有效；（2）对于多元数据，可用的选择少一些，并且对于高维数据，这些检测可能性很差。</p>
<h1 id="基于近邻度的离群点检测">基于近邻度的离群点检测</h1>
<p>统计方法是**利用数据的分布来观察异常值，一些方法甚至需要一些分布条件，**而在实际中数据的分布很难达到一些假设条件，在使用上有一定的局限性。</p>
<blockquote>
<p>确定数据集的有意义的邻近性度量比确定它的统计分布更容易。这种方法比统计学方法更一般、更容易使用，因为一个对象的离群点得分由到它的k-最近邻（KNN）的距离给定。<br>
需要注意的是：离群点得分对k的取值高度敏感。**如果k太小，则少量的邻近离群点可能导致较低的离群点得分；**如果K太大，则点数少于k的簇中所有的对象可能都成了离群点。为了使该方案对于k的选取更具有鲁棒性，可以使用k个最近邻的平均距离。</p>
</blockquote>
<p>优缺点：（1）简单；（2）缺点：基于邻近度的方法需要O(m2)时间，大数据集不适用；（3）该方法对参数的选择也是敏感的；（4）不能处理具有不同密度区域的数据集，因为它使用全局阈值，不能考虑这种密度的变化。</p>
<h1 id="基于密度的离群点检测">基于密度的离群点检测</h1>
<blockquote>
<p>从基于密度的观点来说，<strong>离群点是在低密度区域中的对象。基于密度的离群点检测与基于邻近度的离群点检测密切相关，因为密度通常用邻近度定义。</strong></p>
</blockquote>
<p>一种常用的定义密度的方法是，定义密度为到k个最近邻的平均距离的倒数。如果该距离小，则密度高，反之亦然。另一种密度定义是使用<strong>DBSCAN聚类</strong>算法使用的密度定义，即一个对象周围的密度等于该对象指定距离d内对象的个数。</p>
<p>优缺点：（1）给出了对象是离群点的定量度量，并且即使数据具有不同的区域也能够很好的处理；（2）与基于距离的方法一样，这些方法必然具有O(m2)的时间复杂度。对于低维数据使用特定的数据结构可以达到O(mlogm)；（3）参数选择是困难的。虽然LOF算法通过观察不同的k值，然后取得最大离群点得分来处理该问题，但是，仍然需要选择这些值的上下界。</p>
<h1 id="基于聚类的方法来做异常点检测">基于聚类的方法来做异常点检测</h1>
<blockquote>
<p>基于聚类的离群点：一个对象是基于聚类的离群点，如果该对象不强属于任何簇，那么该对象属于离群点。</p>
</blockquote>
<p>离群点对初始聚类的影响：如果通过聚类检测离群点，则由于离群点影响聚类，存在一个问题：结构是否有效。**这也是k-means算法的缺点，对离群点敏感。**为了处理该问题，可以使用如下方法：对象聚类，删除离群点，对象再次聚类（这个不能保证产生最优结果）。</p>
<p>优缺点：（1）基于线性和接近线性复杂度（k均值）的聚类技术来发现离群点可能是高度有效的；（2）簇的定义通常是离群点的补，因此可能同时发现簇和离群点；（3）产生的离群点集和它们的得分可能非常依赖所用的簇的个数和数据中离群点的存在性；（4）聚类算法产生的簇的质量对该算法产生的离群点的质量影响非常大。</p>
<h1 id="专门的离群点检测">专门的离群点检测</h1>
<p>其实以上说到聚类方法的本意是是无监督分类，并不是为了寻找离群点的，只是恰好它的功能可以实现离群点的检测，算是一个衍生的功能。</p>
<p>除了以上提及的方法，还有两个专门用于检测异常点的方法比较常用：<strong>One Class SVM和Isolation Forest</strong></p>
<!-- more -->
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[异常值处理]]></title>
        <id>https://dingtom.github.io/post/yi-chang-zhi-chu-li/</id>
        <link href="https://dingtom.github.io/post/yi-chang-zhi-chu-li/">
        </link>
        <updated>2020-11-30T13:37:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="异常值检测特征分为类别特征和数字特征">异常值检测特征分为类别特征和数字特征</h1>
<h2 id="数字特征">数字特征</h2>
<p>相关性分析、查看特征的偏度和峰度、数字特征相互之间的关系可视化、多变量互相回归关系可视化、数字特征的频数可视化</p>
<h2 id="类别特征">类别特征</h2>
<p>ounique分布、箱形图可视化、小提琴图可视化、类别柱形图可视化</p>
<h1 id="异常值处理">异常值处理</h1>
<h2 id="箱线图没有对数据作任何限制性要求">箱线图(没有对数据作任何限制性要求)</h2>
<h2 id="3-sigmasigma符合正态分布">3-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>(Sigma)(符合正态分布）</h2>
<h2 id="box-cox转换处理有偏分布">BOX-COX转换（处理有偏分布）</h2>
<h2 id="长尾截断">长尾截断</h2>
<p>聚类、k近邻、One Class SVM、Isolation Forest</p>
<blockquote>
<p>关于高势集特征model，也就是类别中取值个数非常多的， 一般可以使用聚类的方式，然后独热</p>
</blockquote>
<h1 id="很多模型假设数据服从正态分布">很多模型假设数据服从正态分布</h1>
<p>数据整体<s>服从正态分布，样本均值和方差则相互独立</s>。当样本不服从正态分布时，可以做如下转换：</p>
<ul>
<li>
<p>线性变化z-scores：基于原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。将A的原始值x使用z-score标准化到x’</p>
</li>
<li>
<p>yeo-johnson变换：是幂变换（power transformation）的方法之一，通过构建一组单调函数对随机变量进行数据变换。</p>
</li>
<li>
<p>Boxcox变换：一种广义幂变换方法，是统计建模中常用的一种数据变换，用于连续的响应变量不满足正态分布的情况。在做线性回归的过程中，一般需要做线性模型假定。</p>
</li>
</ul>
<p>关于box-cox转换，一般是用于连续的变量不满足正态的时候，在做线性回归的过程中，一般线性模型假定:   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><mi>X</mi><mi>β</mi><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">Y=X\beta + \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>满足正态分布，但是利用实际数据建立回归模型时，个别变量的系数通不过。例如往往不可观测的误差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>可能是和预测变量相关的，不服从正态分布，于是给线性回归的最小二乘估计系数的结果带来误差，为了使模型满足线性性、独立性、方差齐性以及正态性，需改变数据形式，故应用BOX-COX转换。具体详情这里不做过多介绍，当然还有很多转换非正态数据分布的方式：<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-03d35f2ce4fcf3bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
在一些情况下（P值&lt;0.003）上述方法很难实现正态化处理，所以优先使用BOX-COX转换，但是当P值&gt;0.003时两种方法均可，优先考虑普通的平方变换。<br>
BOX-COX的变换公式：<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b259d819c0b52fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h1 id="别不平衡">别不平衡</h1>
<p>1.扩充数据集<br>
2.尝试其他评价指标：AUC等<br>
3.调整θ值<br>
4.重采样：过采样/欠采样<br>
5.合成样本： SMOTE<br>
6.选择其他模型：决策树等<br>
7.加权少类别的样本错分代价<br>
8.将大类分解成多个小类</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[缺失值处理]]></title>
        <id>https://dingtom.github.io/post/que-shi-zhi-chu-li/</id>
        <link href="https://dingtom.github.io/post/que-shi-zhi-chu-li/">
        </link>
        <updated>2020-11-30T09:16:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="删除">删除</h1>
<p><s>样本数据量十分大且缺失值不多</s>的情况下非常有效，但如果样本量本身不大且缺失也不少，那么不建议使用。</p>
<pre><code class="language-python">#删除数据表中含有空值的行
df.dropna(how='any')
</code></pre>
<h1 id="不处理">不处理</h1>
<p>补齐处理只是将未知值补以我们的主观估计值，不一定完全符合客观事实，一些模型无法应对具有缺失值的数据，因此要对缺失值进行处理。然而还有一些模型本身就可以应对具有缺失值的数据，此时无需对数据进行处理，比如<s>Xgboos等树模型</s>。</p>
<h1 id="分箱缺失值一个箱">分箱：（缺失值一个箱）</h1>
<p>虚拟变量其实就是缺失值的一种衍生变量。具体做法是通过判断特征值是否有缺失值来定义一个新的二分类变量。比如，特征为A含有缺失值，我们<s>衍生出一个新的特征B，如果A中特征值有缺失，那么相应的B中的值为1，如果A中特征值没有缺失，那么相应的B中的值为0。</s></p>
<pre><code>data_train['CabinCat'] = data_train['Cabin'].copy()
data_train.loc[ (data_train.CabinCat.notnull()), 'CabinCat' ] = &quot;No&quot;
data_train.loc[ (data_train.CabinCat.isnull()), 'CabinCat' ] = &quot;Yes&quot;

fig, ax = plt.subplots(figsize=(10,5))
sns.countplot(x='CabinCat', hue='Survived',data=data_train)
plt.show()
</code></pre>
<p><code>data_train[['Cabin','CabinCat']].head(10)</code></p>
<h1 id="补全">补全</h1>
<h2 id="均值-众数-中位数">均值、众数、中位数、</h2>
<p><s>对于定类数据：使用 众数（mode）填补</s>，比如一个学校的男生和女生的数量，男生500人，女生50人，那么对于其余的缺失值我们会用人数较多的男生来填补。<br>
<s>对于定量（定比）数据：使用平均数（mean）或中位数（median）填补</s>，比如一个班级学生的身高特征，对于一些同学缺失的身高值就可以使用全班同学身高的平均值或中位数来填补。一般如果特征分布为正太分布时，使用平均值效果比较好，而当分布由于异常值存在而不是正太分布的情况下，使用中位数效果比较好。</p>
<p>注：此方法虽然简单，但是不够精准，可能会引入噪声，或者会改变特征原有的分布。<strong>如果缺失值是随机性的，那么用平均值比较适合保证无偏，否则会改变原分布。</strong></p>
<pre><code>#使用price均值对NA进行填充
df['price'].fillna(df['price'].mean())
df['price'].fillna(df['price'].median())
</code></pre>
<h2 id="建模预测-多重插补-压缩感知补全-矩阵补全等">建模预测、多重插补、压缩感知补全、矩阵补全等</h2>
<p>利用其它变量做模型的输入进行缺失变量的预测，与我们正常建模的方法一样，只是目标变量变为了缺失值。如果其它特征变量与缺失变量无关，则预测的结果毫无意义。如果预测结果相当准确，则又说明这个变量完全没有必要进行预测，因为这必然是与特征变量间存在重复信息。</p>
<ul>
<li>
<p>回归预测：<br>
缺失值是连续的，即定量的类型，才可以使用回归来预测。</p>
</li>
<li>
<p>极大似然估计（Maximum likelyhood）：<br>
在缺失类型为随机缺失的条件下，假设模型对于完整的样本是正确的，那么通过观测数据的边际分布可以对未知参数进行极大似然估计（Little and Rubin）。这种方法也被称为忽略缺失值的极大似然估计，对于极大似然的参数估计实际中常采用的计算方法是期望值最大化(Expectation Maximization，EM）。该方法比删除个案和单值插补更有吸引力，它一个重要前提：适用于大样本。有效样本的数量足够以保证ML估计值是渐近无偏的并服从正态分布。但是这种方法可能会陷入局部极值，收敛速度也不是很快，并且计算很复杂，且仅限于线性模型。</p>
</li>
<li>
<p>多重插补（Mutiple imputation）：<br>
多值插补的思想来源于贝叶斯估计，认为待插补的值是随机的，它的值来自于已观测到的值。具体实践上通常是估计出待插补的值，然后再加上不同的噪声，形成多组可选插补值。根据某种选择依据，选取最合适的插补值。</p>
</li>
<li>
<p>热卡填补（Hot deck imputation）：<br>
热卡填充法是在完整数据中找到一个与它最相似的对象，然后用这个相似对象的值来进行填充。通常会找到超出一个的相似对象，在所有匹配对象中没有最好的，而是从中随机的挑选一个作为填充值。这个问题关键是不同的问题可能会选用不同的标准来对相似进行判定，以及如何制定这个判定标准。该方法概念上很简单，且利用了数据间的关系来进行空值估计，但缺点在于难以定义相似标准，主观因素较多。</p>
</li>
<li>
<p>K最近距离邻法（K-means clustering）<br>
通过K均值的聚类方法将所有样本进行聚类划分，然后再通过划分的种类的均值对各自类中的缺失值进行填补。归其本质还是通过找相似来填补缺失值。</p>
</li>
<li>
<p>多重插补：<br>
我们看到，以上提出的拟合和替换方法都是单一的插补方法，而多重插补弥补了单一插补的缺陷，它并没有试图去通过模拟值去估计每个缺失值，而是提出缺失数据值的一个随即样本（这些样本可以是不同的模型拟合结果的组合）。这种程序的实施恰当地反映了由于缺失值引起的不确定性，使得统计推断有效。多重插补推断可以分为以下3个步骤：</p>
</li>
</ul>
<blockquote>
<p>为每个缺失值产生一套可能的插补值，这些值反映了无响应模型的不确定性；<br>
每个插补数据集合都用针对完整数据集的统计方法进行统计分析；<br>
对来自各个插补数据集的结果，根据评分函数进行选择，产生最终的插补值；</p>
</blockquote>
<ul>
<li>随机森林：<br>
这也是Kaggle竞赛中大佬们经常使用的一个办法，具体实现方式与正常一样，只是将缺失值作为目标变量即可.</li>
</ul>
<pre><code>def set_missing_ages(df):

    # 把已有的数值型特征取出来丢进Random Forest Regressor中
    age_df = df[['Age','Fare', 'Parch', 'SibSp', 'Pclass']]

    # 乘客分成已知年龄和未知年龄两部分
    known_age = age_df[age_df.Age.notnull()].as_matrix()
    unknown_age = age_df[age_df.Age.isnull()].as_matrix()

    # y即目标年龄
    y = known_age[:, 0]

    # X即特征属性值
    X = known_age[:, 1:]

    # fit到RandomForestRegressor之中
    rfr = RandomForestRegressor(random_state=0, n_estimators=2000, n_jobs=-1)
    rfr.fit(X, y)

    # 用得到的模型进行未知年龄结果预测
    predictedAges = rfr.predict(unknown_age[:, 1:])
#     print predictedAges
    # 用得到的预测结果填补原缺失数据
    df.loc[ (df.Age.isnull()), 'Age' ] = predictedAges 

    return df, rfr
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Feature_Enginneering]]></title>
        <id>https://dingtom.github.io/post/feature_enginneering/</id>
        <link href="https://dingtom.github.io/post/feature_enginneering/">
        </link>
        <updated>2020-11-30T08:40:23.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-bea64e5029c97e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-58b1f785ea1bdd02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p>常见的特征工程包括：</p>
<h1 id="异常处理"><a href="https://dingtom.github.io/post/yi-chang-zhi-chu-li/">异常处理：</a></h1>
<p>通过箱线图（或 3-Sigma）分析删除异常值；<br>
BOX-COX 转换（处理有偏分布）；<br>
长尾截断；</p>
<h1 id="特征归一化标准化httpsdingtomgithubiopost">[特征归一化/标准化：](https://dingtom.github.io/post/</h1>
<p>标准化（转换为标准正态分布）；<br>
归一化（抓换到 [0,1] 区间）；<br>
针对幂律分布，可以采用公式：  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mi>x</mi></mrow><mrow><mn>1</mn><mo>+</mo><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>n</mi></mrow></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">log(\frac{1+x}{1+median})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></p>
<h1 id="数据分桶httpsdingtomgithubiopost">[数据分桶：](https://dingtom.github.io/post/</h1>
<p>等频分桶；<br>
等距分桶；<br>
Best-KS 分桶（类似利用基尼指数进行二分类）；<br>
卡方分桶；</p>
<h1 id="缺失值处理"><a href="https://dingtom.github.io/post/que-shi-zhi-chu-li/">缺失值处理：</a></h1>
<p>不处理（针对类似 XGBoost 等树模型）；<br>
删除（缺失数据太多）；<br>
插值补全，包括均值/中位数/众数/建模预测/多重插补/压缩感知补全/矩阵补全等；<br>
分箱，缺失值一个箱；<br>
#[特征构造：](https://dingtom.github.io/post/<br>
构造统计量特征，报告计数、求和、比例、标准差等；<br>
时间特征，包括相对时间和绝对时间，节假日，双休日等；<br>
地理信息，包括分箱，分布编码等方法；<br>
非线性变换，包括 log/ 平方/ 根号等；<br>
特征组合，特征交叉；<br>
仁者见仁，智者见智。</p>
<h1 id="特征筛选httpsdingtomgithubiopost">[特征筛选：](https://dingtom.github.io/post/</h1>
<p>过滤式（filter）：先对数据进行特征选择，然后在训练学习器，常见的方法有 Relief/方差选择发/相关系数法/卡方检验法/互信息法；<br>
包裹式（wrapper）：直接把最终将要使用的学习器的性能作为特征子集的评价准则，常见方法有 LVM（Las Vegas Wrapper） ；<br>
嵌入式（embedding）：结合过滤式和包裹式，学习器训练过程中自动进行了特征选择，常见的有 lasso 回归；</p>
<h1 id="降维">降维</h1>
<p>PCA/ LDA/ ICA；<br>
特征选择也是一种降维。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Modeling]]></title>
        <id>https://dingtom.github.io/post/modeling/</id>
        <link href="https://dingtom.github.io/post/modeling/">
        </link>
        <updated>2020-11-30T08:21:30.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-b2ff901cddb21e78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-a5371a595aa309c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.EDA]]></title>
        <id>https://dingtom.github.io/post/eda/</id>
        <link href="https://dingtom.github.io/post/eda/">
        </link>
        <updated>2020-11-30T08:20:15.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-9ba330f1c6a54599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="载入各种数据科学以及可视化库">载入各种数据科学以及可视化库:</h1>
<p>数据科学库 pandas、numpy、scipy；<br>
可视化库 matplotlib、seabon；<br>
其他；</p>
<h1 id="载入数据">载入数据：</h1>
<p>载入训练集和测试集；<br>
简略观察数据(head()+shape)；</p>
<h1 id="数据总览">数据总览:</h1>
<p>通过describe()来熟悉数据的相关统计量<br>
通过info()来熟悉数据类型</p>
<h1 id="判断数据缺失和异常">判断数据缺失和异常</h1>
<p>查看每列的存在nan情况<br>
异常值检测</p>
<h1 id="了解预测值的分布">了解预测值的分布</h1>
<p>总体分布概况（无界约翰逊分布等）<br>
查看skewness and kurtosis<br>
查看预测值的具体频数<br>
特征分为类别特征和数字特征，并对类别特征查看unique分布</p>
<h1 id="数字特征分析">数字特征分析</h1>
<p>相关性分析<br>
查看几个特征得 偏度和峰值<br>
每个数字特征得分布可视化<br>
数字特征相互之间的关系可视化<br>
多变量互相回归关系可视化<br>
类型特征分析<br>
unique分布</p>
<h1 id="类别特征箱形图可视化">类别特征箱形图可视化</h1>
<p>类别特征的小提琴图可视化<br>
类别特征的柱形图可视化类别<br>
特征的每个类别频数可视化(count_plot)</p>
<h1 id="用pandas_profiling生成数据报告">用pandas_profiling生成数据报告</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python]]></title>
        <id>https://dingtom.github.io/post/python/</id>
        <link href="https://dingtom.github.io/post/python/">
        </link>
        <updated>2020-11-30T08:13:07.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>== 比较值，is比较ID(内存地址）</li>
<li>and\or逻辑比较，&amp;|按位与\或</li>
<li>字符串拼接join()快，用加号拼接字符串因为字符串是不可变对象所以每次都会生成新对象</li>
<li>支持链式比较（两两相比加and）</li>
</ul>
<h1 id="随机数">随机数</h1>
<pre><code>随机种子：random.seed()
随机选择：random.choice(List)
随机打乱：random.shuffle(List)
随机整数：random.randint(a,b),生成区间内的整数
随机采样:random.sample(list18, samples)
随机小数：random.random()
习惯用numpy库，利用np.random.randn(5)生成5个随机小数
</code></pre>
<h1 id="global">global</h1>
<p>在函数声明 修改全局变量</p>
<pre><code>a=4
def f():
    global a 
    a=3 
f()
</code></pre>
<h1 id="内置函数">内置函数</h1>
<h2 id="filter">filter()</h2>
<p>用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表</p>
<pre><code>t = filter(lambda x:True if x&gt;3 else False, [0, 2, 3, 4, 5])
print(list(t))
</code></pre>
<h2 id="map">map()</h2>
<p>接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p>
<pre><code>比如，把这个list所有数字转为字符串：
list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
</code></pre>
<h1 id="reduce">reduce()</h1>
<p>把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是</p>
<pre><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<pre><code># 比方说对一个序列求和，就可以用reduce实现：
from functools import reduce
def add(x, y):
  return x + y
reduce(add, [1, 3, 5, 7, 9])
25
</code></pre>
<h2 id="-zip">-zip()</h2>
<p>会将列表按位组合成元组</p>
<h2 id="any-all">any、all()</h2>
<p>判断可送代对象中是否包含（0,&quot;&quot;,False）的元素</p>
<h1 id="列表推导式-字典推导式-生成器">列表推导式、字典推导式、生成器</h1>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-e3e9887c9e9be645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="闭包装饰器的本质也是闭包">闭包(装饰器的本质也是闭包)</h1>
<p>一个函数在另一个函数里面，外层函数返回的是里层函数，返回的函数还可以访问它的定义所在的作用域，也就是它带着它的环境。这个被称为闭包。</p>
<p>闭包可以保存环境变量</p>
<pre><code>def outer(factor):
    def inner(number):
        return number*factor
    return inner
func_inner = outer(4)
# 第一次获取到内部的函数，之后可以直接使用这个函数
print(func_inner)
value = func_inner(5)
print(value)  # 20
# 或者我们也可以写成一句话：
value = outer(4)(5)
print(value)  # 20
</code></pre>
<h1 id="函数装饰器"><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">函数装饰器</a></h1>
<p>为什么要用装饰器：在写项目的时候不可能一次性把所有的功能都全部写完或则上线前客户需求改变，需要<s>对函数添加新功能（装饰器函数）。</s></p>
<p>开放封闭原则:<br>
<s>对扩展是开放</s>：就是对项目的拓展功能是开放的，可以进行添加新的功能<br>
<s>对修改是封闭的</s>：就是对原函数的源代码和调用方式是封闭的</p>
<p>使用函数装饰器 A() 去装饰另一个函数 B()，其底层执行了如下 2 步操作：<br>
将 B 作为参数传给 A() 函数；将 A() 函数执行完成的返回值反馈回  B。</p>
<pre><code>@A
def B():
=============================
B = A(B)
</code></pre>
<p>多个装饰器的执行顺序</p>
<pre><code>@B
@A
def C()
装饰过程；A-&gt;B
执行过程；B-&gt;A
</code></pre>
<pre><code># @wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。
from functools import wraps
 
def logit(logfile='out.log'):
    def logging_decorator(func):
        @wraps(func)  # 在装饰器里面访问在装饰之前的函数的属性。
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + &quot; was called&quot;
            print(log_string)
            # 打开logfile，并写入内容
            with open(logfile, 'a') as opened_file:
                # 现在将日志打到指定的logfile
                opened_file.write(log_string + '\n')
            return func(*args, **kwargs)
        return wrapped_function
    return logging_decorator
</code></pre>
<pre><code>@logit()
def myfunc1():
    pass
 
myfunc1()
# Output: myfunc1 was called
# 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串
</code></pre>
<pre><code>@logit(logfile='func2.log')
def myfunc2():
    pass
 
myfunc2()
# Output: myfunc2 was called
# 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串
</code></pre>
<h2 id="property">@property</h2>
<p><s>就是负责把一个方法变成属性调用的</s></p>
<h1 id="面向对象">面向对象</h1>
<p>实例的变量名如果以__开头，就变成了一个私有变量（private）。</p>
<p>仍然可以通过_Student__name来访问__name变量，表面上看，外部代码“成功”地设置了“__name”变量，但实际上这个“__name”变量和class内部的__name变量不是一个变量</p>
<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<s>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以</s>了：这就是动态语言的“鸭子类型”</p>
<p>dir()：获得一个对象的所有属性和方法<br>
getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态</p>
<pre><code>hasattr(obj, 'x') # 有属性'x'吗？
setattr(obj, 'y', 19) # 设置一个属性'y'
 getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
</code></pre>
<p>还可以尝试给实例绑定一个方法,但是，<s>给一个实例绑定的方法，对另一个实例是不起作用的</s></p>
<pre><code>def set_age(self, age): # 定义一个函数作为实例方法
  self.age = age
from types import MethodType
给实例绑定一个方法
s.set_age = MethodType(set_age, s) #
</code></pre>
<p>为了给所有实例都绑定方法，可以<s>给class绑定方法：</s></p>
<pre><code>Student.set_age= set_age
</code></pre>
<p>如果我们想要限制实例的属性，比如，只允许对Student实例添加name和age属性。<br>
为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的~~__slots__变量，来限制该class实例能添加的属性,__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的~~：</p>
<pre><code>class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
</code></pre>
<h1 id="实例方法类方法静态方法">实例方法，类方法，静态方法</h1>
<ul>
<li>实例方法， 类对象直接调用实例方法</li>
<li>类方法，使用类名直接调用类方法，不需要实例化，类方法只能调用类属性，不能调用实例属性</li>
<li>静态方法，不需要实例化，其实就是的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。</li>
</ul>
<blockquote>
<p>静态方法<s>没有类似 self、cls 这样的特殊参数</s>，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中<s>无法调用任何类属性和类方法。</s></p>
</blockquote>
<pre><code>#类构造方法，也属于实例方法
def __init__(self):
     self.name = &quot;C语言中文网&quot;
     self.add = &quot;http://c.biancheng.net&quot;
# 下面定义了一个say实例方法
def say(self):
     print(&quot;正在调用 say() 实例方法&quot;)
#下面定义了一个类方法
@classmethod
def info(cls):
     print(&quot;正在调用类方法&quot;,cls)
# 和 self 一样，cls 参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已。
@staticmethod
    def info(name,add):
        print(name,add)
</code></pre>
<h1 id="文件操作">文件操作</h1>
<h2 id="oswalk">os.walk()</h2>
<pre><code> for root, dirs, files in os.walk('.'):  
        print(root) #当前目录路径  
        print(dirs) #当前路径下所有子目录  (不包括子目录)
        print(files) #当前路径下所有非目录子文件(不包括子目录)
        print('*'*10)
</code></pre>
<h2 id="ospathsplitext">os.path.splitext()</h2>
<p>函数将路径拆分为文件名+扩展名</p>
<pre><code>os.path.splitext(“E:/lena.jpg”)
# 将得到”E:/lena“+&quot;.jpg&quot;。
</code></pre>
<h2 id="ospathbasename">os.path.basename</h2>
<p>返回path最后的文件名。如果path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素。</p>
<pre><code>path = '/Users/beazley/Data/data.csv'
os.path.basename(path)
#'data.csv'
</code></pre>
<h2 id="oslistdir">os.listdir()</h2>
<p>所有目录和文件</p>
<pre><code>1.创建目录
os.mkdir(“file”)
2.复制文件：
shutil.copyfile(“oldfile”,”newfile”) #oldfile和newfile都只能是文件
shutil.copy(“oldfile”,”newfile”) #oldfile只能是文件夹，newfile可以是文件，也可以是目标目录
3.复制文件夹：
shutil.copytree(“olddir”,”newdir”) #olddir和newdir都只能是目录，且newdir必须不存在
5.重命名文件(目录)
os.rename(“oldname”,”newname”) #文件或目录都是使用这条命令
6.移动文件(目录)
shutil.move(“oldpos”,”newpos”)
7.删除文件
os.remove(“file”)
8.删除目录
os.rmdir(“dir”) #只能删除空目录
shutil.rmtree(“dir”) #空目录、有内容的目录都可以删
</code></pre>
<h1 id="生成器">生成器</h1>
<pre><code>def foo():
    print(&quot;starting...&quot;)
    while True:
        res = yield 4
        print(&quot;res:&quot;,res)
g = foo()
print(next(g))
print(&quot;*&quot;*20)
print(next(g))
</code></pre>
<pre><code>starting...
4
********************
res: None
4
</code></pre>
<p>1.程序开始执行以后，<s>因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象).</s><br>
2.直到<s>调用next方法，foo函数正式开始执行</s>，先执行foo函数中的print方法，然后进入while循环<br>
3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，<br>
4.程序执行print(&quot;*&quot;<em>20)，输出20个</em><br>
5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，<s>这个时候是从刚才那个next程序停止的地方开始执行的</s>，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,<br>
6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p>
<h1 id="切片">切片</h1>
<p>object[start_index:end_index:step]<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-708a7823d1970cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<pre><code>print(a[::-1]) ### 取从后向前（相反）的元素
a[3::2]# 从索引3开始隔一取一
</code></pre>
<h1 id="格式化字符串">格式化字符串</h1>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-10f11f25f2121404.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="传参">传参</h1>
<p>fun(*args,**kwargs)<br>
*args是用来发送一个非键值对的可变数量的参数列表给一个函数<br>
**kwargs允许你将不定长度的键值对，作为参数传递给一个函数。</p>
<pre><code>def func1(a,b=1,*c,**d):
    print(a,b,c,d)  
    
l = [3,4]
dic = {'@':2,'#':3}

func1(1,2,l,dic)
func1(1,2,*l,**dic)
func1(1,2,3,4,**dic)

# 1 2 ([3, 4], {'@': 2, '#': 3}) {}
# 1 2 (3, 4) {'@': 2, '#': 3}
# 1 2 (3, 4) {'@': 2, '#': 3}
</code></pre>
<h1 id="列表-字典">列表、字典</h1>
<p>字典的合并</p>
<pre><code>dictl={'a':1,'b':2}
dict2={'c':3,'d':4}
dictl.update(dict2)
print(dictl)
</code></pre>
<h1 id="问题">问题</h1>
<h2 id="列表和元组的区别">列表和元组的区别</h2>
<blockquote>
<ol>
<li>列表是动态数组，它们可变且可以重设长度（改变其内部元素的个数）。</li>
<li>元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变。 但是我们可以将两个元组合并成一个新元组。<br>
3.<s>元组缓存于Python运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存</s><br>
Python是一门垃圾收集语言，这意味着当一个变量不再被使用时，Python会将该变量使用的内存释放回操作系统，以供其他程序（变量）使用。然而，对于长度为1~20的元组，<s>即使它们不在被使用，它们的空间也不会立刻还给系统，而是留待未来使用</s>。这意味着当未来需要一个同样大小的新的元组时，我们不再需要向操作系统申请一块内存来存放数据，因为我们已经有了预留的空间。</li>
</ol>
</blockquote>
<h2 id="gll">GlL</h2>
<p>python的全局解释器锁，<s>同一进程中假如有多个线程运行线程在运行python程序的时候会霸占 python解释器（加了一把锁即GlL),使该进程内的其他线程无法运行</s>，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行</p>
<p>多进程中因为每个进程都能被系统分配资源，相当于<s>每个进程有了一个 python解释器</s>所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大</p>
<h2 id="python传参数是传值还是传址">python传参数是传值还是传址？</h2>
<p>Python中函数参数是<s>引用传递</s>（注意不是值传递）。对于不可变类型（数值型、字符串、元组），因变量不能修改，所以运算不会影响到变量自身；而对于可变类型（列表字典）来说，函数体运算可能会更改传入的参数变量。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-afd4b5afada2703d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="python对象销毁垃圾回收">python对象销毁(垃圾回收)</h2>
<blockquote>
<p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 Python 内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， <s>这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是&quot;立即&quot;的</s>， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。<s>Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。</s></p>
</blockquote>
<h2 id="简述乐观锁和悲观锁">简述乐观锁和悲观锁</h2>
<p>悲观锁，就是很悲观，<s>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁</s>，这样别人想拿这个数据就会 block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<br>
乐观锁，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是<s>在更新的时候会判断一下在此期间别人有没有去更新这个数据</s>，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker]]></title>
        <id>https://dingtom.github.io/post/docker/</id>
        <link href="https://dingtom.github.io/post/docker/">
        </link>
        <updated>2020-11-28T14:10:09.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-a16ddde40bfc6f50.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p>ubuntu安装 Docker 的时候需在管理员的账号下操作。<br>
<code>wget -qO- https://get.docker.com/ | sh</code><br>
安装完成之后，以 sudo 启动 Docker 服务。<br>
<code>sudo service docker start</code></p>
<h3 id="容器生命周期管理">容器生命周期管理</h3>
<h4 id="创建一个新的容器并运行一个命令run"><a href="https://www.runoob.com/docker/docker-run-command.html">创建一个新的容器并运行一个命令：run</a></h4>
<p><code>docker run -d(后台运行不阻塞shell） -p 80:80（指定容器端口映射，内部：外部） nginx</code></p>
<blockquote>
<p>-d：后台运行容器<br>
-h: 指定容器的hostname；<br>
-p：主机端口号:容器端口号```容器内外端口映射<br>
--name name：指定容器名称<br>
-v &lt;外部 dir&gt;:&lt; 内部 dir&gt;：目录映射<br>
<mirror name>:<version>：指定映像版本<br>
-it：在容器启动后直接进入<br>
--link：将另一个容器映射到本容器，进行通信<br>
--restart=always：因某种错误而停止运行时，能够自动重启</p>
</blockquote>
<h4 id="启动停止重启容器startstoprestart"><a href="https://www.runoob.com/docker/docker-start-stop-restart-command.html">启动/停止/重启容器：start/stop/restart</a></h4>
<h4 id="杀掉容器kill"><a href="https://www.runoob.com/docker/docker-kill-command.html">杀掉容器：kill</a></h4>
<p>快速停止容器</p>
<h4 id="删除容器rm"><a href="https://www.runoob.com/docker/docker-rm-command.html">删除容器：rm</a></h4>
<p><code>docker rm -f container_id</code></p>
<h4 id="暂停恢复容器中进程pauseunpause"><a href="https://www.runoob.com/docker/docker-pause-unpause-command.html">暂停/恢复容器中进程：pause/unpause</a></h4>
<p>如果只是希望容器暂停工作一段时间，比如对容器的文件系统大打个快照，或者 docker host 需要使用 CPU，这是可以执行 docker pause 将其暂停。处于暂停状态的容器不会占用 CPU，直到通过 docker unpause 恢复运行。</p>
<h4 id="创建容器create"><a href="https://www.runoob.com/docker/docker-create-command.html">创建容器：create</a></h4>
<h4 id="进入容器exec"><a href="https://www.runoob.com/docker/docker-exec-command.html">进入容器：exec</a></h4>
<p><code>docker exec -it container_id bash</code></p>
<h3 id="容器操作">容器操作</h3>
<h4 id="查看正在运行的容器ps"><a href="https://www.runoob.com/docker/docker-ps-command.html">查看正在运行的容器：ps</a></h4>
<p><code>docker ps</code></p>
<h4 id="inspect"><a href="https://www.runoob.com/docker/docker-inspect-command.html">inspect</a></h4>
<h4 id="top"><a href="https://www.runoob.com/docker/docker-top-command.html">top</a></h4>
<h4 id="attach"><a href="https://www.runoob.com/docker/docker-attach-command.html">attach</a></h4>
<h4 id="events"><a href="https://www.runoob.com/docker/docker-events-command.html">events</a></h4>
<h4 id="logs"><a href="https://www.runoob.com/docker/docker-logs-command.html">logs</a></h4>
<h4 id="wait"><a href="https://www.runoob.com/docker/docker-wait-command.html">wait</a></h4>
<h4 id="export"><a href="https://www.runoob.com/docker/docker-export-command.html">export</a></h4>
<h4 id="port"><a href="https://www.runoob.com/docker/docker-port-command.html">port</a></h4>
<h3 id="容器rootfs命令">容器rootfs命令</h3>
<h4 id="从容器创建一个新的镜像commit"><a href="https://www.runoob.com/docker/docker-commit-command.html">从容器创建一个新的镜像：commit</a></h4>
<p><code>docker commit container_id mirror_name</code>我们修改过后的容器保存成镜像，重新运行，它可以保持这个变化</p>
<blockquote>
<p>-a :提交的镜像作者；<br>
-c :使用Dockerfile指令来创建镜像；<br>
-m :提交时的说明文字；<br>
-p :在commit时，将容器暂停。</p>
</blockquote>
<h4 id="cp"><a href="https://www.runoob.com/docker/docker-cp-command.html">cp</a></h4>
<h4 id="diff"><a href="https://www.runoob.com/docker/docker-diff-command.html">diff</a></h4>
<h3 id="镜像仓库">镜像仓库</h3>
<h4 id="login"><a href="https://www.runoob.com/docker/docker-login-command.html">login</a></h4>
<h4 id="拉取或者更新镜像pull"><a href="https://www.runoob.com/docker/docker-pull-command.html">拉取或者更新镜像：pull</a></h4>
<p><code>docker pull nginx（等效于nginx:latest）</code></p>
<h4 id="push"><a href="https://www.runoob.com/docker/docker-push-command.html">push</a></h4>
<h4 id="search"><a href="https://www.runoob.com/docker/docker-search-command.html">search</a></h4>
<p>命令可以搜索 Docker Hub 中的镜像。</p>
<h3 id="本地镜像管理">本地镜像管理</h3>
<h4 id="查看镜像列表images"><a href="https://www.runoob.com/docker/docker-images-command.html">查看镜像列表：images</a></h4>
<p><code>docker images</code></p>
<h4 id="删除镜像rmi"><a href="https://www.runoob.com/docker/docker-rmi-command.html">删除镜像：rmi</a></h4>
<p><code>docker rmi mirror_name</code></p>
<h4 id="tag"><a href="https://www.runoob.com/docker/docker-tag-command.html">tag</a></h4>
<h4 id="使用dockerfile构建镜像build"><a href="https://www.runoob.com/docker/docker-build-command.html">使用Dockerfile构建镜像：build</a></h4>
<p><code>docker build -t mirror_name 存放Dockerfile的文件夹</code></p>
<h4 id="history"><a href="https://www.runoob.com/docker/docker-history-command.html">history</a></h4>
<h4 id="镜像保存为tarsave"><a href="https://www.runoob.com/docker/docker-save-command.html">镜像保存为tar：save</a></h4>
<p><code>docker save mirror_name &gt; .tar</code></p>
<h4 id="从tar加载镜像load"><a href="https://www.runoob.com/docker/docker-load-command.html">从tar加载镜像：load</a></h4>
<p><code>docker load &lt; .tar</code></p>
<h4 id="import"><a href="https://www.runoob.com/docker/docker-import-command.html">import</a></h4>
<h3 id="infoversion">info|version</h3>
<h4 id="info"><a href="https://www.runoob.com/docker/docker-info-command.html">info</a></h4>
<h4 id="version"><a href="https://www.runoob.com/docker/docker-version-command.html">version</a></h4>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-a16ddde40bfc6f50.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p>ubuntu安装 Docker 的时候需在管理员的账号下操作。<br>
<code>wget -qO- https://get.docker.com/ | sh</code><br>
安装完成之后，以 sudo 启动 Docker 服务。<br>
<code>sudo service docker start</code></p>
<h3 id="容器生命周期管理">容器生命周期管理</h3>
<h4 id="创建一个新的容器并运行一个命令run"><a href="https://www.runoob.com/docker/docker-run-command.html">创建一个新的容器并运行一个命令：run</a></h4>
<p><code>docker run -d(后台运行不阻塞shell） -p 80:80（指定容器端口映射，内部：外部） nginx</code></p>
<blockquote>
<p>-d：后台运行容器<br>
-h: 指定容器的hostname；<br>
-p：主机端口号:容器端口号```容器内外端口映射<br>
--name name：指定容器名称<br>
-v &lt;外部 dir&gt;:&lt; 内部 dir&gt;：目录映射<br>
<mirror name>:<version>：指定映像版本<br>
-it：在容器启动后直接进入<br>
--link：将另一个容器映射到本容器，进行通信<br>
--restart=always：因某种错误而停止运行时，能够自动重启</p>
</blockquote>
<h4 id="启动停止重启容器startstoprestart"><a href="https://www.runoob.com/docker/docker-start-stop-restart-command.html">启动/停止/重启容器：start/stop/restart</a></h4>
<h4 id="杀掉容器kill"><a href="https://www.runoob.com/docker/docker-kill-command.html">杀掉容器：kill</a></h4>
<p>快速停止容器</p>
<h4 id="删除容器rm"><a href="https://www.runoob.com/docker/docker-rm-command.html">删除容器：rm</a></h4>
<p><code>docker rm -f container_id</code></p>
<h4 id="暂停恢复容器中进程pauseunpause"><a href="https://www.runoob.com/docker/docker-pause-unpause-command.html">暂停/恢复容器中进程：pause/unpause</a></h4>
<p>如果只是希望容器暂停工作一段时间，比如对容器的文件系统大打个快照，或者 docker host 需要使用 CPU，这是可以执行 docker pause 将其暂停。处于暂停状态的容器不会占用 CPU，直到通过 docker unpause 恢复运行。</p>
<h4 id="创建容器create"><a href="https://www.runoob.com/docker/docker-create-command.html">创建容器：create</a></h4>
<h4 id="进入容器exec"><a href="https://www.runoob.com/docker/docker-exec-command.html">进入容器：exec</a></h4>
<p><code>docker exec -it container_id bash</code></p>
<h3 id="容器操作">容器操作</h3>
<h4 id="查看正在运行的容器ps"><a href="https://www.runoob.com/docker/docker-ps-command.html">查看正在运行的容器：ps</a></h4>
<p><code>docker ps</code></p>
<h4 id="inspect"><a href="https://www.runoob.com/docker/docker-inspect-command.html">inspect</a></h4>
<h4 id="top"><a href="https://www.runoob.com/docker/docker-top-command.html">top</a></h4>
<h4 id="attach"><a href="https://www.runoob.com/docker/docker-attach-command.html">attach</a></h4>
<h4 id="events"><a href="https://www.runoob.com/docker/docker-events-command.html">events</a></h4>
<h4 id="logs"><a href="https://www.runoob.com/docker/docker-logs-command.html">logs</a></h4>
<h4 id="wait"><a href="https://www.runoob.com/docker/docker-wait-command.html">wait</a></h4>
<h4 id="export"><a href="https://www.runoob.com/docker/docker-export-command.html">export</a></h4>
<h4 id="port"><a href="https://www.runoob.com/docker/docker-port-command.html">port</a></h4>
<h3 id="容器rootfs命令">容器rootfs命令</h3>
<h4 id="从容器创建一个新的镜像commit"><a href="https://www.runoob.com/docker/docker-commit-command.html">从容器创建一个新的镜像：commit</a></h4>
<p><code>docker commit container_id mirror_name</code>我们修改过后的容器保存成镜像，重新运行，它可以保持这个变化</p>
<blockquote>
<p>-a :提交的镜像作者；<br>
-c :使用Dockerfile指令来创建镜像；<br>
-m :提交时的说明文字；<br>
-p :在commit时，将容器暂停。</p>
</blockquote>
<h4 id="cp"><a href="https://www.runoob.com/docker/docker-cp-command.html">cp</a></h4>
<h4 id="diff"><a href="https://www.runoob.com/docker/docker-diff-command.html">diff</a></h4>
<h3 id="镜像仓库">镜像仓库</h3>
<h4 id="login"><a href="https://www.runoob.com/docker/docker-login-command.html">login</a></h4>
<h4 id="拉取或者更新镜像pull"><a href="https://www.runoob.com/docker/docker-pull-command.html">拉取或者更新镜像：pull</a></h4>
<p><code>docker pull nginx（等效于nginx:latest）</code></p>
<h4 id="push"><a href="https://www.runoob.com/docker/docker-push-command.html">push</a></h4>
<h4 id="search"><a href="https://www.runoob.com/docker/docker-search-command.html">search</a></h4>
<p>命令可以搜索 Docker Hub 中的镜像。</p>
<h3 id="本地镜像管理">本地镜像管理</h3>
<h4 id="查看镜像列表images"><a href="https://www.runoob.com/docker/docker-images-command.html">查看镜像列表：images</a></h4>
<p><code>docker images</code></p>
<h4 id="删除镜像rmi"><a href="https://www.runoob.com/docker/docker-rmi-command.html">删除镜像：rmi</a></h4>
<p><code>docker rmi mirror_name</code></p>
<h4 id="tag"><a href="https://www.runoob.com/docker/docker-tag-command.html">tag</a></h4>
<h4 id="使用dockerfile构建镜像build"><a href="https://www.runoob.com/docker/docker-build-command.html">使用Dockerfile构建镜像：build</a></h4>
<p><code>docker build -t mirror_name 存放Dockerfile的文件夹</code></p>
<h4 id="history"><a href="https://www.runoob.com/docker/docker-history-command.html">history</a></h4>
<h4 id="镜像保存为tarsave"><a href="https://www.runoob.com/docker/docker-save-command.html">镜像保存为tar：save</a></h4>
<p><code>docker save mirror_name &gt; .tar</code></p>
<h4 id="从tar加载镜像load"><a href="https://www.runoob.com/docker/docker-load-command.html">从tar加载镜像：load</a></h4>
<p><code>docker load &lt; .tar</code></p>
<h4 id="import"><a href="https://www.runoob.com/docker/docker-import-command.html">import</a></h4>
<h3 id="infoversion">info|version</h3>
<h4 id="info"><a href="https://www.runoob.com/docker/docker-info-command.html">info</a></h4>
<h4 id="version"><a href="https://www.runoob.com/docker/docker-version-command.html">version</a></h4>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker安装Hadoop]]></title>
        <id>https://dingtom.github.io/post/docker-an-zhuang-hadoop/</id>
        <link href="https://dingtom.github.io/post/docker-an-zhuang-hadoop/">
        </link>
        <updated>2020-11-28T13:53:36.000Z</updated>
        <content type="html"><![CDATA[<p>Docker、Java、Scala、Hadoop、 Hbase、Spark。<br>
集群共有5台机器，主机名分别为 h01、h02、h03、h04、h05。其中 h01 为 master，其他的为 slave。<br>
JDK 1.8、Scala 2.11.6、Hadoop 3.2.1、Hbase 2.1.3、Spark 2.4.0</p>
<h1 id="ubuntu-安装-docker">Ubuntu 安装 Docker</h1>
<h2 id="在-ubuntu-下安装-docker-的时候需在管理员的账号下操作">在 Ubuntu 下安装 Docker 的时候需在管理员的账号下操作。</h2>
<p><code>wget -qO- https://get.docker.com/ | sh</code></p>
<h2 id="以-sudo-启动-docker-服务">以 sudo 启动 Docker 服务。</h2>
<p><code>sudo service docker start</code></p>
<h2 id="显示-docker-中所有正在运行的容器">显示 Docker 中所有正在运行的容器</h2>
<p><code>sudo docker ps</code><br>
现在的 Docker 网络能够提供 DNS 解析功能，使用如下命令为接下来的 Hadoop 集群单独构建一个虚拟的网络。<br>
<code>sudo docker network create --driver=bridge hadoop</code><br>
以上命令创建了一个名为 Hadoop 的虚拟桥接网络，该虚拟网络内部提供了自动的DNS解析服务。## 查看 Docker 中的网络<br>
<code>sudo docker network ls</code><br>
可以看到刚刚创建的名为 hadoop 的虚拟桥接网络。</p>
<h2 id="查找-ubuntu-容器">查找 ubuntu 容器</h2>
<p><code>sudo docker search ubuntu</code></p>
<h2 id="下载-ubuntu-1604-版本的镜像文件">下载 ubuntu 16.04 版本的镜像文件</h2>
<p><code>sudo docker pull ubuntu:16.04</code></p>
<h2 id="根据镜像启动一个容器">根据镜像启动一个容器</h2>
<p><code>sudo docker run -it ubuntu:16.04 /bin/bash</code><br>
可以看出 shell 已经是容器的 shell 了</p>
<h2 id="退出容器">退出容器</h2>
<p><code>exit</code></p>
<h2 id="查看本机上所有的容器">查看本机上所有的容器</h2>
<p><code>sudo docker ps -a</code></p>
<h2 id="启动容器">启动容器</h2>
<p><code>sudo docker start fab4da838c2f</code></p>
<h2 id="关闭容器">关闭容器</h2>
<p><code>sudo docker stop fab4da838c2f</code></p>
<h1 id="安装-java-与-scala">安装 Java 与 Scala</h1>
<p>在当前容器中将配置配好，导入出为镜像。以此镜像为基础创建五个容器，并赋予 hostname<br>
进入 h01 容器，启动 Hadoop。</p>
<h2 id="进入-ubuntu-容器">进入 Ubuntu 容器</h2>
<p><code>sudo docker exec -it fab4da838c2f /bin/bash</code></p>
<h2 id="修改-apt-源">修改 apt 源</h2>
<p>备份源<br>
<code>cp /etc/apt/sources.list /etc/apt/sources_init.list</code><br>
先删除旧源文件<br>
<code>rm /etc/apt/sources.list</code><br>
这个时候没有 vim 工具，使用 echo 命令将源写入新文件</p>
<pre><code>echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial main
deb-src http://mirrors.aliyun.com/ubuntu/ xenial main
deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main
deb http://mirrors.aliyun.com/ubuntu/ xenial universe
deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe
deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe
deb http://mirrors.aliyun.com/ubuntu/ xenial-security main
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main
deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe&quot;
&gt; /etc/apt/sources.list
</code></pre>
<h2 id="更新源">更新源</h2>
<p><code>apt update</code></p>
<h2 id="安装-jdk-18">安装 jdk 1.8</h2>
<p>​<code>apt install openjdk-8-jdk</code><br>
测试<br>
​<code>java -version</code></p>
<h2 id="安装-scala">安装 Scala</h2>
<p>​<code>apt install scala</code><br>
测试<br>
​<code>scala</code></p>
<h2 id="安装-vim-与-网络工具包">安装 Vim 与 网络工具包</h2>
<p>安装 vim，用来编辑文件<br>
​<code>apt install vim</code><br>
安装 net-tools<br>
​<code>apt install net-tools</code></p>
<h2 id="安装-ssh">安装 SSH</h2>
<p>安装 SSH，并配置免密登录，由于后面的容器之间是由一个镜像启动的，所以在当前容器里配置 SSH 自身免密登录就 OK 了。</p>
<p>安装 SSH<br>
​<code>apt-get install openssh-server</code><br>
安装 SSH 的客户端<br>
​<code>apt-get install openssh-client</code><br>
进入当前用户的用户根目录<br>
​<code>cd ~</code><br>
生成密钥，一直回车就行<br>
​<code>ssh-keygen -t rsa -P &quot;&quot;</code><br>
生成的密钥在当前用户根目录下的 .ssh 文件夹中以 . 开头的文件与文件夹 ls 是看不懂的，需要<code>ls -al</code> 才能查看。</p>
<p>将公钥追加到 authorized_keys 文件中<br>
​<code>cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys</code><br>
启动 SSH 服务<br>
​<code>service ssh start</code><br>
免密登录自己<br>
​<code>ssh 127.0.0.1</code><br>
修改 .bashrc 文件，启动 shell 的时候，自动启动 SSH 服务<br>
​<code>vim ~/.bashrc</code><br>
添加一行<br>
​<code>service ssh start</code></p>
<h1 id="安装-hadoop">安装 Hadoop</h1>
<h2 id="下载-hadoop">下载 Hadoop</h2>
<p>​<code>wget http://mirrors.hust.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz</code></p>
<h2 id="解压">解压</h2>
<p>到 /usr/local 目录下面并重命名文件夹<br>
​<code>tar -zxvf hadoop-3.2.1.tar.gz -C /usr/local/</code><br>
​<code>cd /usr/local/</code><br>
​<code>mv hadoop-3.2.1 hadoop</code></p>
<h2 id="添加环境变量">添加环境变量</h2>
<p><code>vim /etc/profile</code><br>
追加以下内容，JAVA_HOME 为 JDK 安装路径，使用 apt 安装就是这个，用 <code>update-alternatives --config java</code>可查看</p>
<pre><code>#java
export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export JRE_HOME=${JAVA_HOME}/jre    
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib    
export PATH=${JAVA_HOME}/bin:$PATH
#hadoop
export HADOOP_HOME=/usr/local/hadoop
export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin
export HADOOP_COMMON_HOME=$HADOOP_HOME 
export HADOOP_HDFS_HOME=$HADOOP_HOME 
export HADOOP_MAPRED_HOME=$HADOOP_HOME
export HADOOP_YARN_HOME=$HADOOP_HOME 
export HADOOP_INSTALL=$HADOOP_HOME 
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native 
export HADOOP_CONF_DIR=$HADOOP_HOME 
export HADOOP_LIBEXEC_DIR=$HADOOP_HOME/libexec 
export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native:$JAVA_LIBRARY_PATH
export HADOOP_CONF_DIR=$HADOOP_PREFIX/etc/hadoop
export HDFS_DATANODE_USER=root
export HDFS_DATANODE_SECURE_USER=root
export HDFS_SECONDARYNAMENODE_USER=root
export HDFS_NAMENODE_USER=root
export YARN_RESOURCEMANAGER_USER=root
export YARN_NODEMANAGER_USER=root
</code></pre>
<p>使环境变量生效<br>
​<code>source /etc/profile</code></p>
<h2 id="修改配置文件">修改配置文件</h2>
<p>在目录 /usr/local/hadoop/etc/hadoop 下，修改 hadoop-env.sh 文件，在文件末尾添加以下信息<br>
​<code>cd /usr/local/hadoop/etc/hadoop</code><br>
​<code>vim hadoop-env.sh</code></p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export HDFS_NAMENODE_USER=root
export HDFS_DATANODE_USER=root
export HDFS_SECONDARYNAMENODE_USER=root
export YARN_RESOURCEMANAGER_USER=root
export YARN_NODEMANAGER_USER=root
</code></pre>
<p>修改 core-site.xml，修改为<br>
​<code>vim core-site.xml</code></p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;fs.default.name&lt;/name&gt;
        &lt;value&gt;hdfs://h01:9000&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
        &lt;value&gt;/home/hadoop3/hadoop/tmp&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p><code>chmod 777 /home/hadoop3/hadoop/tmp</code><br>
修改 hdfs-site.xml，修改为<br>
​<code>vim hdfs-site.xml</code></p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;2&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;
        &lt;value&gt;/home/hadoop3/hadoop/hdfs/name&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.namenode.data.dir&lt;/name&gt;
        &lt;value&gt;/home/hadoop3/hadoop/hdfs/data&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p>修改 mapred-site.xml，修改为<br>
​<code>vim mapred-site.xml</code></p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
        &lt;value&gt;yarn&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;
        &lt;value&gt;
            /usr/local/hadoop/etc/hadoop,
            /usr/local/hadoop/share/hadoop/common/*,
            /usr/local/hadoop/share/hadoop/common/lib/*,
            /usr/local/hadoop/share/hadoop/hdfs/*,
            /usr/local/hadoop/share/hadoop/hdfs/lib/*,
            /usr/local/hadoop/share/hadoop/mapreduce/*,
            /usr/local/hadoop/share/hadoop/mapreduce/lib/*,
            /usr/local/hadoop/share/hadoop/yarn/*,
            /usr/local/hadoop/share/hadoop/yarn/lib/*
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p>修改 yarn-site.xml，修改为<br>
​<code>vim yarn-site.xml</code></p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
        &lt;value&gt;h01&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p>修改 worker 为<br>
​<code>vim workers</code></p>
<pre><code>h01
h02
h03
h04
h05
</code></pre>
<p>此时，hadoop已经配置好了</p>
<h2 id="在-docker-中启动集群">在 Docker 中启动集群</h2>
<h3 id="将当前容器导出为镜像">将当前容器导出为镜像</h3>
<p>​<code>exit</code><br>
​<code>sudo docker commit -m &quot;hadoop&quot; -a &quot;tomding&quot; fab4da838c2f newuhadoop</code><br>
查看镜像<br>
​<code>sudo docker images</code></p>
<h3 id="启动-5-个终端">启动 5 个终端</h3>
<p>启动 h01 做 master 节点，所以暴露了端口，以供访问 web 页面，--network hadoop 参数是将当前容器加入到名为 hadoop 的虚拟桥接网络中，此网站提供自动的 DNS 解析功能<br>
​<code>sudo docker run -it --network hadoop -h &quot;h01&quot; --name &quot;h01&quot; -p 9870:9870 -p 8088:8088 newuhadoop /bin/bash</code><br>
<code>sudo docker run -it --network hadoop -h &quot;h02&quot; --name &quot;h02&quot; newuhadoop /bin/bash</code><br>
​<code>sudo docker run -it --network hadoop -h &quot;h03&quot; --name &quot;h03&quot; newuhadoop /bin/bash</code><br>
​<code>sudo docker run -it --network hadoop -h &quot;h04&quot; --name &quot;h04&quot; newuhadoop /bin/bash</code><br>
​<code>sudo docker run -it --network hadoop -h &quot;h05&quot; --name &quot;h05&quot; newuhadoop /bin/bash</code></p>
<h3 id="在-h01-主机中启动-haddop-集群">在 h01 主机中，启动 Haddop 集群</h3>
<p>先进行格式化操作，不格式化操作，hdfs会起不来<br>
​<code>cd /usr/local/hadoop/bin</code><br>
​<code>./hadoop namenode -format</code><br>
进入 hadoop 的 sbin 目录<br>
​<code>cd /usr/local/hadoop/sbin/</code><br>
启动<br>
​<code>./start-all.sh</code><br>
查看分布式文件系统的状态<br>
​<code>cd /usr/local/hadoop/bin</code><br>
​<code>./hadoop dfsadmin -report</code></p>
<h2 id="运行内置wordcount例子">运行内置WordCount例子</h2>
<p>把license作为需要统计的文件<br>
<code>cd /usr/local/hadoop</code><br>
<code>cat LICENSE.txt &gt; file1.txt</code><br>
在 HDFS 中创建 input 文件夹<br>
​<code>cd /usr/local/hadoop/bin</code><br>
<code>./hadoop fs -mkdir /input</code><br>
上传 file1.txt 文件到 HDFS 中<br>
<code>./hadoop fs -put ../file1.txt /input</code><br>
查看 HDFS 中 input 文件夹里的内容<br>
<code>./hadoop fs -ls /input</code><br>
运作 wordcount 例子程序<br>
<code>./hadoop jar ../share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar wordcount /input /output</code><br>
查看 HDFS 中的 /output 文件夹的内容<br>
<code>./hadoop fs -ls /output</code><br>
查看 part-r-00000 文件的内容<br>
<code>./hadoop fs -cat /output/part-r-00000</code><br>
Hadoop 部分结束了</p>
<h1 id="安装-hbase">安装 Hbase</h1>
<p>在 Hadoop 集群的基础上安装 Hbase</p>
<h2 id="下载-hbase-213">下载 Hbase 2.1.3</h2>
<p>root@h01:~# <code>wget http://archive.apache.org/dist/hbase/2.1.3/hbase-2.1.3-bin.tar.gz</code></p>
<h2 id="解压-2">解压</h2>
<p>到 /usr/local 目录下面<br>
​<code>tar -zxvf hbase-2.1.3-bin.tar.gz -C /usr/local/</code></p>
<h2 id="修改环境变量文件">修改环境变量文件</h2>
<p>​<code>vim /etc/profile</code></p>
<pre><code>export HBASE_HOME=/usr/local/hbase-2.1.3
export PATH=$PATH:$HBASE_HOME/bin
</code></pre>
<p>​<code>source /etc/profile</code><br>
使用 ssh h02/3/4/5 进入其他四个容器，依次在 /etc/profile 文件后追加那两行环境变量</p>
<p>在目录 /usr/local/hbase-2.1.3/conf 修改配置<br>
​<code>cd /usr/local/hbase-2.1.3/conf</code><br>
修改 hbase-env.sh，追加<br>
​<code>vim hbase-env.sh</code></p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export HBASE_MANAGES_ZK=true
</code></pre>
<h2 id="修改配置文件-2">修改配置文件</h2>
<p>修改 hbase-site.xml 为<br>
​<code>vim hbase-site.xml</code></p>
<pre><code>&lt;configuration&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.rootdir&lt;/name&gt;
                &lt;value&gt;hdfs://h01:9000/hbase&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
                &lt;value&gt;true&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.master&lt;/name&gt;
                &lt;value&gt;h01:60000&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
                &lt;value&gt;h01,h02,h03,h04,h05&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
                &lt;value&gt;/home/hadoop/zoodata&lt;/value&gt;
        &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p>修改 regionservers 文件为<br>
​<code>vim regionservers</code></p>
<pre><code>h01
h02
h03
h04
h05
</code></pre>
<p>使用 scp 命令将配置好的 Hbase 复制到其他 4 个容器中<br>
<code>scp -r /usr/local/hbase-2.1.3 root@h02:/usr/local/</code><br>
<code>scp -r /usr/local/hbase-2.1.3 root@h03:/usr/local/</code><br>
<code>scp -r /usr/local/hbase-2.1.3 root@h04:/usr/local/</code><br>
<code>scp -r /usr/local/hbase-2.1.3 root@h05:/usr/local/</code></p>
<h2 id="启动-hbase">启动 Hbase</h2>
<p><code>cd /usr/local/hbase-2.1.3/bin</code><br>
<code>./start-hbase.sh</code><br>
打开 Hbase 的 shell<br>
<code>hbase shell</code></p>
<h1 id="安装-spark">安装 Spark</h1>
<p>在 Hadoop 的基础上安装 Spark</p>
<h2 id="下载-spark-240">下载 Spark 2.4.0</h2>
<p>​<code>wget https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz</code></p>
<h2 id="解压-3">解压</h2>
<p>到 /usr/local 目录下面<br>
<code>tar -zxvf spark-2.4.0-bin-hadoop2.7.tgz -C /usr/local/</code><br>
修改文件夹的名字<br>
<code>cd /usr/local/</code><br>
<code>mv spark-2.4.0-bin-hadoop2.7 spark-2.4.0</code></p>
<h2 id="修改-环境变量">修改 环境变量</h2>
<p>​<code>vim /etc/profile</code></p>
<pre><code>export SPARK_HOME=/usr/local/spark-2.4.0
export PATH=$PATH:$SPARK_HOME/bin
</code></pre>
<p><code>source /etc/profile</code></p>
<p>使用 ssh h02/3/4/5 可进入其他四个容器，依次在 /etc/profile 文件后追加那两行环境变量</p>
<p>在目录 /usr/local/spark-2.4.0/conf 修改配置<br>
​<code>cd /usr/local/spark-2.4.0/conf</code><br>
修改文件名<br>
​<code>mv spark-env.sh.template spark-env.sh</code><br>
修改 spark-env.sh，追加<br>
​<code>vim spark-env.sh</code></p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export HADOOP_HOME=/usr/local/hadoop
export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop
export SCALA_HOME=/usr/share/scala

export SPARK_MASTER_HOST=h01
export SPARK_MASTER_IP=h01
export SPARK_WORKER_MEMORY=4g
</code></pre>
<p>修改文件名<br>
​<code>mv slaves.template slaves</code><br>
修改 slaves 如下<br>
<code>vim slaves</code></p>
<pre><code>h01
h02
h03
h04
h05
</code></pre>
<p>使用 scp 命令将配置好的 Hbase 复制到其他 4 个容器中<br>
<code>scp -r /usr/local/spark-2.4.0 root@h02:/usr/local/</code><br>
<code>scp -r /usr/local/spark-2.4.0 root@h03:/usr/local/</code><br>
<code>scp -r /usr/local/spark-2.4.0 root@h04:/usr/local/</code><br>
<code>scp -r /usr/local/spark-2.4.0 root@h05:/usr/local/</code></p>
<h2 id="启动-spark">启动 Spark</h2>
<p><code>cd /usr/local/spark-2.4.0/sbin</code><br>
<code>./start-all.sh</code></p>
<p>其他<br>
3.1 HDFS 重格式化问题<br>
参考 https://blog.csdn.net/gis_101/article/details/52821946<br>
<s>重新格式化意味着集群的数据会被全部删除，格式化前需考虑数据备份或转移问题</s>；<br>
先删除主节点（即namenode节点），Hadoop的临时存储目录tmp、namenode存储永久性元数据目录dfs/name、Hadoop系统日志文件目录log 中的内容 （注意是删除目录下的内容不是目录）；<br>
删除所有数据节点(即datanode节点) ，Hadoop的临时存储目录tmp、namenode存储永久性元数据目录dfs/name、Hadoop系统日志文件目录log 中的内容；</p>
<p>格式化一个新的分布式文件系统：<br>
<code>cd /usr/local/hadoop/bin</code><br>
<code>./hadoop namenode -format</code></p>
<p>注意事项</p>
<blockquote>
<p>Hadoop的临时存储目录tmp（即core-site.xml配置文件中的hadoop.tmp.dir属性，默认值是/tmp/hadoop-{user.name}），<br>
如果没有配置hadoop.tmp.dir属性，那么hadoop格式化时将会在/tmp目录下创建一个目录，例如在cloud用户下安装配置hadoop，那么Hadoop的临时存储目录就位于/tmp/hadoop-cloud目录下Hadoop的namenode元数据目录（即hdfs-site.xml配置文件中的dfs.namenode.name.dir属性，默认{hadoop.tmp.dir}/dfs/name），<br>
同样如果没有配置该属性，那么hadoop在格式化时将自行创建。必须注意的是在格式化前必须清楚所有子节点（即DataNode节点）dfs/name下的内容，否则在启动hadoop时子节点的守护进程会启动失败。这是由于，每一次format主节点namenode，dfs/name/current目录下的VERSION文件会产生新的clusterID、namespaceID。<br>
但是如果子节点的dfs/name/current仍存在，hadoop格式化时就不会重建该目录，因此形成子节点的clusterID、namespaceID与主节点（即namenode节点）的clusterID、namespaceID不一致。最终导致hadoop启动失败。</p>
</blockquote>
<p>进入：<br>
<code>​sudo docker run -it --network hadoop -h &quot;h01&quot; --name &quot;h01&quot; -p 9870:9870 -p 8088:8088 master /bin/bash</code><br>
<code>sudo docker run -it --network hadoop -h &quot;h02&quot; --name &quot;h02&quot; slave1 /bin/bash</code><br>
<code>​sudo docker run -it --network hadoop -h &quot;h03&quot; --name &quot;h03&quot; slave2 /bin/bash</code><br>
<code>​sudo docker run -it --network hadoop -h &quot;h04&quot; --name &quot;h04&quot; slave3 /bin/bash</code><br>
<code>​sudo docker run -it --network hadoop -h &quot;h05&quot; --name &quot;h05&quot; slave14 /bin/bash</code><br>
退出：<br>
<code>sudo docker commit -m &quot;master&quot; -a &quot;tomding&quot; h01 master</code><br>
<code>sudo docker commit -m &quot;slave1&quot; -a &quot;tomding&quot; h02 slave1</code><br>
<code>sudo docker commit -m &quot;slave2&quot; -a &quot;tomding&quot; h03 slave2</code><br>
<code>sudo docker commit -m &quot;slave3&quot; -a &quot;tomding&quot; h04 slave3</code><br>
<code>sudo docker commit -m &quot;slave4&quot; -a &quot;tomding&quot; h05 slave4</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[特征统计]]></title>
        <id>https://dingtom.github.io/post/ji-zhong-qu-shi-fen-xi-chi-san-cheng-du-fen-xi/</id>
        <link href="https://dingtom.github.io/post/ji-zhong-qu-shi-fen-xi-chi-san-cheng-du-fen-xi/">
        </link>
        <updated>2020-11-27T09:10:13.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/dingtom/python/blob/master/%E7%BB%9F%E8%AE%A1.ipynb">https://github.com/dingtom/python/blob/master/%E7%BB%9F%E8%AE%A1.ipynb</a><br>
`</p>
<h2 id="特征统计">特征统计</h2>
<p>特征统计可能是数据科学中最常用的统计学概念。它是你在研究数据集时经常使用的统计技术，包括偏差、方差、平均值、中位数、百分数等等。</p>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-f6ad8aaac18ba88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="箱型图" loading="lazy"></figure>
<p>中间的直线表示数据的中位数（对异常值更具有鲁棒性）。<br>
第一个四分位数（即数据中的25%要低于该值）。<br>
第三个四分位数（即数据中的75%要低于该值）。</p>
<ul>
<li>当箱形图很短时，就意味着很多数据点是相似的，因为很多值是在一个很小的范围内分布;</li>
<li>如果中位数接近了底部，那么大部分的数据具有较低的值。基本上，如果中位线不在框的中间，那么就表明了是偏斜数据;</li>
<li>如果框上下两边的线很长表示数据<s>具有很高的标准偏差和方差</s>，意味着这些值被分散了，并且变化非常大。</li>
</ul>
<h1 id="概率分布">概率分布</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-4c7b9565a240309f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="均匀分布" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-34e1e11b3edf40ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正态分布" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-ad02a5cea35a9122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泊松分布" loading="lazy"></p>
<h1 id="频数与频率">频数与频率</h1>
<ul>
<li>预数，指一组数据中类别变量的每个不同取值出现的次数。</li>
<li>频率，指每个类别变量的频数与总次数的比值，通常采用百分数表示。</li>
</ul>
<pre><code># 计算鸢尾花数据集中每个类别出现的频数
frequency = df[&quot;types&quot;].value_counts() / len(df)
print(frequency.shape)
print(frequency)
plt.bar([1, 2, 3], frequency)
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-e6622ef2938a600b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="集中趋势分析">集中趋势分析</h1>
<ul>
<li>均值</li>
<li>中位数</li>
<li>众数</li>
</ul>
<blockquote>
<p>”数值变量”通常使用均值与中值表示集中趋势。<br>
“类别变量”通常使用众数表示集中趋势。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-6c6a67d920539438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
记忆方法：哪边的尾巴长，就叫做 “X偏”。左边的尾巴长，就叫做“左偏”；右边的尾巴长，就叫做“右偏”。并且均值离着尾巴最近，中位数总是在最中间，众数离着尾巴最远。</p>
</blockquote>
<ul>
<li>分位数，将数据从小到大排列，通过n-1个分位数将数据分为n个区间，使得每个区间的数值的个数相等(近似相等)。</li>
</ul>
<pre><code>mean = df[&quot;sepal length (cm)&quot;].mean()  
median = df[&quot;sepal length (cm)&quot;].median() 
print('mean, median',mean, median)  
# 由于series中没有专门计算众数的函数， # scipy的stats模块中，可以计算众数  
from scipy import stats  
t = stats.mode(df[&quot;sepal length (cm)&quot;])  
# 注意：t展示的类字典格式的数据类型，mode展示众数，count用于展示众数出现的次数   
print(t.mode, t.count)  
</code></pre>
<p>mean, median 5.843333333333335 5.8<br>
[5.] [10]</p>
<pre><code>sns.distplot(df[&quot;sepal length (cm)&quot;])  
plt.axvline(mean,ls=&quot;-&quot;,color=&quot;r&quot;,label=&quot;均值&quot;) 
plt.axvline(median,ls=&quot;-&quot;,color=&quot;g&quot;,label=&quot;中值&quot;)
plt.axvline(t.mode,ls=&quot;-&quot;,color=&quot;indigo&quot;,label=&quot;众数&quot;) 
plt.legend(loc=&quot;best&quot;)
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/18339009-8112dca9a0d8c36f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<pre><code># 分位数
x = np.arange(10,20) 
q = np.quantile(x,[0.25,0.5,0.75])
plt.figure(figsize=(15,4))
plt.xticks(x)
plt.plot(x,np.zeros(len(x)),ls=&quot;&quot;,marker=&quot;D&quot;,ms=15,label=&quot;元素值&quot;)
plt.plot(q,np.zeros(len(q)),ls=&quot;&quot;,marker=&quot;X&quot;,ms=15,label=&quot;四分位值&quot;)
for v in q:     
    plt.text(v,0.01,v,fontsize=15)
plt.legend()
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://upload-images.jianshu.io/upload_images/18339009-3e9ebd3e4b3a505e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="离散程度分析">离散程度分析</h1>
<ul>
<li>
<p>极差，极差指一组数据中，最大值与最小值之差。</p>
</li>
<li>
<p>方差，方差体现的是一组数据中，每个元素与均值偏离的大小。</p>
</li>
<li>
<p>标准差，标准差标准差为方差的开方。</p>
</li>
</ul>
<pre><code>sub = df[&quot;sepal length (cm)&quot;].max()  - df[&quot;sepal length (cm)&quot;].min() 
var = df[&quot;sepal length (cm)&quot;].var()
std = df[&quot;sepal length (cm)&quot;].std()
print(sub, var, std)
</code></pre>
<p>3.6000000000000005 0.6856935123042505 0.8280661279778629</p>
<pre><code>plt.figure(figsize=(15,4))
plt.ylim(-0.5,1.5)
plt.plot(df[&quot;sepal length (cm)&quot;],np.zeros(len(df)),ls=&quot;&quot;,marker=&quot;o&quot;,ms=10,color=&quot;g&quot;,label=&quot;花瓣长度&quot;)
plt.plot(df[&quot;sepal width (cm)&quot;],np.ones(len(df)),ls=&quot;&quot;,marker=&quot;o&quot;,ms=10,color=&quot;b&quot;,label=&quot;花瓣宽度&quot;)
         
plt.axvline(df[&quot;sepal length (cm)&quot;].mean(),ls=&quot;--&quot;,color=&quot;g&quot;,label=&quot;花瓣长度均值&quot;)
plt.axvline(df[&quot;sepal width (cm)&quot;].mean(),ls=&quot;-&quot;,color=&quot;b&quot;,label=&quot;花瓣宽度均值&quot;)

plt.legend()
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://upload-images.jianshu.io/upload_images/18339009-1e63ba109f5053ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="分布形状">分布形状</h1>
<ul>
<li>偏度，偏度是统计数据分布偏斜方向和程度的度量，是统计数据分布非对称程度的数字特征。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-1d29f1c0af7f7546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></li>
</ul>
<h2 id="偏度skewness">偏度（Skewness）</h2>
<p>Definition:是描述数据分布形态的统计量，其描述的是某总体取值分布的对称性，<strong>简单来说就是数据的不对称程度。</strong><br>
偏度是三阶中心距计算出来的。<br>
（1）Skewness = 0 ，分布形态与正态分布偏度相同。<br>
（2）Skewness &gt; 0 ，正偏差数值较大，为正偏或右偏。长尾巴拖在右边，数据右端有较多的极端值。<br>
（3）Skewness &lt; 0 ，负偏差数值较大，为负偏或左偏。长尾巴拖在左边，数据左端有较多的极端值。<br>
（4）数值的绝对值越大，表明数据分布越不对称，偏斜程度大。<br>
计算公式：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>k</mi><mi>e</mi><mi>w</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>E</mi><mo>[</mo><mo>(</mo><mo>(</mo><mi>x</mi><mo>−</mo><mi>E</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><msqrt><mrow><mi>D</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msqrt><mo>)</mo><msup><mo>)</mo><mn>3</mn></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">Skewness=E[((x-E(x))/(\sqrt{D(x)}))^3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span><br>
| Skewness| 越大，分布形态偏移程度越大。</p>
<h2 id="峰度kurtosis">峰度（Kurtosis）</h2>
<p>Definition:偏度是描述某变量所有取值分布形态陡缓程度的统计量，<strong>简单来说就是数据分布顶的尖锐程度。</strong><br>
峰度是四阶标准矩计算出来的。<br>
（1）Kurtosis=0 与正态分布的陡缓程度相同。<br>
（2）Kurtosis&gt;0 比正态分布的高峰更加陡峭——尖顶峰<br>
（3）Kurtosis&lt;0 比正态分布的高峰来得平台——平顶峰<br>
计算公式：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>u</mi><mi>r</mi><mi>t</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>s</mi><mo>=</mo><mi>E</mi><mo>[</mo><mo>(</mo><mo>(</mo><mi>x</mi><mo>−</mo><mi>E</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><msqrt><mo>(</mo></msqrt><mi>D</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>)</mo><msup><mo>)</mo><mn>4</mn></msup><mo>]</mo><mo>−</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">Kurtosis=E[ ( (x-E(x))/ (\sqrt(D(x))) )^4 ]-3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mopen" style="padding-left:1em;">(</span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></p>
<ul>
<li>峰度， 峰度是描述总体中所有取值分布形态陡缓程度的统计量，可以讲峰度理解为数据分布的高矮程度，峰度的比较是相对于标准正态分布的。</li>
</ul>
<blockquote>
<p>对于标准正态分布，峰度为0。<br>
如果峰度大于0，说明数据在分布上比标准正态分布密集，方差(标准差)较小。<br>
如果峰度小于0，说明数据在分布上比标准正态分布分散，方差(标准差)较大。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-9828218e64b397ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
</blockquote>
<pre><code>t1 = np.random.randint(1,11,100)
t2 = np.random.randint(11,21,500)
t3 = np.concatenate([t1,t2])
print(t3.shape)
left_skew = pd.Series(t3)

t1 = np.random.randint(1,11,500)
t2 = np.random.randint(11,21,100)
t3 = np.concatenate([t1,t2])
right_skew = pd.Series(t3)
print(left_skew.skew(),right_skew.skew())

sns.kdeplot(standard_normal,label=&quot;标准正态分布&quot;)
sns.kdeplot(df[&quot;sepal length (cm)&quot;],label=&quot;花萼长度&quot;)
sns.kdeplot(df[&quot;sepal width (cm)&quot;],label=&quot;花萼宽度&quot;)

sns.kdeplot(left_skew,shade=True,label=&quot;左偏&quot;) 
sns.kdeplot(right_skew,shade=True,label=&quot;右偏&quot;) 
plt.legend()

print(&quot;Kurtosis: %f&quot; % Train_data['price'].kurt())
sns.distplot(Train_data.kurt(),color='orange',axlabel ='Kurtness')

# fig, axes=plt.subplots(nrows=2, ncols=1, figsize=(14,6)) 
# axes[0].hist(left_skew,label=&quot;左偏&quot;)
# axes[1].hist(right_skew,label=&quot;右偏&quot;)
plt.legend()
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://upload-images.jianshu.io/upload_images/18339009-668cc417ccd32acc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AB测试]]></title>
        <id>https://dingtom.github.io/post/ab-ce-shi/</id>
        <link href="https://dingtom.github.io/post/ab-ce-shi/">
        </link>
        <updated>2020-11-27T07:23:37.000Z</updated>
        <content type="html"><![CDATA[<p>将Web或App界面或流程的两个或多个版本，<s>在同一时间维度</s>，分别让两个或多个属性或组成成分<s>相同（相似）<s>的访客群组访同，收集各群组的</s>用户体验数据和业务数据</s>，最后分析评估出<s>最好版本正式采用</s>。</p>
<h2 id="主要应用场景">主要应用场景：</h2>
<p><s>界面设计、算法优化</s>。</p>
<h2 id="流程">流程：</h2>
<p>1、分析实际业务场景，明确<s>改进关键点。</s><br>
2、与项目经理<s>确定优化目标，设计优化方案。</s><br>
3、根据优化目标及方案搭建<s>数据分析指标体系，明确数据口径。</s><br>
4、由UI设计师或算法工程师根据方案<s>完成样例开发，并设定数据埋点。</s><br>
5、调整流量池，在<s>同一时间内对目标用户开始测试</s>。<br>
6、根据时间进度及时收集数据，并根据数据情况<s>调整流量池或重新进行测试</s><br>
7、经过多次试验取得成功后，确定新版本功能，<s>正式发布。</s></p>
<h2 id="注意事项">注意事项：</h2>
<ul>
<li>
<p>忽略个别异常<br>
AB测试要分析<s>参与测试用户的整体分布情况</s>，而不仅仅是个别用户的情况。<s>如出现了个别异常值，重点是需要保证整体分布没有大的异常即可继续进行AB测试</s>，对于异常值，可以重直关注其产生的根本原因，可能是其他可优化直。</p>
</li>
<li>
<p>数据有效性<br>
正常情况下，在推进AB测试时，<s>前三天的数据波动会比教大，不建议直接使用</s>，测试需要大约7-14天为周期进行推进，切不可心急。对不同行业应用的产品，也要根据用户使用周期进行调整，~~一定要完整覆盖整个户周期。~~如电商平台在进行AB测试时，就需要注意工作日与节假日的影响不同，需要将测试周期定在一周以上。</p>
</li>
<li>
<p>用户反馈反方向发展<br>
在这种情况下，<s>先缩小测试用的流量池</s>，减少测试的用户数量；另一方面，分析目前的用户反馈情况，跟进反馈背后<s>问题的真实原因，优化调整AB测试方案</s>。千万<s>不要着急直接停止AB测试</s>，认真分析问题产生的根源，待情况明确，新方案制定后继续进行AB测试。</p>
</li>
</ul>
<h2 id="灰度测试">灰度测试：</h2>
<p>由于调整版本对企业影响极大，设定目标中的两个版本可能都不是有效版本，故不能将所有用户直接一分为二全部进行AB测试，对此可以采用灰度发布的方式，即<s>只选择其中极小部分用户进行AB測试，并逐步推广到所有用户。</s></p>
<h2 id="abn测试">ABN测试：</h2>
<p>在AB测试设计初期，可能提出了多种优化版本，对此并不一定只能要求其中一种版本进行AB测试，可<s>同时选择类型相同的版本同时进行AB测试，此类方法称为ABN试。</s><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e43f7922afc4d4ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="anb-测试">ANB  测试：</h2>
<p>在进AB测试过程中，可能会有个别特因素对测试结果有异常明确的影响，如遇到有特殊用户刷量等。为了免此类情况的发生对AB测试产生影响，可以考虑进行ANB测试（AA测试的加强版），<s>避免偶然因素对目标产生误差。</s><br>
具体原理如下图：<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e99a4516ae78c68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="多维测试">多维测试</h2>
<p>可以在多个维度内同时推进AB测试，但是<s>一定要保任意两个维度内互不影响</s><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e6099c32a5954649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="数据分析师需要扮演的角色">数据分析师需要扮演的角色：</h2>
<p>1、针对业务场景，<s>制定专题分析，明确分析目标</s><br>
2、AB测试初期，分析业务场景，<s>提出优化方向</s><br>
3、与产品经理沟通设计解决方案，<s>制定数据分析体系，明确数据口径</s><br>
4、与测试人员<s>明确流量分配情况</s>，确保流量分配方式有效。<br>
5、及时<s>收集数据</s>，分析并对测试过程<s>不断优化</s>。<br>
6、跟进试过程，<s>了解测试用户的反馈情况</s>，分析其他优化点。<br>
7、完成测试后，<s>撰写专題报告</s>，整理测试方案、测试数据、测试报告等完成<s>文件归档。</s></p>
<h1 id="例子"><a href="https://github.com/dingtom/python/blob/master/ABtest.ipynb">例子</a></h1>
<p><a href="https://alltodata.cowtransfer.com/s/b6eddb13746642">数据</a><br>
给网站投放广告的时候，一开始给大家看到的落地页是访问课程资料，现在我们又推出了开始免费试学这个落地页，然后想着以后换上新的落地页，这时候就要检测两个落地页的转化效果了，下面是测试的24天，目的是确定使用新落地页，还是使用旧落地页，或是延长测试时<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-2ad2fdd698f4b6f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-ef1626d4bbd41bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<p>结论：由于z_score=1.31小于norm.ppf(1-0.05)=1.64，落在95%的置信区间中，所以无法拒绝原假设，建议延长测试时间，继续观测情况。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试3（计算机基础）]]></title>
        <id>https://dingtom.github.io/post/mian-shi-3ji-suan-ji-ji-chu/</id>
        <link href="https://dingtom.github.io/post/mian-shi-3ji-suan-ji-ji-chu/">
        </link>
        <updated>2020-11-26T06:45:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="按照二叉树的定义4个节点的二叉树有多少种">按照二叉树的定义，4个节点的二叉树有多少种？</h1>
<p>0个节点的二叉树有1种,即f(0)=1;<br>
1个节点的二叉树有1种,即f(1)=1;<br>
2个节点的二叉树有2种，即f(2)=2；<br>
3个节点的二叉树肯定先得固定一个根节点，然后还剩2个节点，这两个节点有三种排列方式，根节点左边两个、根节点左边一个右边一个、根节点右边两个，这样的话就可以用f(0),f(1)和f(2)来求了：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>2</mn><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">f(3)=f(2)*f(0)+f(1)*f(1)+f(0)*f(2)=2*1+1*1+1*2=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>;同理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>4</mn><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>=</mo><mn>5</mn><mo>∗</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>5</mn><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">f(4)=f(3)*f(0)+f(2)*f(1)+f(1)*f(2)+f(0)*f(3)=5*1+2*1+1*2+1*5=14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span>;于是就有了递推公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=f(n-1)*f(0)+f(n-2)*f(1)+···+f(1)*f(n-2)+f(0)f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h1 id="网络层">网络层</h1>
<p>OSI中的层</p>
<table>
<thead>
<tr>
<th style="text-align:center">层</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">协议</th>
<th style="text-align:center">设备</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">为操作系统或网络应用程序提供访问网络服务的接口。</td>
<td style="text-align:center">FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">(TCP/IP无)表示层</td>
<td style="text-align:center">数据格式化、转换</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">(TCP/IP无)会话层</td>
<td style="text-align:center">管理主机之间的会话进程</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">提供端对端传输</td>
<td style="text-align:center">CP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）</td>
<td style="text-align:center">网关</td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">路由选择</td>
<td style="text-align:center">IP协议（Internet Protocol，因特网互联协议）;ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;ARP协议（Address Resolution Protocol，地址解析协议）;RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</td>
<td style="text-align:center">路由器</td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">提供可靠的数据传输</td>
<td style="text-align:center">以太网协议</td>
<td style="text-align:center">网桥和交换机</td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">提供一个传输数据的可靠的物理媒体</td>
<td style="text-align:center"></td>
<td style="text-align:center">中继器（Repeater，也叫放大器）和集线器</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-546d626b3b6edd73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实际应用还是 TCP/IP 四层体系结构" loading="lazy"></figure>
<p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。<br>
DNS是域名系统(DomainNameSystem)，将URL转换为IP地址<br>
NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技.</p>
<h1 id="ip地址">IP地址</h1>
<p>255.255.255.255该IP地址指的是受限的广播地址。</p>
<blockquote>
<p>受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。</p>
</blockquote>
<p>localhost</p>
<blockquote>
<p>不联网 ，不使用网卡，不受防火墙和网卡限制 ，本机访问</p>
</blockquote>
<p>127.0.0.0/8</p>
<blockquote>
<p>不联网 ，网卡传输，受防火墙和网卡限制 ，本机访问<br>
用作回环地址，在主机上发送给127开头的IP地址的数据包会被发送的主机自己接收。</p>
</blockquote>
<p>本机IP</p>
<blockquote>
<p>联网 ，网卡传输 ，受防火墙和网卡限制 ，本机或外部访问</p>
</blockquote>
<p>0.0.0.0</p>
<blockquote>
<p>它表示本机中所有的IPV4地址。</p>
</blockquote>
<p>私有地址(private address)</p>
<blockquote>
<p>也叫专用地址，它们不会在全球使用，只具有本地意义。<br>
A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255<br>
B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255<br>
C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p>
</blockquote>
<p>子网掩码</p>
<blockquote>
<p>标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</p>
</blockquote>
<h2 id="子网划分">子网划分</h2>
<p>主机位全0代表网络地址<br>
主机位全1代表广播地址</p>
<blockquote>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-0adf85df2ed8b10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
解析：先判断为C类地址，要五个子网，需要三个1：11100000；剩下五个主机数，2的五次方-2=30&gt;28，所以主机数也够，因此子网掩码应为：255.255.255.224；<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-7e3519e6bee82bd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
</blockquote>
</blockquote>
<h1 id="三次握手">三次握手</h1>
<p>序列号seq：占4个字节，用来<s>标记数据段</s>的顺序<br>
确认号ack：占4个字节，期待收到对方<s>下一个报文段的第一个数据字节的序号</s><br>
确认ACK：占1位，~~仅当ACK=1时，确认号字段ack才有效。~~ACK=0时，确认号无效<br>
同步SYN：连接建立时用于同步序号。<s>当SYN=1，ACK=0时表示：这是一个连接请求报文段</s>。~~若同意连接，则在响应报文段中使得SYN=1，ACK=1。~~因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。<br>
终止FIN：用来释放一个连接。<s>FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</s><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b2e011d8e291b309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-cd177a4f9867fc92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h1 id="四次挥手">四次挥手</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-5410b0192c8199e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-5ea4d776df3a350d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<p>为什么要三次握手呢？主要是为了信息对等和防止出现请求超时导致脏连接。</p>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-72cf315559f0ec3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
只有三次握手之后<s>才能够保证两台服务器都具备发报和收报能力。</s></p>
</blockquote>
<p>为什么会出现脏连接？</p>
<blockquote>
<p>因为TTL 网络报文的生存时间往往都会超 TCP 请求超时时间，如果两次握手就可以创建连接 ，传输数据并释放连接后，第一个超时的连接请求才到达 B 机器的话，B 机器会以为是 A 创建新连接的请求，然后确认同意创建连接。因为 A 机器的状态不是 SYl_SENT ，所以直接丢弃了 B 的确认数据 ，以致最后只是 B 机器单方面创建连接完毕。</p>
</blockquote>
<p>为什么连接的时候是三次握手，关闭的时候却是四次握手</p>
<blockquote>
<p>答：Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
</blockquote>
<p>如果已经建立了连接，但是客户端突然出现故障了怎么办?</p>
<blockquote>
<p>答：<s>TCP还设有一个保活计时器</s>，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
</blockquote>
<h1 id="为什么客户端发出第四次挥手的确认报文后要等2msl的时间才能释放tcp连接">为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h1>
<p>这里同样是要考虑丢包的问题，如果<s>第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL</s>，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<h1 id="http-https">http、https</h1>
<p>HTTP：运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份<br>
HTTPS：身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， 是添加了加密和认证机制的 HTTP。<br>
状态码的类别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational（信息性状态码） 接受的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码） 请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码） 需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码） 服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码） 服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h1 id="tcp和udp有哪些区别">TCP和UDP有哪些区别。</h1>
<h1 id="get和post区别">GET和POST区别</h1>
<p>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。<br>
POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。<br>
PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。<br>
DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</p>
<p><s>Get是不安全的</s>，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p>
<p><s>Get请求提交的url中的数据最多只能是2048字节</s>，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。</p>
<p><s>Get限制Form表单的数据集的值必须为ASCII字符</s>；而Post支持整个ISO10646字符集。</p>
<p><s>Get执行效率却比Post方法好</s>。Get是form提交的默认方法。</p>
<h1 id="对称加密与非对称加密">对称加密与非对称加密</h1>
<p>对称密钥加密是指<s>加密和解密使用同一个密钥的方式</s>，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；<br>
而非对称加密是指使用一对非对称密钥，即<s>公钥和私钥，公钥可以随意发布，但私钥只有自己知道</s>。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。<br>
由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</p>
<h1 id="简述-cookie和-session的区别">简述 cookie？和 session的区别</h1>
<p>cookie是由Web~~服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。~~客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</p>
<p>1, session在服务器端， cookie在客户端（浏览器）<br>
2，session的运行依赖 session id，而 session id是存在 cookie中的，也就是说，如果浏览器禁用了 cookie，同时 session也会失效，存储 Session时，键与 Cookie中的sessionid相同，值是开发人员设置的键值对信息，进行了base64编码，过期时间由开发人员设置<br>
3，cookie安全性比 session差</p>
<h1 id="sql注入">SQL注入</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-b53953def3dedd79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
解決方式：通过传参数方式解决SQL注入<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-cbdf12c3596bc7f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h1 id="关系型数据库和非关系型数据库">关系型数据库和非关系型数据库</h1>
<p>关系模型指的就是二维表格模型，好比Excel文件中的表格，强调用表格的方式存储数据（有字段，表与表之间还有关系）</p>
<blockquote>
<ul>
<li>Oracle</li>
<li>Microsoft SQL Server</li>
<li>MySQL：数据保存在磁盘中，检索的话，会有一定的操作，访问速度相<br>
对慢</li>
<li>SQLite（手机端的）</li>
</ul>
</blockquote>
<p>非关系型数据库,即NoSQL（not only SQL），非关联型的，强调Key-Value的方式存储数据</p>
<blockquote>
<ul>
<li>MongoDB</li>
<li>Redis：内存型，数据保存在内存中，速度快</li>
</ul>
</blockquote>
<h1 id="进程与线程的区别">进程与线程的区别</h1>
<p>1.<s>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位</s></p>
<ol>
<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</li>
<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；<br>
4.调度和切换：线程上下文切换比进程上下文切换要快得多</li>
</ol>
<h1 id="可变数据类型和不可变数据类型">可变数据类型和不可变数据类型</h1>
<p><s>不可变数据类型：数值型、字符串型string和元组tuple</s></p>
<p><s>不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址）</s>，如下图用id()方法可以打印对象的id</p>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-9589825b5b5a5d08.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p>可变数据类型：列表list和字典dict；</p>
<p>允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，~~只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，~~即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/18339009-2f0cc1774c1dc642.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p><s>Python使用乘号复制双层列表，内层数组指向同一个物理地址</s></p>
<pre><code class="language-python">a = [[1]] * 3
print(a)
a[0][0]=2
a
# [[2], [2], [2]]
</code></pre>
<h1 id="深拷贝和浅拷贝的区别">深拷贝和浅拷贝的区别</h1>
<p>在浅拷贝时，拷贝出来的<s>新对象的地址和原对象是不一样</s>的，但是新对象里面的<s>可变元素（如列表）的地址和原对象里的可变元素的地址是相同的</s>，浅拷贝它拷贝的是浅层次的数据结构（不可变元素），对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去。</p>
<p>赋值： 值相等，地址相等<br>
copy浅拷贝：值相等，地址不相等(深层地址相等)<br>
deepcopy深拷贝：值相等，地址不相等</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[markdwon]]></title>
        <id>https://dingtom.github.io/post/markdwon/</id>
        <link href="https://dingtom.github.io/post/markdwon/">
        </link>
        <updated>2020-11-26T00:56:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="生成目录">生成目录</h1>
<pre><code>[TOC]
</code></pre>
<p>[TOC]</p>
<h1 id="to-do-list">To Do List</h1>
<pre><code>- [x] 学习python基础 【减号+[+空格或x+]+空格】
- [ ] 学习python网络编程
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-58fe77302ab071f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h1 id="横线">横线</h1>
<pre><code>---
</code></pre>
<hr>
<h1 id="删除线">删除线</h1>
<pre><code>~~哈哈~~
</code></pre>
<p><s>哈哈</s></p>
<h1 id="列表点号">列表点号</h1>
<pre><code>- 
</code></pre>
<ul>
<li></li>
</ul>
<h1 id="表格">表格</h1>
<pre><code>|Theme name|Value|Directive|
|:-:|:-:|:-:|
|***Default***|default|`&lt;!-- $theme: default --&gt;`
|**Gaia**|gaia|`&lt;!-- $theme: gaia --&gt;`
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">Theme name</th>
<th style="text-align:center">Value</th>
<th style="text-align:left">Directive</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em><strong>Default</strong></em></td>
<td style="text-align:center">default</td>
<td style="text-align:left"><code>&lt;!-- $theme: default --&gt;</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>Gaia</strong></td>
<td style="text-align:center">gaia</td>
<td style="text-align:left"><code>&lt;!-- $theme: gaia --&gt;</code></td>
</tr>
</tbody>
</table>
<pre><code>&lt;table&gt;
    &lt;tr&gt;&lt;th rowspan=4&gt;会员登记表&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th colspan=3&gt;个人信息&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;未婚&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;&lt;td&gt;女&lt;/td&gt;&lt;td&gt;35&lt;/td&gt;&lt;td&gt;已婚&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;王五&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;45&lt;/td&gt;&lt;td&gt;离异&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<h1 id="标注颜色">标注颜色</h1>
<pre><code>==word==
</code></pre>
<p><mark>word</mark></p>
<h1 id="设置背景">设置背景</h1>
<pre><code>![bg](http://img0.imgtn.bdimg.com/it/u=1377132983,1746819781&amp;fm=26&amp;gp=0.jpg)
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://img0.imgtn.bdimg.com/it/u=1377132983,1746819781&amp;fm=26&amp;gp=0.jpg" alt="bg" loading="lazy"></figure>
<h1 id="设置文字背景">设置文字背景</h1>
<pre><code>&lt;span style=&quot;background-color:yellow;&quot;&gt;yellow marker highlight&lt;/span&gt;
</code></pre>
<p><span style="background-color:yellow;">yellow marker highlight</span></p>
<h1 id="区块引用">区块引用</h1>
<pre><code>* python
&gt; 一种编程语言

&gt; 一级引用
&gt;&gt; 二级引用
&gt;&gt;&gt; 三级引用

</code></pre>
<ul>
<li>python</li>
</ul>
<blockquote>
<p>一种编程语言</p>
</blockquote>
<blockquote>
<p>一级引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="链接">链接</h1>
<pre><code>[Yuki Hattori](https://github.com/yhatt)
</code></pre>
<p><a href="https://github.com/yhatt">Yuki Hattori</a></p>
<h1 id="锚点">锚点</h1>
<p>跳转需要按住ctrl</p>
<pre><code># titleA //这是个一级标题，锚点

[titleA](#titleA) //这是锚点引用格式
</code></pre>
<p><a href="#%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95">生成目录</a> //这是锚点引用格式</p>
<h1 id="注脚">注脚</h1>
<pre><code>使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。
[^1]:Markdown是一种纯文本标记语言
[^2]:HyperText Markup Language 超文本标记语言
[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文
</code></pre>
<p>使用 Markdown<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>可以效率的书写文档, 直接转换成 HTML<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>, 你可以使用 Leanote<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 编辑器进行书写。</p>
<h1 id="定义图片尺寸">定义图片尺寸</h1>
<pre><code>&lt;img width = '150' height ='150' src =&quot;https://tse2-mm.cn.bing.net/th?id=OIP.rF3VYN1CRvtyWBPU0I7kyQDMEy&amp;p=0&amp;pid=1.1&quot;/&gt;
</code></pre>
<img width = '150' height ='150' src ="https://tse2-mm.cn.bing.net/th?id=OIP.rF3VYN1CRvtyWBPU0I7kyQDMEy&p=0&pid=1.1"/>
<h1 id="图片居中">图片居中</h1>
<pre><code>&lt;div align=center&gt;&lt;img width = '150' height ='150' src =&quot;https://tse2-mm.cn.bing.net/th?id=OIP.rF3VYN1CRvtyWBPU0I7kyQDMEy&amp;p=0&amp;pid=1.1&quot;/&gt;&lt;/div&gt;
</code></pre>
<div align=center><img width = '150' height ='150' src ="https://tse2-mm.cn.bing.net/th?id=OIP.rF3VYN1CRvtyWBPU0I7kyQDMEy&p=0&pid=1.1"/></div>
<h1 id="插入音乐">插入音乐</h1>
<pre><code>&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=528478901&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;
</code></pre>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=528478901&auto=1&height=66"></iframe>
<h1 id="插入视频">插入视频</h1>
<pre><code>&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=69570770&amp;cid=120575067&amp;page=1&amp;danmaku=0&quot; allowfullscreen=&quot;allowfullscreen&quot; width=&quot;100%&quot; height=&quot;500&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; sandbox=&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;&gt;&lt;/iframe&gt;
</code></pre>
<iframe src="//player.bilibili.com/player.html?aid=69570770&cid=120575067&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>
<h1 id="设置字体">设置字体</h1>
<pre><code>&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;
&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;
&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font》
&lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt;
</code></pre>
<p><font face="黑体">我是黑体字</font><br>
<font face="微软雅黑">我是微软雅黑</font><br>
<font face="STCAIYUN">我是华文彩云</font><br>
<font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font></p>
<h1 id="emoj表情">emoj表情</h1>
<p>https://github.com/guodongxiaren/README/blob/master/emoji.md</p>
<h1 id="首行缩进">首行缩进</h1>
<pre><code>半方大的空白&amp;ensp;或&amp;#8194;
全方大的空白&amp;emsp;或&amp;#8195;
不断行的空白格&amp;nbsp;或&amp;#160;
</code></pre>
<p>半方大的空白 或 <br>
全方大的空白 或 <br>
不断行的空白格 或 </p>
<h1 id="绘图">绘图</h1>
<p><a href="https://blog.csdn.net/qq_18150255/article/details/88043774">https://blog.csdn.net/qq_18150255/article/details/88043774</a><br>
<a href="https://blog.csdn.net/weixin_30307267/article/details/99385290">https://blog.csdn.net/weixin_30307267/article/details/99385290</a></p>
<h1 id="甘特图">甘特图</h1>
<pre><code>gantt
dateFormat YYYY-MM-DD
title “所见”微信小程序-项目进度甘特图
需求分析 :active, des2, 2019-04-10, 5d
可行性分析 :active, des2, 2019-04-13, 4d
项目开发计划 :active, des2, 2019-04-16, 5d
系统设计 :active, des2, 2019-04-19, 7d
开发实现 :active, des2, 2019-04-26, 14d
UI设计 :active, des2, 2019-04-26, 7d
数据库设计 :active, des2, 2019-05-05, 5d
系统测试 :active, des2, 2019-05-10, 5d
操作手册 :active, des2, 2019-05-15, 5d
用户手册 :active, des2, 2019-05-15, 5d
完善项目文档/准备答辩 : des3, after des2, 10d
</code></pre>
<h1 id="流程图">流程图</h1>
<p>流程图代码分两块，上面一块是创建你的流程（创建元素），然后隔一行，创建流程的走向(连接元素)</p>
<p>#####创建流程（元素）：tag=&gt;type: content:&gt;url<br>
<strong>tag 是流程图中的标签</strong>，在第二段连接元素时会用到。名称可以任意，一般为流程的英文缩写和数字的组合。<br>
<strong>type 用来确定标签的类型</strong>，=&gt;后面表示类型。由于标签的名称可以任意指定，所以要依赖type来确定标签的类型<br>
标签有6种类型：start 、end 、operation 、subroutine 、condition 、inputoutput<br>
<strong>content 是流程图文本框中的描述内容</strong>，: 后面表示内容，中英文均可。特别注意，冒号与文本之间一定要有个空格<br>
<strong>url是一个连接</strong>，与框框中的文本相绑定，:&gt;后面就是对应的 url 链接，点击文本时可以通过链接跳转到 url 指定页面</p>
<h5 id="指向流程连接元素标识类别-下一个标识">指向流程(连接元素)：标识（类别）-&gt;下一个标识</h5>
<p>使用 -&gt; 来连接两个元素<br>
对于<strong>condition类型</strong>，有yes和no两个分支，如示例中的cond(yes)和cond(no)<br>
每个元素可以制定分支走向，默认向下，也可以用right指向右边，如示例中cond2(yes,right)。</p>
<p>流程图元素</p>
<pre><code>star1=&gt;start: 开始 
end1=&gt;end: 登录 
in1=&gt;inputoutput: 输入用户名密码 
sub1=&gt;subroutine: 数据库查询子类 
cond1=&gt;condition: 是否有此用户 
cond2=&gt;condition: 密码是否正确 
ope1=&gt;operation: 读入用户信息
star1-&gt;in1-&gt;sub1-&gt;cond1 
cond1(yes,right)-&gt;cond2 
cond1(no)-&gt;in1(right) 
cond2(yes,right)-&gt;ope1-&gt;end1
cond2(no)-&gt;in1
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Markdown是一种纯文本标记语言 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>HyperText Markup Language 超文本标记语言 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>开源笔记平台，支持Markdown和笔记直接发为博文 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql]]></title>
        <id>https://dingtom.github.io/post/mysql/</id>
        <link href="https://dingtom.github.io/post/mysql/">
        </link>
        <updated>2020-11-26T00:38:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<h2 id="win">win</h2>
<blockquote>
<p>https://dev.mysql.com/downloads/mysql/<br>
<a href="http://mirrors.sohu.com/mysql/MySQL-8.0/">http://mirrors.sohu.com/mysql/MySQL-8.0/</a><br>
配置环境变量path<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-6c5c4e1ade3e95ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b6f751a6e0727c08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
新建一个my.ini 用记事本打开</p>
</blockquote>
<pre><code>[mysqld]
# 设置mysql的安装目录
basedir=D:\\software\\java\\mysql-5.7.28-winx64
# 切记此处一定要用双斜杠\\，单斜杠这里会出错。
# 设置mysql数据库的数据的存放目录
datadir=D:\\software\\java\\mysql-5.7.28-winx64\\Data
# 此处同上
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors=10
# 服务端使用的字符集默认为UTF8
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin=mysql_native_password
[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8
[client]
# 设置mysql客户端连接服务端时默认使用的端口
port=3306
default-character-set=utf8
</code></pre>
<p>管理员权限下运行cmd</p>
<pre><code>mysqld -install
# 执行初始化代码（会在根目录创建data文件夹，并创建root用户）
mysqld --initialize-insecure --user=mysql
# 启动mysql服务
net start mysql
</code></pre>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-3b3965a4ecafa1f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
##ubuntu</p>
</blockquote>
<pre><code>sudo apt-get install mysql-server
#sudo apt-get install mysql-client
</code></pre>
<p><s>删除 mysql</s></p>
<pre><code>sudo apt-get autoremove --purge mysql-server
sudo apt-get remove mysql-server
sudo apt-get autoremove mysql-server
sudo apt-get remove mysql-common
</code></pre>
<p><s>清理残留数据</s></p>
<pre><code>dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P
</code></pre>
<p>进入mysql</p>
<pre><code>sudo mysql -uroot -p 
</code></pre>
<p>配置 MySQL 的管理员密码：</p>
<pre><code>sudo mysqladmin -u root password newpassword
</code></pre>
<p>安装MySQL-workbench</p>
<pre><code>sudo apt-get install mysql-workbench
</code></pre>
<p>一旦安装完成，MySQL 服务器应该自动启动。您可以在终端提示符后运行以下命令来检查 MySQL 服务器是否正在运行：</p>
<pre><code>sudo netstat -tap | grep mysql
</code></pre>
<p>当您运行该命令时，您可以看到类似下面的行：<br>
tcp 0 0 localhost.localdomain:mysql <em>:</em> LISTEN -<br>
如果服务器不能正常运行，您可以通过下列命令启动它：</p>
<pre><code>sudo /etc/init.d/mysql restart
</code></pre>
<h1 id="增删改查数据库create-drop-alter-show">增删改查数据库(CREATE、DROP、ALTER、SHOW)</h1>
<h2 id="增加">增加：</h2>
<pre><code>create database 库名 default character utf8;
</code></pre>
<h2 id="删除">删除：</h2>
<pre><code>drop database 库名 ;
</code></pre>
<h2 id="修改">修改：</h2>
<pre><code>alter database 库名  default character gbk;
</code></pre>
<h2 id="查询">查询：</h2>
<pre><code>show databases 
</code></pre>
<h2 id="选择数据库">选择数据库：</h2>
<pre><code>use 库名 ;
</code></pre>
<h1 id="增删改表create-drop-alter-rename">增删改表(CREATE、DROP、ALTER、RENAME)</h1>
<h2 id="新建表">新建表</h2>
<pre><code>CREATE TABLE 表名 (
  id int(10) unsigned NOT NULL COMMENT 'Id',
  username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',
  password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',
  email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'
) COMMENT='用户表';
</code></pre>
<p><s>SELECT  INTO根据已有的表创建新表</s></p>
<pre><code>SELECT * INTO new_表名 FROM 表名
</code></pre>
<h2 id="删除-2">删除：</h2>
<pre><code>DROP TABLE user;
</code></pre>
<h2 id="修改表名称">修改表名称：</h2>
<pre><code>ALTER TABLE user RENAME  user_new;
</code></pre>
<h1 id="增删改查字段add-drop-column-modify-change-desc">增删改查字段（ADD、DROP COLUMN、MODIFY、CHANGE、DESC）</h1>
<h2 id="添加字段">添加字段：</h2>
<pre><code>ALTER TABLE user ADD age int(3);
</code></pre>
<h2 id="删除字段">删除字段:</h2>
<pre><code>ALTER TABLE user DROP COLUMN age;
</code></pre>
<h2 id="修改字段类型">修改字段类型：</h2>
<pre><code>ALTER TABLE user MODIFY 字段名 新的字段类型;
</code></pre>
<p>mysql 设置字段 not null 变成可以null</p>
<pre><code>ALTER TABLE 表名 MODIFY 字段名 VARCHAR(20) DEFAULT NULL
</code></pre>
<h2 id="修改字段名称-change">修改字段名称 ：CHANGE</h2>
<pre><code>ALTER TABLE user CHANGE 旧字段名 新字段名 字段类型;
</code></pre>
<h2 id="显示表字段信息">显示表字段信息：</h2>
<pre><code>DESC user;
</code></pre>
<h1 id="管理数据">管理数据:</h1>
<h3 id="添加主键-add-primary-key">添加主键 ADD PRIMARY KEY</h3>
<pre><code>ALTER TABLE user ADD PRIMARY KEY (id);
</code></pre>
<p><s>删除主键</s></p>
<pre><code>ALTER TABLE user DROP PRIMARY KEY;
</code></pre>
<p>查询表的大小：</p>
<pre><code>use information_schema;  
select data_length,index_length 
from tables 
where table_schema=库 and table_name = 表 ;
</code></pre>
<h2 id="添加数据">添加数据：</h2>
<p>插入完整的行</p>
<pre><code>INSERT INTO user VALUES (10, 'root', 'root', 'xxxx@163.com');
</code></pre>
<p>插入行的一部分</p>
<pre><code>INSERT INTO user(username, password, email) VALUES ('admin', 'admin', 'xxxx@163.com');
</code></pre>
<p><s>插入查询出来的数据</s></p>
<pre><code>INSERT INTO user(字段) SELECT 字段 FROM account;
</code></pre>
<h2 id="删除-3">删除：</h2>
<h3 id="delete-from">DELETE FROM</h3>
<p>1)可以<s>带条件删除</s>2）只能删除表的数据，<s>不能删除表的约束</s>3)删除的数据<s>可以回滚（事务）</s></p>
<pre><code>DELETE FROM user WHERE username='robot';
</code></pre>
<h3 id="truncate">truncate</h3>
<p>1）不能带条件删除 2）即可以删除表的数据，也可以删除表的约束 3）不能回滚</p>
<pre><code>TRUNCATE TABLE user;
</code></pre>
<h2 id="修改update-set">修改：UPDATE SET</h2>
<pre><code>UPDATE user
SET username='robot', password='robot'
WHERE username = 'root';
</code></pre>
<h2 id="查询-2">查询：</h2>
<p>所有字段：</p>
<pre><code>select * from 表;
</code></pre>
<p>指定字段：</p>
<pre><code>select 字段 from 表;
</code></pre>
<p>指定别名：</p>
<pre><code>select 字段1 as 别名 from 表;
</code></pre>
<p>合并列：</p>
<pre><code>select (字段1+字段2) as “和” from 表;
</code></pre>
<p>去重：</p>
<pre><code>select distinct 字段 from 表;
</code></pre>
<h1 id="特殊字符">特殊字符</h1>
<h2 id="逻辑-and-or-in-not-in">逻辑 ：and、 or、in、not  in</h2>
<p><code>select * from 表 where 条件1 and/or 条件2</code><br>
<code>IN (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</code></p>
<h2 id="比较-between-and">比较： &gt; 、 &lt;  、&gt;= 、 &lt;= 、 =、  !=、 &lt;&gt;、 between  and</h2>
<p><code>select * from 表 where 字段&gt;=条件;</code></p>
<h2 id="模糊-like-替换任意个字符-_替换一个字符">模糊： like  、%（替换任意个字符）、  _（替换一个字符）</h2>
<p><code>SELECT * FROM student WHERE NAME LIKE '李%';</code></p>
<h1 id="判断case-when-条件-then-真的操作-else-假的操作-end-if条件-真的操作-假的操作">判断：（case when 条件 then 真的操作 else 假的操作 end）、if(条件, 真的操作, 假的操作)</h1>
<pre><code>SELECT role,
case when building is not null 
THEN &quot;1&quot; else &quot;0&quot; end
as Wheater
FROM employees
GROUP BY role,Wheater;
</code></pre>
<h2 id="聚合函数">聚合函数：</h2>
<p><s>聚合函数要使用的话,有一个前提，那就是是必zhi须要有结果集</s><br>
<code>sum()、avg() 、 max() 、min() 、 count()</code></p>
<h4 id="count">count()</h4>
<p>COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。</p>
<p><code>SELECT SUM(servlet) AS 'servlet的总成绩' FROM student;</code><br>
<code>SELECT COUNT(*) FROM student;</code></p>
<p><code>concat</code>将A和B按顺序连接在一起的字符串<br>
<code>split(str, regex)</code>将string类型数据按regex提取，分隔后转换为array。<br>
<code>substr（str,0,len)</code>截取字符串从0位开始的长度为len个字符。<br>
<code>LOCATE()</code>查找某字符在长字符中的位置<br>
<code>LEFT()、RIGHT()</code>左边或者右边的字符<br>
<code>LOWER()、UPPER()</code>转换为小写或者大写<br>
<code>LTRIM()、RTIM()</code>去除左边或者右边的空格<br>
<code>LENGTH()</code>长度<br>
<code>SOUNDEX()</code>转换为语音值<br>
其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<pre><code>SELECT *
FROM mytable
WHERE SOUNDEX(col1) = SOUNDEX('apple')
</code></pre>
<p>常用的日期提取函数包括 <code>year()/month()/day()/hour()/minute()/second()</code><br>
<code>AddDate()</code>增加一个日期（天、周等）<br>
<code>AddTime()</code>增加一个时间（时、分等）<br>
<code>CurDate()</code>返回当前日期<br>
<code>CurTime()</code>返回当前时间<br>
<code>Date()</code>返回日期时间的日期部分<br>
<code>to_date(&quot;1970-01-01 00:00:00&quot;)</code>把时间的字符串形式转化为时间类型，再进行后续的计算；<br>
<code>datediff(enddate,stratdate)</code>计算两个时间的时间差（day)；<br>
<code>date_sub(stratdate,days)</code>返回开始日期startdate减少days天后的日期。<br>
<code>date_add(startdate,days)</code>返回开始日期startdate增加days天后的日期。<br>
<code>Date_Format()</code>返回一个格式化的日期或时间串<br>
<code>date(paidTime).date_format(paidTime，%Y-%m-d%)</code></p>
<p><code>SIN()</code>正弦<br>
<code>COS()</code>余弦<br>
<code>TAN()</code>正切<br>
<code>ABS()</code>绝对值<br>
<code>SQRT()</code>平方根<br>
<code>MOD()</code>余数<br>
<code>EXP()</code>指数<br>
<code>PI()</code>圆周率<br>
<code>RAND()</code>随机数<br>
<code>percentile()</code> 百分位函数<br>
<code>rank()</code>排序相同时会重复，总数不会变 ，意思是会出现1、1、3这样的排序结果；<br>
<code>dense_rank()</code> 排序相同时会重复，总数会减少，意思是会出现1、1、2这样的排序结果。<br>
<code>row_number()</code> 则在排序相同时不重复，会根据顺序排序。</p>
<h1 id="from-where-group含聚合-having-order-select">from &gt; where &gt; group（含聚合）&gt; having &gt; order &gt; select</h1>
<h2 id="分组查询group-by">分组查询：group by</h2>
<p><s>group by 后可加聚合函数，where 后不能加聚合函数</s>，<s>聚合函数要使用的话,有一个前提，那就是是必zhi须要有结果集</s></p>
<p>把统计函数和GROUP BY结合，那统计结果就是对分组内的数据统计了.</p>
<pre><code>SELECT building,count(*) 
FROM employees
WHERE building!='null'
GROUP BY building
;
</code></pre>
<h2 id="分组后筛选-having">分组后筛选： having</h2>
<p>查询总人数大于2的性别<br>
-- 1) 查询男女的人数<br>
-- 2）筛选出人数大于2的记录(having)<br>
--- 注意： 分组之前条件使用where关键字，分组之前条件使用having关键字<br>
<code>SELECT gender,COUNT(*) FROM student WHERE GROUP BY gender HAVING COUNT(*)&gt;2;</code></p>
<h2 id="distinct-唯一">DISTINCT 唯一</h2>
<p><code>SELECT DISTINCT Director FROM movies ASC;</code></p>
<h2 id="分页查询limit-offset">分页查询：limit offset</h2>
<p>起始行,查询行数起始行从0开始<br>
把结果集分页，每页3条记录。要获取第1页的记录<br>
<code>SELECT * FROM student LIMIT 3 OFFSET 0;</code></p>
<h2 id="排序-order-by">排序： order by</h2>
<p>asc: 正序（默认）desc：反序<br>
按照id顺序排序</p>
<pre><code>SELECT * 
FROM movies 
ORDER BY Director ASC,Year DESC 
LIMIT 10 OFFSET 0;
</code></pre>
<h1 id="连接查询多表查询join-on">连接查询（多表查询）JOIN  ON</h1>
<p>把两个表中具有相同 主键ID的数据连接起来</p>
<p><s>单纯的select * from a,b是笛卡尔乘积</s>。比如a表有5条数据，b表有3条数据，那么最后的结果有5*3=15条数据。但是如果对两个表进行关联:select * from a,b where a.id = b.id 意思就变了，此时就等价于：select * from a inner join b on a.id = b.id。即就是<s>内连接</s>。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-a79c08f891013866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<p>INNER JOIN 产生的结果是AB的交集。<br>
FULL [OUTER] JOIN 产生A和B的并集。<br>
LEFT [OUTER] JOIN 产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代。<br>
RIGHT [OUTER] JOIN 产生表B的完全集，而A表中匹配的则有值，没有匹配的则以null值取代CROSS JOIN 把表A和表B的数据进行一个N*M的组合，即笛卡尔积。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-93ca0a681c0411c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-315255693cbe1041.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="内连接查询inner-join只保留两张表中完全匹配的结果集">内连接查询INNER JOIN：只保留两张表中完全匹配的结果集</h2>
<pre><code>SELECT p.LastName, p.FirstName, o.OrderNo
FROM Persons p
INNER JOIN Orders o
ON p.Id_P=o.Id_P and 1=1　　
ORDER BY p.LastName
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-798cff79aafdee78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h2 id="左连接查询left-join返回左表所有的行即使在右表中没有匹配的记录">左连接查询LEFT JOIN：返回左表所有的行，即使在右表中没有匹配的记录。</h2>
<pre><code>SELECT p.LastName, p.FirstName, o.OrderNo
FROM Persons p
LEFT JOIN Orders o
ON p.Id_P=o.Id_P
ORDER BY p.LastName
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-7951f83402cc6026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h2 id="右连接right-join返回右表所有的行即使在左表中没有匹配的记录">右连接RIGHT JOIN：返回右表所有的行，即使在左表中没有匹配的记录。</h2>
<pre><code>SELECT p.LastName, p.FirstName, o.OrderNo
FROM Persons p
RIGHT JOIN Orders o
ON p.Id_P=o.Id_P
ORDER BY p.LastName
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/18339009-fd7eaa8cc12522ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h2 id="全连接查询full-join-返回左表和右表中所有的行">全连接查询：FULL JOIN ,返回左表和右表中所有的行。</h2>
<pre><code>SELECT p.LastName, p.FirstName, o.OrderNo
FROM Persons p
FULL JOIN Orders o
ON p.Id_P=o.Id_P
ORDER BY p.LastName
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://upload-images.jianshu.io/upload_images/18339009-e11d28c6df0d7187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="union">UNION</h1>
<p>将两个或更多查询的结果组合起来，并生成一个结果集<br>
所有查询的<s>列数和列顺序</s>必须相同。<br>
每个查询中涉及表的<s>列的数据类型</s>必须相同或兼容。<br>
通常<s>返回的列名取自第一个查询。</s><br>
<s>默认会去除相同行</s>，如果需要保留相同行，使用 UNION ALL。<br>
<s>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</s></p>
<h2 id="join-vs-union">JOIN vs UNION</h2>
<p>JOIN 中连接表的列可能不同，但在 UNION 中，<s>所有查询的列数和列顺序必须相同。</s><br>
<s>UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），</s></p>
<h2 id="应用场景">应用场景</h2>
<p><s>在一个查询中从不同的表返回结构数据。</s><br>
<s>对一个表执行多个查询，按一个查询返回数据。<br>
组合查询</s></p>
<pre><code>SELECT cust_name, cust_contact, cust_email
FROM customers
WHERE cust_state IN ('IL', 'IN', 'MI')
UNION
SELECT cust_name, cust_contact, cust_email
FROM customers
WHERE cust_name = 'Fun4All';
</code></pre>
<h1 id="远程连接">远程连接</h1>
<h2 id="查看当前的用户">查看当前的用户</h2>
<p><code>USE mysql;</code><br>
<code>SELECT * FROM user;</code></p>
<h2 id="修改密码">修改密码</h2>
<p>@前用户名@后地址（ % 代表可以任意ip访问）<br>
<code>LTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED BY &quot;root&quot;;</code></p>
<h2 id="创建新用户">创建新用户</h2>
<p><code>CREATE USER 'new_user'@'%' IDENTIFIED BY 'passwd';</code></p>
<h2 id="给用户赋权限">给用户赋权限</h2>
<p>这里我赋的是全部的权限，<em>.</em> 表示数据库库的所有库和表，对应权限存储在mysql.user表中<br>
<code>GRANT ALL ON *.* TO 'new_user'@'%';</code></p>
<p><code>GRANT SELECT, UPDATE ON day16.employee TO 'eric'@'localhost' IDENTIFIED BY '123456';</code></p>
<h2 id="刷新权限">刷新权限</h2>
<p><code>flush privileges;</code></p>
<h2 id="取消远程控制">取消远程控制</h2>
<p><code>update user set host='localhost' where user='用户名';</code></p>
<h2 id="删除用户">删除用户</h2>
<p><code>delete from user where user=&quot;用户名&quot; and host='host权限（localhost/%）';</code></p>
<blockquote>
<p>--开放3306端口--<br>
1.控制面板—系统和安全—windows防火墙—攻击设置—入栈规则<br>
2.新建规则—选择端口<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e649fed7e43e6b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
3.指定开放的端口<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-a40b2644f02b64a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
4.允许连接，一直点下一步即可<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-4610a319e4a4f648.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
</blockquote>
<h1 id="pymysql模块">PyMySQL模块</h1>
<p>是默认开启MySQL的事务功能的，<br>
因此，进行 &quot;增&quot;、 &quot;删&quot;、&quot;改&quot;的时候，一定要使用db.commit()提交事务<br>
一定要使用try…except…语句，因为万一没插入成功，其余代码都无法执行。当语句执行不成功，<br>
我们就db.rollback()回滚到操作之前的状态；当语句执行成功，我们就db.commit()提交事务。</p>
<pre><code>import pymysql 
# 使用pymysql连接上mysql数据库服务器，创建了一个数据库对象；
db=pymysql.connect(host='localhost',user='root', password='',
                   port=3306, db='test', charset='utf8')
# 开启mysql的游标功能，创建一个游标对象；
cursor = db.cursor()

# 建表语句；
sql = &quot;&quot;&quot;create table person(
        id int auto_increment primary key not null,
        name varchar(10) not null,
        age int not null) charset=utf8&quot;&quot;&quot;
# 执行sql语句；
cursor.execute(sql)

# 一次性插入一条数据；
name = &quot;猪八戒&quot;
age = 8000
sql = &quot;&quot;&quot;
insert into person(name,age) values (&quot;猪八戒&quot;,8000)
&quot;&quot;&quot;
try:
    cursor.execute(sql)
    db.commit()
    print(&quot;插入成功&quot;)
except:
    print(&quot;插入失败&quot;)
    db.rollback()

# 要执行的SQL语句；
sql = &quot;select * from person&quot;
# execute(query, args)：执行单条sql语句，接收的参数为sql语句本身和使用的参数列表，返回值为受影响的行数；
# executemany(query, args)：执行单条sql语句，但是重复执行参数列表里的参数，返回值为受影响的行数；
cursor.execute(sql)
# fetchone()：返回一条结果行；
# fetchmany(size)：接收size条返回结果行。如果size的值大于返回的结果行的数量，则会返回cursor.arraysize条数据；
# fetchall()：接收全部的返回结果行；
data = cursor.fetchone()
print(data)
db.close()
</code></pre>
<h1 id="使用pandas">使用pandas</h1>
<p>中的read_sql()方法，将提取到的数据直接转化为DataFrame，进行操作</p>
<pre><code>df1 = pd.read_sql(&quot;select * from student where ssex='男'&quot;,db)
display(df1)
df2 = pd.read_sql(&quot;select * from student where ssex='女'&quot;,db)
display(df2)
</code></pre>
<h1 id="数据约束表约束">数据约束（表约束）</h1>
<pre><code>默认值： default 默认值
非空：   not null
 唯一： unique
主键： primary key （非空+唯一）
 自增长： auto_increment
</code></pre>
<p>######外键： foreign key   约束两种表</p>
<pre><code>CONSTRAINT emlyee_dept_fk 
FOREIGN KEY(deptId) 
REFERENCES dept(id)  
ON UPDATE CASCADE ON DELETE CASCADE  -- ON CASCADE
</code></pre>
<pre><code>ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
</code></pre>
<p>其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。</p>
<pre><code>ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
</code></pre>
<p>注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。</p>
<p>######UPDATE ：级联修改<br>
外键名称                  外键               参考表(参考字段)<br>
注意：<br>
1）被约束的表称为副表，约束别人的表称为主表，外键设置在副表上的！！！<br>
2）主表的参考字段通用为主键！<br>
3）添加数据： 先添加主表，再添加副表<br>
4）修改数据： 先修改副表，再修改主表<br>
5）删除数据： 先删除副表，再删除主表<br>
当有了外键约束的时候，必须先修改或删除副表中的所有关联数据，才能修改或删除主表！但是，我们希望直接修改或删除主表数据，从而影响副表数据。可以使用级联操作实现！！！</p>
<p>存储过程<br>
-- 创建存储过程</p>
<pre><code>DELIMITER $       -- 声明存储过程的结束符
CREATE PROCEDURE pro_test()           --存储过程名称(参数列表)
BEGIN             -- 开始
    -- 可以写多个sql语句;          -- sql语句+流程控制
    SELECT * FROM employee;
END $            -- 结束 结束符
</code></pre>
<p>-- 执行存储过程</p>
<pre><code>CALL pro_test();          -- CALL 存储过程名称(参数);
</code></pre>
<p>-- 删除存储过程</p>
<pre><code>DROP PROCEDURE pro_testOut;
</code></pre>
<ul>
<li>全局变量（内置变量）：mysql数据库内置的变量 （所有连接都起作用）<br>
-- 查看所有全局变量： show variables<br>
-- 查看某个全局变量： select @@变量名<br>
-- 修改全局变量： set 变量名=新值<br>
--  会话变量： 只存在于当前客户端与数据库服务器端的一次连接当中。如果连接断开，那么会话变量全部丢失！<br>
-- 定义会话变量: set @变量=值<br>
-- 查看会话变量： select @变量</li>
</ul>
<p>-- 局部变量： 在存储过程中使用的变量就叫局部变量。只要存储过程执行完毕，局部变量就丢失！！</p>
<ul>
<li>3.3 带有输入输出参数的存储过程</li>
</ul>
<pre><code>  DELIMITER $
  CREATE PROCEDURE pro_testInOut(INOUT n INT)  -- INOUT： 输入输出参数
  BEGIN
   SELECT n;   过程中的变量都是局部变量
   SET n =500;
  END $
  SET @n=10;
  CALL pro_testInOut(@n);
  SELECT @n;
IF num=1    THEN  SET str='星期一';
ELSEIF num=2 THEN  SET str='星期二';
ELSE               SET str='输入错误';
END IF;
</code></pre>
<p>-- 定义一个局部变量</p>
<pre><code>    DECLARE i INT DEFAULT 1;
    DECLARE vsum INT DEFAULT 0;
    WHILE i&lt;=num DO
          SET vsum = vsum+i;
          SET i=i+1;
    END WHILE;
    SET result=vsum;
</code></pre>
<p>-- 3.6 使用查询的结果赋值给变量（INTO）</p>
<pre><code>DELIMITER $
CREATE PROCEDURE pro_findById2(IN eid INT,OUT vname VARCHAR(20) )
BEGIN
    SELECT empName INTO vname FROM employee WHERE id=eid;
END $
CALL pro_findById2(1,@NAME);
SELECT @NAME;
</code></pre>
<p>-- 创建触发器(添加)</p>
<pre><code>CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW    -- 当往员工表插入一条记录时
     INSERT INTO test_log(content) VALUES('员工表插入了一条记录');
</code></pre>
<p>-- 创建触发器(修改)</p>
<pre><code>CREATE TRIGGER tri_empUpd AFTER UPDATE ON employee FOR EACH ROW    -- 当往员工表修改一条记录时
     INSERT INTO test_log(content) VALUES('员工表修改了一条记录');
</code></pre>
<p>-- 创建触发器(删除)</p>
<pre><code>CREATE TRIGGER tri_empDel AFTER DELETE ON employee FOR EACH ROW    -- 当往员工表删除一条记录时
     INSERT INTO test_log(content) VALUES('员工表删除了一条记录');
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安装nvidia显卡驱动]]></title>
        <id>https://dingtom.github.io/post/an-zhuang-nvidia-xian-qia-qu-dong/</id>
        <link href="https://dingtom.github.io/post/an-zhuang-nvidia-xian-qia-qu-dong/">
        </link>
        <updated>2020-11-25T07:17:28.000Z</updated>
        <content type="html"><![CDATA[<p>查看显卡型号<br>
<code>lsb_release -a</code></p>
<p>更新PCI ID数据库<br>
<code>update-pciids</code><br>
<code>lspci | grep -i nvidia</code></p>
<p>驱动安装<br>
<code>wget https://us.download.nvidia.com/XFree86/Linux-x86_64/455.23.04/NVIDIA-Linux-x86_64-455.23.04.run</code><br>
查看TMPDIR目录是否报错<br>
<code>echo $TMPDIR</code></p>
<p>安装驱动</p>
<p><code>sudo bash NVIDIA-Linux-x86_64-455.23.04.run</code></p>
<p>禁用nouveau<br>
<code>lsmod | grep nouveau</code></p>
<p><code>vim /etc/modprobe.d/blacklist.conf</code>添加<br>
<code>blacklist nouveau</code></p>
<p><code>sudo update-initramfs -u</code></p>
<p><code>sudo reboot now</code></p>
<p>查看显卡信息<br>
<code>nvidia-smi</code></p>
<h1 id="安装cuda">安装cuda</h1>
<p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1804&amp;target_type=deblocal">download</a></p>
<h6 id="查看cuda版本">查看cuda版本</h6>
<p><code>nvcc -V</code><br>
不显示</p>
<blockquote>
<p>首先，查看cuda的bin目录下是否有nvcc：<br>
<code>ls /usr/local/cuda/bin</code><br>
如果存在，直接将cuda路径加入系统路径即可：<br>
<code>vim ~/.bashrc</code>进入配置文件；<br>
添加以下两行：<br>
<code>export PATH=/usr/local/cuda/bin:$PATH</code><br>
<code>export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH</code><br>
然后更新配置文件：<br>
<code>source ~/.bashrc</code></p>
</blockquote>
<h1 id="安装cudnn">安装cudnn</h1>
<p><a href="https://developer.nvidia.com/rdp/cudnn-archive">download</a><br>
<code>tar -xvf cudnn-8.0-linux-x64-v5.1.tgz</code><br>
安装cuDNN比较简单，解压后把相应的文件拷贝到对应的CUDA目录下即可</p>
<p><code>sudo cp cuda/include/cudnn.h /usr/local/cuda/include/</code><br>
<code>sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/</code><br>
<code>sudo chmod a+r /usr/local/cuda/include/cudnn.h</code><br>
<code>sudo chmod a+r /usr/local/cuda/lib64/libcudnn*</code></p>
<h1 id="卸载显卡驱动重新安装">卸载显卡驱动重新安装</h1>
<p>命令行界面<br>
Ctrl+Alt+F1</p>
<p><code>sudo apt-get --purge remove nvidia*</code></p>
<p><code>sudo apt autoremove</code></p>
<p>To remove CUDA Toolkit:<br>
<code>sudo apt-get --purge remove &quot;*cublas*&quot; &quot;cuda*&quot;</code><br>
To remove NVIDIA Drivers:<br>
<code>sudo apt-get --purge remove &quot;*nvidia*&quot;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu安装Samba分享文件夹]]></title>
        <id>https://dingtom.github.io/post/ubuntu-an-zhuang-samba-fen-xiang-wen-jian-jia/</id>
        <link href="https://dingtom.github.io/post/ubuntu-an-zhuang-samba-fen-xiang-wen-jian-jia/">
        </link>
        <updated>2020-11-25T07:17:06.000Z</updated>
        <content type="html"><![CDATA[<p>安装samba服务器。<br>
<code>sudo apt-get install samba samba-common</code><br>
创建一个用于分享的samba目录。<br>
<code>sudo mkdir /home/zut_csi/tomding/share</code><br>
给创建的这个目录设置权限<br>
<code>sudo chmod 777 /home/zut_csi/tomding/share</code><br>
添加用户(下面的zut_csi是我的用户名，之后会需要设置samba的密码)。<br>
<code>sudo smbpasswd -a zut_csi</code><br>
配置samba的配置文件。<br>
<code>sudo vim /etc/samba/smb.conf</code></p>
<p>在配置文件smb.conf的最后添加下面的内容：</p>
<pre><code>[share]
comment = share folder
browseable = yes
path = /home/zut_csi/tomding/share
create mask = 0700
directory mask = 0700
valid users = zut_csi
force user = zut_csi
force group = zut_csi
public = yes
browseable = yes
read only = no
available = yes
writable = yes
security = share
</code></pre>
<p>重启samba服务器。<br>
<code>sudo service smbd restart</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell]]></title>
        <id>https://dingtom.github.io/post/shell/</id>
        <link href="https://dingtom.github.io/post/shell/">
        </link>
        <updated>2020-11-25T07:16:54.000Z</updated>
        <content type="html"><![CDATA[<p><code>#!/bin/bash</code> <br>
######! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 <code>chmod +x ./test.sh</code> #使脚本具有执行权限 <code>./test.sh</code> #执行脚本 注意，一定要写成 ./test.sh，而不是 <a href="http://test.sh/">test.sh</a>，运行其它二进制的程序也一样，直接写 <a href="http://test.sh/">test.sh</a>，linux 系统会去 PATH 里寻找有没有叫 <a href="http://test.sh/">test.sh</a> 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <a href="http://test.sh/">test.sh</a> 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
<p><code>/bin/sh test.sh</code> # 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<p>######变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p>#####除了显式地直接赋值，还可以用语句给变量赋值，如： <code>for file in</code>ls /etc`` 或 <code>for file in $(ls /etc)</code> 以上语句将 /etc 下目录的文件名循环出来。</p>
<p>#####使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<pre><code>your_name=&quot;qinjx&quot;
echo $your_name
echo ${your_name}

</code></pre>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<pre><code>for skill in Ada Coffe Action Java; do  echo &quot;I am good at ${skill}Script&quot; ;done

</code></pre>
<p>如果不给skill变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<p>#####使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 readonly myUrl #修改的话执行时会报错</p>
<p>#####使用 unset 命令可以删除变量。unset 命令不能删除只读变量。 unset variable_name 变量被删除后不能再次使用。</p>
<p>#####单引号字符串的限制：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p>
<p>#####双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符</p>
<pre><code>your_name='runoob'
str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;
echo -e $str

</code></pre>
<p>#####拼接字符串</p>
<pre><code>your_name=&quot;runoob&quot;
# 使用双引号拼接
greeting=&quot;hello, &quot;$your_name&quot; !&quot;
greeting_1=&quot;hello, ${your_name} !&quot;
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
输出结果为：

hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !

</code></pre>
<p>#获取字符串长度 string=&quot;abcd&quot; echo ${#string} #输出 4</p>
<p>#提取子字符串 以下实例从字符串第 2 个字符开始截取 4 个字符： string=&quot;runoob is a great site&quot; echo ${string:1:4} # 输出 unoo</p>
<p>#查找子字符串 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： string=&quot;runoob is a great site&quot; <code>echo</code>expr index &quot;$string&quot; io`` # 输出 4</p>
<p>#####定义数组 在 Shell 中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开。 例如： array_name=(value0 value1 value2 value3) 还可以单独定义数组的各个分量： array_name[0]=value0 array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。</p>
<p>#####读取数组元素值的一般格式是：</p>
<pre><code>valuen=${array_name[n]}
使用 @ 符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}

</code></pre>
<p>#####获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<pre><code>length=${#array_name[@]}
或者
length=${#array_name[*]}

</code></pre>
<p>#####遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？ 每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
<p>#####多行注释还可以使用以下格式：</p>
<pre><code>:&lt;&lt;EOF
注释内容...
注释内容...
注释内容...
EOF

</code></pre>
<p>#####Shell 传递参数</p>
<pre><code>echo &quot;Shell 传递参数实例！&quot;
echo &quot;执行的文件名：$0&quot;;！！！！！！！！！！！！！！！！！！！！！！
echo &quot;第一个参数为：$1&quot;;
echo &quot;第二个参数为：$2&quot;;
echo &quot;第三个参数为：$3&quot;;
为脚本设置可执行权限，并执行脚本，输出结果如下所示：
chmod +x test.sh 
./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3

</code></pre>
<pre><code>$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。

</code></pre>
<p>#####另外，还有几个特殊字符用来处理</p>
<pre><code>$# 传递到脚本的参数个数 

$*  以一个单字符串显示所有向脚本传递的参数。如&quot;$*&quot;用「&quot;」
括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。

$$  脚本运行的当前进程ID号 

$!  后台运行的最后一个进程的ID号 

$@  与$*相同，但是使用时加引号，并在引号中返回每个参数。如&quot;$@&quot;用「&quot;」括起来的情况
以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数
 $* 与 $@ 区别：
相同点：都是引用所有参数。
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等
价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。

$- 显示Shell使用的当前选项，与[set命令]
(https://www.runoob.com/linux/linux-comm-set.html)功能相同。 

$?  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 

</code></pre>
<p>#Shell 基本运算符 #####算术运算符</p>
<pre><code>条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成
 [ $a == $b ]。表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，
这与我们熟悉的大多数编程语言不一样。完整的表达式要被 ` ` 包含，注意这个字符不是常用
的单引号，在 Esc 键下边。

</code></pre>
<pre><code>加法	`expr $a + $b` 结果为 30。
减法	`expr $a - $b` 结果为 -10。
乘法	`expr $a \* $b` 结果为  200。!   !  !   !   !
除法	`expr $b / $a` 结果为 2。
取余	`expr $b % $a` 结果为 0。
赋值	a=$b 将把变量 b 的值赋给 a。
相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。
不相等。用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。

</code></pre>
<p>#####关系运算符,关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<pre><code>-eq   检测两个数是否相等，相等返回 true。                 [ $a -eq $b ] 

-ne	检测两个数是否不相等，不相等返回 true。	            [ $a -ne $b ] 

-gt	检测左边的数是否大于右边的，如果是，则返回 true。   	[ $a -gt $b ] 

-lt	检测左边的数是否小于右边的，如果是，则返回 true。   	[ $a -lt $b ] 

-ge	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 

-le	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 

</code></pre>
<p>#####布尔运算符</p>
<pre><code>!	非运算，表达式为 true 则返回 false，否则返回 true。   	[ ! false ] 
-o	或运算，有一个表达式为 true 则返回 true。	                        [ $a -lt 20 -o $b -gt 100 ] 
-a	与运算，两个表达式都为 true 才返回 true。	                        [ $a -lt 20 -a $b -gt 100 ] 

</code></pre>
<p>#####逻辑运算符，表达式外有两个大括号! ! ! ! ! ! ! ! ! ! ! !</p>
<pre><code>&amp;&amp;	逻辑的 AND	[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]     !　！　！！　！！
||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]]   

</code></pre>
<p>##字符串运算符</p>
<pre><code>=	检测两个字符串是否相等，相等返回 true。	        [ $a = $b ] 
!=	检测两个字符串是否相等，不相等返回 true。	     [ $a != $b ] 
-z	检测字符串长度是否为0，为0返回 true。	        [ -z $a ] 
-n	检测字符串长度是否为0，不为0返回 true。	         [ -n &quot;$a&quot; ] 
$	检测字符串是否为空，不为空返回 true。	         [ $a ]   !!!!!!!!!!!

</code></pre>
<p>##文件测试运算符</p>
<pre><code>-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 
-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 
-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 
-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 
-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ]
-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 
-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 
-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 
-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 
-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 
-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 
-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 
-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 
-S: 判断某文件是否 socket。
-L: 检测文件是否存在并且是一个符号链接。

</code></pre>
<p>#echo命令 #####显示变量 read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<pre><code>read name 
echo &quot;$name It is a test&quot;
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出

</code></pre>
<p>#####显示换行 echo -e &quot;OK! \n&quot; # -e 开启转义 echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行 echo -n &quot;haod&quot; #输出后不换行 #####显示结果定向至文件 echo &quot;It is a test&quot; &gt; myfile</p>
<p>#####原样输出字符串，不进行转义或取变量(用单引号) <code>echo '$name\&quot;'</code></p>
<p>##显示命令执行结果 echo <code>date</code> #显示时间</p>
<p>#printf 命令 接下来,我来用一个脚本来体现printf的强大功能：</p>
<pre><code>#!/bin/bash
printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 
printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 
执行脚本，输出结果如下所示：

姓名     性别   体重kg
郭靖     男      66.12
杨过     男      48.65
郭芙     女      47.99

</code></pre>
<p>%s %c %d %f都是格式替代符</p>
<p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
<p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

# format-string为双引号
printf &quot;%d %s\n&quot; 1 &quot;abc&quot;

# 单引号与双引号效果一样 
printf '%d %s\n' 1 &quot;abc&quot; 

# 没有引号也可以输出
printf %s abcdef

# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
printf %s abc def

printf &quot;%s\n&quot; abc def

printf &quot;%s %s %s\n&quot; a b c d e f g h i j

# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
printf &quot;%s and %d \n&quot; 
执行脚本，输出结果如下所示：

1 abc
1 abc
abcdefabcdefabc
def
a b c
d e f
g h i
j  
 and 0

</code></pre>
<p>#####流程控制 <code>if [ $int == $anwser ]; then echo &quot;right&quot;;else echo &quot;wrong&quot;;fi</code></p>
<p><code>for var in item; do command; done</code> item是数组不用写括号</p>
<pre><code>echo '按下 &lt;CTRL-D&gt; 退出'
echo -n '输入你最喜欢的名字: '
while read NAME
do
    echo &quot;是的！$NAME 是一个好名字&quot;
done

</code></pre>
<p>#####while后的条件需要加括号 read 读取键盘输入 <CTRL-D> 退出</p>
<pre><code>#!/bin/bash
int=1
while([ $int -lt 5 ])   ! ! ! !  ! ! ! ! ! !
do
    echo $int
    let int++
done

</code></pre>
<p>let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。 let int++ #case</p>
<pre><code>echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac

</code></pre>
<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<pre><code>funWithReturn(){
    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;
    echo &quot;输入第一个数字: &quot;
    read aNum
    echo &quot;输入第二个数字: &quot;
    read anotherNum
    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;
    return $(($aNum+$anotherNum))
}
funWithReturn
echo &quot;输入的两个数字之和为 $? !&quot;

</code></pre>
<p>#####return返回的值需要两个括号 函数返回值在调用该函数后通过 $? 来获得。 #####输入/输出重定向 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
<pre><code>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：

$ wc -l users
       2 users
也可以将输入重定向到 users 文件：

$  wc -l &lt; users
       2 
注意：上面两个例子的结果不同：第一个例子，会输出文件名；
第二个不会，因为它仅仅知道从标准输入读取内容

</code></pre>
<p>#####重定向深入讲解 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<p>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>如果希望 stderr 重定向到 file，可以这样写：</p>
<p>command &lt; file1 &gt;file2 command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 #Here Document 它的基本的形式如下：</p>
<p>command &lt;&lt; delimiter document delimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<p>注意：</p>
<p>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。</p>
<pre><code>wc -l &lt;&lt; EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行

</code></pre>
<p>#####/dev/null 文件 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-ae38c3e76a5bcb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux命令]]></title>
        <id>https://dingtom.github.io/post/linux-ming-ling/</id>
        <link href="https://dingtom.github.io/post/linux-ming-ling/">
        </link>
        <updated>2020-11-25T05:55:41.000Z</updated>
        <content type="html"><![CDATA[<p>Ctrl+d	键盘输入结束或退出终端<br>
Ctrl+s	暂停当前程序，暂停后按下任意键恢复运行<br>
Ctrl+z	将当前程序放到后台运行，恢复到前台为命令fg<br>
Ctrl+a	将光标移至输入行头，相当于Home键<br>
Ctrl+e	将光标移至输入行末，相当于End键<br>
Ctrl+k	删除从光标所在位置到行末<br>
Alt+Backspace	向前删除一个<strong>单词</strong><br>
命令 --help  查看一些它的某个命令具体参数的作用<br>
man 命令   显示系统手册页中的内容</p>
<p>一行中运行多个命令。<br>
; Command 1 ; Command 2 首先运行Command1，然后运行Command2<br>
&amp;&amp; Command 1 &amp;&amp; Command 2 当Command1运行成功并结束，然后运行Command2<br>
|| Command 1 || Command 2 当Command1运行失败时才运行Command2</p>
<h1 id="文件">文件</h1>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-be4aa0903719bf65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<blockquote>
<p>bin (binaries)存放二进制可执行文件<br>
sbin (super user binaries)存放二进制可执行文件，只有root才能访问<br>
etc (etcetera)存放系统配置文件<br>
usr (unix shared resources)用于存放共享的系统资源<br>
home 存放用户文件的根目录<br>
root 超级用户目录<br>
dev (devices)用于存放设备文件<br>
lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块<br>
mnt (mount)系统管理员安装临时文件系统的安装点<br>
boot 存放用于系统引导时使用的各种文件<br>
tmp (temporary)用于存放各种临时文件<br>
var (variable)用于存放运行时需要改变数据的文件</p>
</blockquote>
<h1 id="文件增删改查">文件增删改查</h1>
<h4 id="mkdir">mkdir</h4>
<blockquote>
<p>创建目录和父目录a,b,c,d<br>
<code>mkdir -p a/b/c/d</code><br>
-p 建立多级目录<br>
-m 在建立目录的时候给目录赋于权限值</p>
</blockquote>
<h4 id="rmdir">rmdir</h4>
<blockquote>
<p>删除空目录<br>
-p 删除多级空目录</p>
</blockquote>
<h4 id="cp">cp</h4>
<blockquote>
<p>拷贝文件夹a到/tmp目录<br>
<code>cp -rvf a/ /tmp/</code><br>
-R 复制整个目录里的内容<br>
-p 复制完后保持目录的权限值<br>
-v 在复制文件的时候显示进度<br>
-f 在复制的时候如果碰到目的文件名有重复就将原先的删除</p>
</blockquote>
<h4 id="mv">mv</h4>
<blockquote>
<p>重命名 <code>mv a.txt b.txt</code><br>
移动文件a到/tmp目录，并重命名为b<br>
<code>mv -vf a /tmp/b</code><br>
-i 如果目的地有相同文件名时会出现提示<br>
-v 在搬移文件时显示进度，在移动多文件时非常有用<br>
-u 当移动时只有源文件比目的文件新的时候才会移动<br>
-f 强制覆盖已有的文件</p>
</blockquote>
<h4 id="touch">touch</h4>
<blockquote>
<p>创建文件<br>
<code>touch asd.txt</code><br>
创建多个文件<br>
<code>touch love_{1..10}_shiyanlou.txt</code></p>
</blockquote>
<h4 id="rm">rm</h4>
<blockquote>
<p>删除机器上的所有文件<br>
rm -rvf /<br>
-i 在删除文件之前需要手工确认<br>
-v 在删除文件的时候显示信息<br>
-r 删除目录<br>
-f 忽略提示</p>
</blockquote>
<h4 id="ls">ls</h4>
<blockquote>
<p>-a 这个选项能显示.开头的隐藏文件<br>
-l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>
-t 将文件依建立时间之先后次序列出<br>
-i 显示每个文件的inode号<br>
-m 所有项目以逗号分隔，并填满整行行宽<br>
-R 同时列出所有子目录层<br>
-h 将列出文件的大小以人性化格式输出<br>
--color=tty(2个-号)显示文件的时候以色彩提示<br>
-full-time显示文件的详细访问时间<br>
-lc查看文件状态修改时间</p>
</blockquote>
<h4 id="cat">cat</h4>
<blockquote>
<p>查看文本文件<br>
如果文件很大的话，cat命令的输出结果会疯狂在终端上输出，可以多次按ctrl+c终止。<br>
-b 显示文件内容的时候显示行数<br>
-n 显示文件内容包括空行<br>
-s 将多个空行合并成一个空行输出</p>
</blockquote>
<h4 id="tr">tr</h4>
<blockquote>
<p>删除、转换一段文本信息中的某些文字<br>
-d	删除匹配的字符，注意不是全词匹配也不是按字符顺序匹配<br>
-s	去除指定的在输入文本中连续并重复的字符<br>
删除 &quot;hello shiyanlou&quot; 中所有的'o','l','h'<br>
<code>echo 'hello shiyanlou' | tr -d 'olh'</code><br>
将&quot;hello&quot; 中的ll,去重为一个l<br>
<code>echo 'hello' | tr -s 'l'</code><br>
将输入文本，全部转换为大写或小写输出<br>
<code>echo 'input some text here' | tr '[:lower:]' '[:upper:]'</code><br>
上面的'[:lower:]' '[:upper:]'你也可以简单的写作'[a-z]' '[A-Z]',当然反过来将大写变小写也是可以的</p>
</blockquote>
<h4 id="jion">jion</h4>
<blockquote>
<p>将两个文件中包含相同内容的那一行合并在一起。<br>
-t	指定分隔符，默认为空格<br>
-i	忽略大小写的差异<br>
-1	指明第一个文件要用哪个字段来对比，默认对比第一个字段<br>
-2	指明第二个文件要用哪个字段来对比，默认对比第一个字段<br>
将/etc/passwd与/etc/group两个文件合并，指定以':'作为分隔符, 分别比对第4和第3个字段<br>
<code>sudo join -t':' -1 4 /etc/passwd -2 3 /etc/group</code></p>
</blockquote>
<h4 id="paste">paste</h4>
<blockquote>
<p>在不对比数据的情况下，简单地将多个文件合并一起，以Tab隔开。<br>
-d	指定合并的分隔符，默认为 Tab<br>
-s	不合并到一行，每个文件为一行</p>
</blockquote>
<h4 id="less">less</h4>
<p>针对比较大的文件，我们就可以使用less命令打开某个文件。</p>
<p>按n(N)向下(上)查找。</p>
<h4 id="more">more</h4>
<p>查看文本文件命令</p>
<p>用空格向下翻页，用b向上翻页</p>
<blockquote>
<p>+行数直接从给定的行数开始显示<br>
-s 将多个空行压缩成一个空行<br>
-p 清除屏幕后再显示</p>
</blockquote>
<h4 id="nano">nano</h4>
<p>文本编辑器<br>
命令格式：nano [选项] [行号] 文件名</p>
<h4 id="head">head</h4>
<p>查看文件头部</p>
<blockquote>
<p>-n &lt;行数&gt; 显示文件的最前指定的行<br>
-c &lt;字节数&gt; 显示文件前N个字节数里的内容<br>
-q 不输出文件头的内容<br>
-v 输出文件头的内容</p>
</blockquote>
<h4 id="tail">tail</h4>
<p>查看文件尾部</p>
<blockquote>
<p>-f 循环读取<br>
-c &lt;字节数&gt; 显示文件前N个字节数里的内容<br>
-q 不输出文件头的内容<br>
-n &lt;行数&gt; 指定所显示的行数<br>
-v 输出文件头的内容</p>
</blockquote>
<p><code>tail -f access.log</code></p>
<h4 id="ln">ln</h4>
<p>生成链接文件</p>
<p>命令格式：ln [选项] 源文件 链接文件</p>
<blockquote>
<p>-f 删除已存在的目的文件<br>
-i 如果碰到有重复名字的提示如何操作<br>
-v 显示操作信息<br>
-s 软链接选项</p>
</blockquote>
<h4 id="file">file</h4>
<p>查看文件的类型</p>
<h4 id="stat">stat</h4>
<p>显示文件或文件系统状态</p>
<p>命令格式：stat [选项] &lt;文件/目录&gt;</p>
<blockquote>
<p>-f:查看指定的文件系统</p>
</blockquote>
<p>stat可查看：<br>
文件名 2. 文件尺寸 3. I节点号 4. 创建时间/访问时间/状态(属 主、组、权限)修改时间 5.权限 6.链接文件个数 7. 属主及属组等</p>
<h4 id="whereis">whereis</h4>
<p>whereis 只能查找2进制程序，文档和源码。</p>
<h4 id="which">which</h4>
<p>查找是否安装某个命令</p>
<h4 id="find">find</h4>
<p>最常用的命令，命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。<br>
<code>sudo find /etc -name sources.list</code></p>
<p>find -size n [c]<br>
查找n值大小的文件,默认单位是块(1块=512字节)</p>
<blockquote>
<ol>
<li>查找大于1500字节的文件<br>
find ~ -size +1500c</li>
</ol>
</blockquote>
<ol>
<li>查找等于1500字节的文件<br>
find ~ -size 1500c</li>
<li>查找小于1500字节的文件<br>
find ~ -size -1500c</li>
<li>查找大于512k字节的文件<br>
find ~ -size +512k</li>
<li>查找等于1M字节的文件<br>
find ~ -size 1M</li>
<li>查找小于1G字节的文件<br>
find ~ -size -1G</li>
<li>查找大于10块的文件<br>
find ~ -size +10</li>
<li>查找等于10块的文件<br>
find ~ -size -10</li>
<li>查找大于10M小于20M的文件<br>
find ./ -size +10M -size -20M</li>
<li>查找小于10块的文件<br>
find ~ -size -10</li>
<li>查找文件/目录字节为0的文件(即空文件)<br>
find / -empty</li>
</ol>
<h4 id="grep">grep</h4>
<p>功能: 通过正则表达式查找文件中的关键字</p>
<blockquote>
<p>-i:忽略大小写<br>
-c:打印匹配的行数<br>
-C:打印出匹配的上下文(上N行,下N行)的多少行-l:列出匹配的文件名<br>
-L:列出不匹配的文件名<br>
-n：打印包含匹配项的行和行标<br>
-w:仅匹配指定的单词而非关键字<br>
-e:索引匹配字串<br>
-r:递归查询<br>
-v:不输出匹配的行<br>
-A &lt;行号&gt;:显示所找的匹配字段，并显示下面指定的行数的信息<br>
-B &lt;行号&gt;:显示所找的匹配字段，并显示上面指定的行数的信息</p>
</blockquote>
<p>查看nginx日志中的POST请求。<br>
<code>grep -rn --color POST access.log</code><br>
看某个异常前后相关的内容<br>
<code>grep -rn --color Exception -A10 -B2 error.log</code></p>
<h4 id="正则表达式表示方法">正则表达式表示方法:</h4>
<blockquote>
<p>\忽略正则表达式中特殊字符的原有含义<br>
^ 匹配正则表达式的开始行<br>
$ 匹配正则表达式的结束行<br>
&lt; 从匹配正则表达式的行开始<br>
到匹配正则表达式的行结束<br>
[ ] 单个字符；如[A] 即A符合要求<br>
[ n - m ] 范围 ；如[A-H]即包含A至H都符合要求<br>
. 所有的单个字符<br>
* 所有字符，长度可以为0</p>
</blockquote>
<h4 id="cut">cut</h4>
<p>打印每一行的某一字段</p>
<blockquote>
<p>-d “n”:定义分界符,即点位<br>
-f 取第几位的字符<br>
-c:仅显示行中指定范围的字符</p>
</blockquote>
<p>打印/etc/passwd文件中以:为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录：<br>
<code>cut /etc/passwd -d ':' -f 1,6</code><br>
前五个（包含第五个）<br>
<code>cut /etc/passwd -c -5</code><br>
前五个之后的（包含第五个）<br>
<code>cut /etc/passwd -c 5-</code></p>
<h4 id="sort">sort</h4>
<p>排序<br>
-r反转<br>
-t参数用于指定字段的分隔符<br>
-k 字段号用于指定对哪一个字段进行排序<br>
-n 按照数字排序,默认情况下是以字典序排序的<br>
<code>cat /etc/passwd | sort -t':' -k 3 -n</code></p>
<h4 id="wc">wc</h4>
<p>计数工具<br>
行数<br>
<code>wc -l /etc/passwd</code><br>
单词数<br>
<code>wc -w /etc/passwd</code><br>
字节数<br>
<code>wc -c /etc/passwd</code><br>
字符数<br>
<code>wc -m /etc/passwd</code><br>
最长行字节数，西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于 2 个字节的，具体数目是由字符编码决定的<br>
<code>wc -L /etc/passwd</code></p>
<h4 id="uniq">uniq</h4>
<p>-c:在数据行前出现的次数<br>
-d:只打印重复的行,重复的行只显示一次<br>
-f:忽略行首的几个字段<br>
-i:忽略大小写<br>
-s:忽略行首的几个字母<br>
-u:只打印唯一的行</p>
<p>用于过滤或者输出重复行。<br>
因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：</p>
<p><code>history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq</code><br>
使用频率前三的命令<br>
<code>history |cut -c 8-|sort|uniq -dc|sort -rn -k1 |head -3</code></p>
<h4 id="下载">下载</h4>
<p><code>wget url</code></p>
<p><code>sudo apt-get install axel</code></p>
<p><code>axel -n 10 -o /tmp/ [http://testdownload.net/test.tar.gz](http://testdownload.net/test.tar.gz)</code><br>
-n 指定线程数<br>
-o 指定另存为目录<br>
-s 指定每秒的最大比特数<br>
-q 静默模式</p>
<h1 id="系统">系统</h1>
<p><code>who am i</code><br>
查看用户<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-f5fab39403516fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<p>输出的第一列表示打开当前伪终端的用户的用户名，第二列的 pts/0 中 pts 表示伪终端，所谓伪是相对于 /dev/tty 设备而言的，还记得上一节讲终端时的那七个使用 [Ctrl]+[Alt]+[F1]～[F7] 进行切换的 /dev/tty 设备么，这是“真终端”，伪终端就是当你在图形用户界面使用 /dev/tty7 时每打开一个终端就会产生一个伪终端，pts/0 后面那个数字就表示打开的伪终端序号，第三列则表示当前伪终端的启动时间。</p>
<h4 id="用户">用户</h4>
<p>sudo passwd lilei  设置用户lilei的密码<br>
sudo adduser lilei 创建新用户lilei，默认为新用户在 /home 目录下创建一个工作目录<br>
su -l lilei   切换到lilei用户<br>
sudo deluser lilei --remove-home  删除用户</p>
<h4 id="groups">groups</h4>
<p>groups shiyanlou<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-190c8e54549c1881.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
其中冒号之前表示用户，后面表示该用户所属的用户组。这里可以看到 shiyanlou 用户属于 shiyanlou 用户组，每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组<br>
<code>cat /etc/group | grep -E &quot;shiyanlou&quot;</code><br>
查看自己属于哪些用户组<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-51df186681c8e87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
group_name:password:GID:user_list</p>
<p><code>sudo usermod -G sudo lilei</code><br>
将其它用户加入 sudo 用户组<br>
以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。</p>
<h2 id="文件权限操作">文件权限操作</h2>
<p><code>ls -l a.txt</code></p>
<p>drwxr-xr-x  2 root root 4.0K  3月  23  2017  a.txt</p>
<blockquote>
<p>第1位：文件类型（d 目录，- 普通文件，l 链接文件）<br>
r 可读权限，w可写权限，x可执行权限（也可以用二进制表示 111 110 100 --&gt; 764）<br>
第2-4位：所属用户权限，用u（user）表示<br>
第5-7位：所属组权限，用g（group）表示<br>
第8-10位：其他用户权限，用o（other）表示<br>
第2-10位：表示所有的权限，用a（all）表示</p>
</blockquote>
<p>2是纯数字 ，表示 文件链接个数<br>
第一个“root” 表示文件的所有者<br>
第二个“root” 表示为文件的所在群组<br>
“4.0K”，表示为文件长度（大小）<br>
“3月  23  2017”，表示文件最后更新（修改）时间<br>
“etc” 表示文件的名称</p>
<h4 id="chown">chown</h4>
<p>改变文件的所属用户和所属组。</p>
<blockquote>
<p>-R 修改指定目录及其子目录</p>
</blockquote>
<p>修改a目录的用户和组为 xjj<br>
<code>chown -R xjj:xjj a</code></p>
<h4 id="chmod">chmod</h4>
<p>改变文件的访问权限。</p>
<blockquote>
<p>u表示当前用户<br>
g表示同组用户<br>
o表示其他用户<br>
a表示所有用户<br>
r表示可读<br>
w表示可写<br>
x表示可执行<br>
用数字来表示权限（r=4，w=2，x=1，-=0）,7：表示可读可写可执行，4+2+1,6：表示可读可写，4+2<br>
-R 修改指定目录及其子目录</p>
</blockquote>
<p>给a.sh文件增加执行权限（这个太常用了)<br>
<code>chmod a+x a.sh</code><br>
g、o 还有 u 分别表示 group（用户组）、others（其他用户） 和 user（用户），+ 和 - 分别表示增加和去掉相应的权限。<br>
<code>chmod go-rw t.txt</code></p>
<p>####df(report file system disk space usage)<br>
显示文件系统磁盘空间的使用情况</p>
<blockquote>
<p>-h 以人类可读的方式显示，KD，Mb，GB等</p>
</blockquote>
<h4 id="du-estimate-file-space-usage">du  (estimate file space usage)</h4>
<p>显示指定的目录及其子目录已使用的磁盘空间的总和</p>
<blockquote>
<p>-s显示指定目录的总和<br>
-a  显示目录中所有文件的大小。<br>
-h以人类可读的方式显示，Kb，Mb，G8等<br>
-d参数指定查看目录的深度 # 只查看1级目录的信息<br>
-d 0 ~<br>
查看文件大小<br>
<code>du -h file</code></p>
</blockquote>
<h4 id="dd">dd</h4>
<p>转换和复制文件,也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。</p>
<p>dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file，输入文件）和of（output file，输出文件）改变。</p>
<p>bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如'K'，'M'，'G'等单位），<br>
count用于指定块数量。<br>
conv=ucase  将输出的英文字符转换为大写再写入文件</p>
<p>输出到test文件<br>
<code>dd of=test bs=10 count=1</code><br>
输出到标准输出<br>
<code>dd if=/dev/stdin of=/dev/stdout bs=10 count=1</code></p>
<h4 id="mount">mount</h4>
<p>-o 操作选项<br>
-t 文件系统类型<br>
-w|--rw|--ro权限</p>
<p>从/dev/zero设备创建一个容量为 256M 的空文件：<br>
<code>dd if=/dev/zero of=virtual.img bs=1M count=256</code><br>
格式化磁盘：<br>
<code>sudo mkfs.ext4 virtual.img</code><br>
挂载我们创建的虚拟磁盘镜像到/mnt目录：<br>
<code>mount -o loop -t ext4 virtual.img /mnt</code></p>
<p>卸载已挂载磁盘<br>
<code>sudo umount /mnt</code></p>
<h4 id="free">free</h4>
<p>显示当前内存和交换空间的使用情况</p>
<h4 id="date">date</h4>
<p>显示系统当前时间</p>
<h4 id="top">top</h4>
<p>显示当前系统中耗费资源最多的进程<br>
查看某个进程中的线程状态<br>
<code>top -H -p pid</code></p>
<h4 id="ps">ps</h4>
<p>较少单独使用，配参数根据需求，ps ef或者ps-aux</p>
<blockquote>
<p>-e 显示所有选程，环境变量<br>
-f 全格式显示<br>
-a 显示所有用户的所有进程（包括其它用户）<br>
-u 按用户名和启动时间的顺序来显示进程<br>
-x 显示无控制终端的进程</p>
</blockquote>
<h4 id="kill">kill</h4>
<blockquote>
<p>-9 kill -9 pid强制杀死一个进程</p>
</blockquote>
<h4 id="ifconfig">ifconfig</h4>
<p>网卡网络配置，常用于查看当前IP地址<br>
ifconfig etho 192.168.12.22 修改系统IP（重品后失效）</p>
<h4 id="ping">ping</h4>
<p>ping baidu.com 测试网络的连通</p>
<h4 id="hostname">hostname</h4>
<p>查看主机名</p>
<h4 id="关机">关机</h4>
<blockquote>
<p><code>sudo shutdown now</code><br>
<code>sudo reboot now</code><br>
<code>shutdown -c</code>取消关机   <br>
<code>shutdown -p</code>立即关机，无提示、延时<br>
<code>shutdown -s</code>关机<br>
<code>shutdown -r</code>重启<br>
<code>shutdown -f</code>强行关闭应用程序<br>
<code>shutdown -l</code>注销当前用户<br>
<code>shutdown -s -t</code> 设置关机倒计时<br>
<code>shutdown -h</code>休眠</p>
</blockquote>
<h4 id="export">export</h4>
<p>设定一些环境变量，env命令能看到当前系统中所有的环境变量。比如，下面设置的就是jdk的。<br>
<code>export PATH=$PATH:/home/xjj/jdk/bin</code><br>
<code>source</code>命令来让其立即生效<br>
set	显示当前 Shell 所有变量，包括<strong>其内建环境变量，用户自定义变量及导出的环境变量。</strong><br>
env	显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。<br>
export	显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</p>
<p>/etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。<br>
<code>unset</code><br>
命令删除一个环境变量</p>
<h1 id="压-解缩">压、解缩</h1>
<h4 id="gzip">gzip</h4>
<blockquote>
<p>压缩文件成者文件夹<br>
-d解压缩文件</p>
</blockquote>
<h4 id="zip">zip</h4>
<blockquote>
<p>将目录 /home/shiyanlou/Desktop 打包成一个文件<br>
<code>zip -r -9 -q -o -l shiyanlou.zip /home/shiyanlou/Desktop</code><br>
-r 参数表示递归打包包含子目录的全部内容，9 压缩级别最大1 最小,<br>
-q 参数表示为安静模式，即不向屏幕输出信息，<br>
-o，表示输出文件,<br>
-l 参数将 LF 转换为 CR+LF 来达到win/linux兼容。</p>
</blockquote>
<h4 id="unzip">unzip</h4>
<blockquote>
<p>将文件解压到指定目录：<br>
<code>unzip -q shiyanlou.zip -d ziptest</code><br>
-q 使用安静模式<br>
-d指定路径<br>
-l 不解压只想查看压缩包的内容<br>
-O（英文字母，大写 o）参数指定编码类型：(win默认会采用 GBK , Linux 默认 UTF-8 )<br>
unzip -O GBK 中文压缩文件.zip</p>
</blockquote>
<h4 id="tar">tar</h4>
<blockquote>
<p><code>tar -xzf shiyanlou.tar.gz -C tardir</code><br>
压缩文件格式<code>-z/*.tar.gz</code>，<code>-J/*.tar.xz</code>	，<code>-j/*tar.bz2</code><br>
-P 保留绝对路径符<br>
-v压缩的过程中显示文件<br>
-c 表示创建一个 tar 包文件<br>
-f 用于指定创建的文件名，件名必须紧跟在 -f 参数之后<br>
-p在其他主机还原时希望保留文件的属性<br>
-h 备份链接指向的源文件而不是链接本身<br>
-x解包一个文件<br>
-C 指定保存路径<br>
-t只查看不解包文件</p>
</blockquote>
<h1 id="vim">VIM</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-de0ac15d12403184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
修改文本<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b6f40fe5095da55e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
定位命令<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-40f8d2a91c245485?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" loading="lazy"><br>
替换和取消命令<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-3192c0b29770869f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
删除命令<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-52358b7bd810c2b8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
常用快捷键<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-c8dc68e3552b4958?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h4 id="alias">alias</h4>
<p><code>alias a='find . -size +10M -type f -print0 | xargs -0 ls -Ssh | sort -z'</code></p>
<h4 id="关闭防火墙">关闭防火墙</h4>
<p>systemctl stop firewalld.service</p>
<h4 id="禁止防火墙开机启动">禁止防火墙开机启动</h4>
<p>systemctl disable firewalld.service</p>
<h4 id="关闭selinux">关闭SELinux</h4>
<p>nano -w /etc/selinux/config<br>
将SELINUX=enforcing改为SELINUX=disabled保存并退出:^x-&gt;y-&gt;回车</p>
<h1 id="计划任务">计划任务</h1>
<p>查看添加了哪些任务<code>crontab -l</code><br>
添加一个计划任务<code>crontab -e</code><br>
删除任务<code>crontab -r</code><br>
<code>分 小时 天 月 星期 user-name command to be executed</code></p>
<p>启动 rsyslog，以便我们可以通过日志中的信息来了解我们的任务是否真正的被执行了<br>
<code>sudo apt-get install -y rsyslog</code><br>
<code>sudo service rsyslog start</code>( Ubuntu 会默认自行启动不需要手动启动)<br>
<code>sudo cron －f &amp;</code>(实验环境中 crontab 也是不被默认启动的，同时不能在后台由 upstart 来管理，所以需要我们来启动它)</p>
<p>每分钟我们会在/home/shiyanlou 目录下创建一个以当前的年月日时分秒为名字的空白文件<br>
<code>*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)</code></p>
<blockquote>
<p>“ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p>
</blockquote>
<p>查看到执行任务命令之后在日志中的信息反馈<br>
<code>sudo tail -f /var/log/syslog</code></p>
<h4 id="有选择的执行命令">有选择的执行命令</h4>
<p><code>which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;</code><br>
<code>&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回 0 则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果</code><br>
<code>||在这里就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为 ≠0($?≠0)时则执行它后面的命令</code><br>
echo $?</p>
]]></content>
    </entry>
</feed>