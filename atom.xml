<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dingtom.github.io</id>
    <title>Tomding&apos;s Blog</title>
    <updated>2021-04-25T02:58:43.699Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dingtom.github.io"/>
    <link rel="self" href="https://dingtom.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://dingtom.github.io/images/avatar.png</logo>
    <icon>https://dingtom.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Tomding&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[K-近邻算法（K-NN）]]></title>
        <id>https://dingtom.github.io/post/k-jin-lin-suan-fa-k-nn/</id>
        <link href="https://dingtom.github.io/post/k-jin-lin-suan-fa-k-nn/">
        </link>
        <updated>2021-04-18T13:46:39.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="k-nearest-neighbor">K-Nearest Neighbor</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-7ea1897bd96957ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
作为一种<strong>没有显式训练和学习</strong>过程的<strong>分类和回归</strong>算法，k 近邻在众多有<strong>监督机器学习</strong>算法中算是一种比较独特的方法。说它独特，是因为 k 近邻<strong>不像其他模型有损失函数、有优化算法、有训练过程</strong>。</p>
<h2 id="原理">原理</h2>
<p>给定一个训练数据集，对于新的输入实例，<strong>根据这个实例最近的 k 个实例所属的类别来决定其属于哪一类</strong>。所以相对于其它机器学习模型和算法，k 近邻总体上而言是一种非常简单的方法。</p>
<h2 id="距离的度量方式">距离的度量方式</h2>
<p>找到与该实例最近邻的实例，这里就涉及到如何找到，即在特征向量空间中，我们要采取<strong>何种方式来对距离进行度量</strong>。</p>
<p>距离的度量用在 k 近邻中我们也可以称之为<strong>相似性度量</strong>，即特征空间中两个实例点相似程度的反映。在机器学习中，常用的距离度量方式包括欧式距离、曼哈顿距离、余弦距离以及切比雪夫距离等。**在 k 近邻算法中常用的距离度量方式是欧式距离，也即 L2 距离，**L2 距离计算公式如下：<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-5b5f88f15c0de905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="k-值的大小如何选择">k 值的大小如何选择</h2>
<p>一般而言，k 值的大小对分类结果有着重大的影响。<strong>当选择的 k 值较小的情况下，就相当于用较小的邻域中的训练实例进行预测，只有当与输入实例较近的训练实例才会对预测结果起作用。但与此同时预测结果会对实例点非常敏感，分类器抗噪能力较差，因而容易产生过拟合</strong>，所以一般而言，k 值的选择不宜过小。但如果选择较大的 k 值，就相当于在用较大邻域中的训练实例进行预测，但相应的分类误差也会增大，模型整体变得简单，会产生一定程度的欠拟合。所以一般而言，我们需要<strong>采用交叉验证的方式来选择合适的 k 值</strong>。</p>
<blockquote>
<p>交叉验证的思路就是，把样本集中的大部分样本作为训练集，剩余的小部分样本用于预测，来验证分类模型的准确性。所以在 KNN 算法中，我们一般会把 K 值选取在较小的范围内，同时在验证集上准确率最高的那一个最终确定作为 K 值。</p>
</blockquote>
<h2 id="分类决策规则">分类决策规则</h2>
<p>k 个实例的多数属于哪个类，明显是多数表决的归类规则。当然还可能使用其他规则，所以第三个关键就是<strong>分类决策规则。</strong><br>
     <br>
回归：k个实例该属性值的平均值</p>
<h1 id="kd树">KD树</h1>
<p>它是一个二叉树的数据结构，方便存储 K 维空间的数据</p>
<p>KNN 的计算过程是大量计算样本点之间的距离。为了减少计算距离次数，提升 KNN 的搜索效率，人们提出了 KD 树（K-Dimensional 的缩写）。KD 树是对数据点在 K 维空间中划分的一种数据结构。在 KD 树的构造中，每个节点都是 k 维数值点的二叉树。既然是二叉树，就可以采用二叉树的增删改查操作，这样就大大提升了搜索效率。</p>
<h1 id="技巧">技巧</h1>
<ul>
<li>所有的特征应该被放缩到相同的量级</li>
<li>为了免平票的出现，K应该选择奇数</li>
<li>投票的结果会被到近邻样本的距离归一化，这样更近的样本的投票价值更大</li>
<li>尝试各种不同的距离度量方法</li>
<li>k值小，低偏差，高方差<br>
K值大，高偏差，低方差</li>
</ul>
<h1 id="sklearn"><a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html?highlight=neighbors%20kneighborsclassifier#sklearn.neighbors.KNeighborsClassifier">sklearn</a></h1>
<p>如果是做分类，你需要引用：from sklearn.neihbors import KNeighborsClassifier<br>
如果是回归， 需要引用：from sklearn.neighbors import KNeighborsRegressor</p>
<p><code>sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, weights='uniform', algorithm='auto', leaf_size=30, p=2, metric='minkowski', metric_params=None, n_jobs=None, **kwargs)</code></p>
<ul>
<li>weights： 预测中使用权重函数。</li>
</ul>
<blockquote>
<p>uniform，代表所有邻居的权重相同；distance，代表权重是距离的倒数，即与距离成反比；</p>
</blockquote>
<ul>
<li>algorithm：计算最近邻居的算法</li>
</ul>
<blockquote>
<p>auto，根据数据的情况自动选择适合的算法，默认情况选择 auto；<br>
kd_tree，也叫作 KD 树，是多维空间的数据结构，方便对关键数据进行检索，不过 KD 树适用于维度少的情况，一般维数不超过 20，如果维数大于 20 之后，效率反而会下降；<br>
ball_tree，也叫作球树，它和 KD 树一样都是多维空间的数据结果，不同于 KD 树，球树更适用于维度大的情况；<br>
brute，也叫作暴力搜索，它和 KD 树不同的地方是在于采用的是线性扫描，而不是通过构造树结构进行快速检索。当训练集大的时候，效率很低。</p>
</blockquote>
<ul>
<li>leaf_size：构造 KD 树或球树时的叶子数，默认是 30，调整 leaf_size 会影响到树的构造和搜索速度。</li>
<li>p：Minkowski度量的Power参数</li>
<li>metric：树使用的距离度量</li>
<li>n_jobsint：为邻居搜索运行的并行作业数。</li>
</ul>
<pre><code>from sklearn.neighbors import KNeighborsClassifier 
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from math import sqrt
from collections import Counter

iris = load_iris()
X = iris.data
y = iris.target
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

kNN_classifier = KNeighborsClassifier(n_neighbors=3)
kNN_classifier.fit(X_train,y_train)
predict_y = kNN_classifier.predict(X_test)

print(predict_y,y_test)
</code></pre>
<h1 id="numpy">numpy</h1>
<pre><code>from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from math import sqrt
from collections import Counter

iris = load_iris()
X = iris.data
y = iris.target
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

for x_t, y_t in zip(X_test, y_test):
    # 算出和X_train中每个点的距离
    distances = [sqrt(np.sum((x - x_t)**2)) for x in X_train] 
    # 对到每个点的距离从小到大排序，返回排序前的索引
    near_index = np.argsort(distances)
    # 选取前三个最靠近的点
    K = 3 
    # 根据索引得到值
    topK = [y_train[i] for i in near_index[:K]]
    # 投票
    votes = Counter(topK)
    predict_y = votes.most_common(1)[0][0]
    print(predict_y,y_t)
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="k-nearest-neighbor">K-Nearest Neighbor</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-7ea1897bd96957ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
作为一种<strong>没有显式训练和学习</strong>过程的<strong>分类和回归</strong>算法，k 近邻在众多有<strong>监督机器学习</strong>算法中算是一种比较独特的方法。说它独特，是因为 k 近邻<strong>不像其他模型有损失函数、有优化算法、有训练过程</strong>。</p>
<h2 id="原理">原理</h2>
<p>给定一个训练数据集，对于新的输入实例，<strong>根据这个实例最近的 k 个实例所属的类别来决定其属于哪一类</strong>。所以相对于其它机器学习模型和算法，k 近邻总体上而言是一种非常简单的方法。</p>
<h2 id="距离的度量方式">距离的度量方式</h2>
<p>找到与该实例最近邻的实例，这里就涉及到如何找到，即在特征向量空间中，我们要采取<strong>何种方式来对距离进行度量</strong>。</p>
<p>距离的度量用在 k 近邻中我们也可以称之为<strong>相似性度量</strong>，即特征空间中两个实例点相似程度的反映。在机器学习中，常用的距离度量方式包括欧式距离、曼哈顿距离、余弦距离以及切比雪夫距离等。**在 k 近邻算法中常用的距离度量方式是欧式距离，也即 L2 距离，**L2 距离计算公式如下：<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-5b5f88f15c0de905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="k-值的大小如何选择">k 值的大小如何选择</h2>
<p>一般而言，k 值的大小对分类结果有着重大的影响。<strong>当选择的 k 值较小的情况下，就相当于用较小的邻域中的训练实例进行预测，只有当与输入实例较近的训练实例才会对预测结果起作用。但与此同时预测结果会对实例点非常敏感，分类器抗噪能力较差，因而容易产生过拟合</strong>，所以一般而言，k 值的选择不宜过小。但如果选择较大的 k 值，就相当于在用较大邻域中的训练实例进行预测，但相应的分类误差也会增大，模型整体变得简单，会产生一定程度的欠拟合。所以一般而言，我们需要<strong>采用交叉验证的方式来选择合适的 k 值</strong>。</p>
<blockquote>
<p>交叉验证的思路就是，把样本集中的大部分样本作为训练集，剩余的小部分样本用于预测，来验证分类模型的准确性。所以在 KNN 算法中，我们一般会把 K 值选取在较小的范围内，同时在验证集上准确率最高的那一个最终确定作为 K 值。</p>
</blockquote>
<h2 id="分类决策规则">分类决策规则</h2>
<p>k 个实例的多数属于哪个类，明显是多数表决的归类规则。当然还可能使用其他规则，所以第三个关键就是<strong>分类决策规则。</strong><br>
     <br>
回归：k个实例该属性值的平均值</p>
<h1 id="kd树">KD树</h1>
<p>它是一个二叉树的数据结构，方便存储 K 维空间的数据</p>
<p>KNN 的计算过程是大量计算样本点之间的距离。为了减少计算距离次数，提升 KNN 的搜索效率，人们提出了 KD 树（K-Dimensional 的缩写）。KD 树是对数据点在 K 维空间中划分的一种数据结构。在 KD 树的构造中，每个节点都是 k 维数值点的二叉树。既然是二叉树，就可以采用二叉树的增删改查操作，这样就大大提升了搜索效率。</p>
<h1 id="技巧">技巧</h1>
<ul>
<li>所有的特征应该被放缩到相同的量级</li>
<li>为了免平票的出现，K应该选择奇数</li>
<li>投票的结果会被到近邻样本的距离归一化，这样更近的样本的投票价值更大</li>
<li>尝试各种不同的距离度量方法</li>
<li>k值小，低偏差，高方差<br>
K值大，高偏差，低方差</li>
</ul>
<h1 id="sklearn"><a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html?highlight=neighbors%20kneighborsclassifier#sklearn.neighbors.KNeighborsClassifier">sklearn</a></h1>
<p>如果是做分类，你需要引用：from sklearn.neihbors import KNeighborsClassifier<br>
如果是回归， 需要引用：from sklearn.neighbors import KNeighborsRegressor</p>
<p><code>sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, weights='uniform', algorithm='auto', leaf_size=30, p=2, metric='minkowski', metric_params=None, n_jobs=None, **kwargs)</code></p>
<ul>
<li>weights： 预测中使用权重函数。</li>
</ul>
<blockquote>
<p>uniform，代表所有邻居的权重相同；distance，代表权重是距离的倒数，即与距离成反比；</p>
</blockquote>
<ul>
<li>algorithm：计算最近邻居的算法</li>
</ul>
<blockquote>
<p>auto，根据数据的情况自动选择适合的算法，默认情况选择 auto；<br>
kd_tree，也叫作 KD 树，是多维空间的数据结构，方便对关键数据进行检索，不过 KD 树适用于维度少的情况，一般维数不超过 20，如果维数大于 20 之后，效率反而会下降；<br>
ball_tree，也叫作球树，它和 KD 树一样都是多维空间的数据结果，不同于 KD 树，球树更适用于维度大的情况；<br>
brute，也叫作暴力搜索，它和 KD 树不同的地方是在于采用的是线性扫描，而不是通过构造树结构进行快速检索。当训练集大的时候，效率很低。</p>
</blockquote>
<ul>
<li>leaf_size：构造 KD 树或球树时的叶子数，默认是 30，调整 leaf_size 会影响到树的构造和搜索速度。</li>
<li>p：Minkowski度量的Power参数</li>
<li>metric：树使用的距离度量</li>
<li>n_jobsint：为邻居搜索运行的并行作业数。</li>
</ul>
<pre><code>from sklearn.neighbors import KNeighborsClassifier 
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from math import sqrt
from collections import Counter

iris = load_iris()
X = iris.data
y = iris.target
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

kNN_classifier = KNeighborsClassifier(n_neighbors=3)
kNN_classifier.fit(X_train,y_train)
predict_y = kNN_classifier.predict(X_test)

print(predict_y,y_test)
</code></pre>
<h1 id="numpy">numpy</h1>
<pre><code>from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from math import sqrt
from collections import Counter

iris = load_iris()
X = iris.data
y = iris.target
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)

for x_t, y_t in zip(X_test, y_test):
    # 算出和X_train中每个点的距离
    distances = [sqrt(np.sum((x - x_t)**2)) for x in X_train] 
    # 对到每个点的距离从小到大排序，返回排序前的索引
    near_index = np.argsort(distances)
    # 选取前三个最靠近的点
    K = 3 
    # 根据索引得到值
    topK = [y_train[i] for i in near_index[:K]]
    # 投票
    votes = Counter(topK)
    predict_y = votes.most_common(1)[0][0]
    print(predict_y,y_t)
</code></pre>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试1（杂谈）]]></title>
        <id>https://dingtom.github.io/post/mian-shi-1za-tan/</id>
        <link href="https://dingtom.github.io/post/mian-shi-1za-tan/">
        </link>
        <updated>2021-03-29T07:43:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础知识">基础知识</h1>
<p>对于一些企业的技术初面，面试官可能不会和你讨论项目的技术细节，而是已经准备好了一系列的面试题，此时面试就变成面试官读题，自己答题的环节。这类基础知识问答包括计算机网络、操作系统、计算机组成原理、语言特性、数据库原理等方面的内容。例如：<br>
（网络）输入域名后的流程是什么？七/四层模型是怎样的？TCP 的拥塞控制方法是什么？<br>
（操作系统）进程和线程的区别是什么？死锁的如何产生、避免？分段、分页与虚拟内存的系列问题、CPU 调度的系列问题等；<br>
（计算机组成原理）指令执行的基本过程是什么？<br>
（数据库原理）存储引擎的区别是什么？索引底层实现的原理是什么？<br>
（语言特性）Java 垃圾回收机制是怎样的？Java 虚拟机包括哪些部分？Js 闭包的原理是什么？go routine 的调度是如何进行的？<br>
对于这些问题，最直接的办法就是直接看已有的面试题整理，在一些博客或是牛客论坛上有大量的总结材料，对于有一定基础的同学直接看材料就能基本回忆起之前所学的课程。<br>
近两年由于大家越来越善于背题，出题的难度也在逐渐增加，偶尔有一些确实不会的题目直接承认即可，也不用不懂装懂强行回答，反而可能引起面试官的反感。<br>
#项目经历<br>
投递技术开发类岗位的同学基本都需要准备一些拿得出手的项目。项目经历是最无法临时准备的部分，在一些企业中项目深挖讨论反而会占面试的大部分时间。<br>
在我看来，准备描述自己的项目经历可以包括以下几点：<br>
(1) 描述清楚项目的背景和需要解决的问题；<br>
(2) 用了什么样的技术方法；<br>
(3) 项目取得了怎样的成果；<br>
(4) 自己在项目中是怎样的角色，负责哪些工作；<br>
在我实习和秋招面试的过程中，尽管简历上列出了最具代表性的三个项目，但是每次详细介绍的项目实际只有一到两个。<br>
对于如何描述自己的项目经历，完全可以像自我介绍一样准备好时间稍长一些的介绍模版，并至少准备好回答如下问题：<br>
在这个项目中，你遇到的难点是什么？你是如何解决的？<br>
项目介绍本身并不需要回答这个问题，而是面试官基本都会问这个问题。<br>
此外，通过多次面试，我发现每个项目介绍后面试官所问的问题都是有限的几个，因此可以通过多次面试提前准备好更多的项目问题回答，在交流过程中展现出自己从容、清晰的一面。</p>
<h1 id="原理解析">原理解析</h1>
<p>在我看来，这是整个面试过程中非常容易加分的部分。我们可以根据自己已有的项目、自我介绍中频繁出现的关键词，用心准备两到三个可以深挖的点。<br>
这里的原理解析不是仅仅是自己“看过别人写的解析文档”，而是自己深入理解，并能“有条理地讲述给别人听”。<br>
可以选择的方向例如：Tomcat、Spring、Redis、Kafka 的架构和源码实现、数据库引擎的实现、操作系统内核的实现、分布式一致性算法的源码实现、以及其他在自己项目中出现的问题等。<br>
选择深入准备的方向并不是随机的，而是确实在自己的项目中发挥了重要用途，并解决实际问题的关键难点。如果说基础知识重在广度和准确性，那么原理解析就要重在深度和思考性，描述自己的理解和思考，并能经得起面试官“步步紧逼”的询问。<br>
准备好可以深入探讨的点后，就可以在自我介绍、项目介绍过程中有意识的挖坑，频繁提起关键词，并留下含糊的描述性语句吸引面试官提问。（石头注：哈哈，都是套路啊）<br>
而在交流的过程中，也无需完整背诵千字大论文，而是由上而下，从整体到局部逐步解释。如果面试官强行讨论自己不熟悉的领域，直接简短说明不太了解即可，长时间支支吾吾无法清晰表达反而会导致减分。</p>
<h1 id="手写算法">手写算法</h1>
<p>在秋招开始前，我最担心的就是手写代码这一环节，对比身边一些将 leetcode 题库刷完的同学，我刷过的题目数量可能只有零头，不过在手写代码上也没有出过严重的问题。<br>
在我看来，平时没有刷题习惯的同学也无需对这个环节太过担心，只要有针对性进行准备，基本都能顺利完成。<br>
在临时突击刷题方案中，“数量”并不是重要因素，“重复”才是重点，我比较推荐的一个刷题方案是：<br>
(1) 专题练习阶段：按 leetcode 标签专题刷题，如字符串、DFS、动态规划、树、双指针、排序等，选择出现频率较高的简单和中等难度题目。对于常见的标签，做到能理解其常见解题思路即可；<br>
(2) 精选题库阶段：可以选择 leetcode 热门 100 题，或者剑指 offer 练习题刷题，此时需要注意重复刷题，例如完整做完剑指 offer 练习题后再刷一遍，争取看到题目就能想到思路，独立快速完成题目；<br>
在秋招准备阶段，我个人一共刷了 150 题左右，在面试的手写算法环节基本都顺利完成。<br>
此外，在手写算法的过程中一定要注意代码规范，注意异常输入的处理和代码整洁性，另外：<br>
如果暂时没有思路，可以试图从面试官那里获取提示，部分面试官甚至可以接受换题的要求。<br>
如果有一些思路，可以尝试积极和面试官沟通获取一些提示。<br>
如果确信自己无法解决问题，那么要求提示或者换其他题目总比留白要好。</p>
<h1 id="项目经验">项目经验</h1>
<p>项目：有目标、有资源投入、一系列任务的集合</p>
<h1 id="实习经历只关注了券商的实习-一定要提前准备实习的内容详细介绍-非常重要">实习经历，只关注了券商的实习。一定要提前准备实习的内容，详细介绍。非常重要！！！</h1>
<h1 id="以前做过的工作现在想想有没有哪里可以优化的-a知识点关联分析">以前做过的工作现在想想有没有哪里可以优化的； （A：知识点关联分析）</h1>
<h1 id="自我介绍">自我介绍</h1>
<p>至少应该包括：<br>
(1) 基本信息，毕业院校；<br>
(2) 实习、项目、竞赛经历和成果；<br>
(3) 自己擅长的技术栈；</p>
<ul>
<li>
<p>例如如果自己对某些课程掌握非常深入，可以在教育经历中简要谈谈自己的课程情况，如果对自己的一个项目准备非常充分，可以加大自我介绍时该项目的比重，但切忌一下子说完让面试官无问题可问，而是有意识的留一些常见问题的缺口，例如分布式、效率优化等关键词，并针对这些关键词着重准备。</p>
</li>
<li>
<p><strong>对面试公司的热爱及了解、过往重点工作经历（ 结合招聘岗位，只讲重点）</strong></p>
</li>
<li>
<p><strong>有理有据，少说空话。</strong>“学习能力强”，假大空。“精通”这类给自己挖坑的词汇。举一个例子，考了什么证书、具体做了什么。</p>
</li>
</ul>
<p>**有开头有结尾，有逻辑。**开头问候，结尾总结。中间1、2、3条理</p>
<blockquote>
<ul>
<li>
<p>各位面试官下午好，非常感谢咱们公司给我这次面试的机会。  我叫丁文超，是中原工学院计算机学院控制工程专业应届毕业生。</p>
</li>
<li>
<p>在研究生期间我的研究方向是无线智能感知， 主要是使用修改过网卡驱动的linux系统进行Wi-Fi信道状态信息数据的收集和处理，使用深度学习算法对其进行分析建模，来识别人体动作。研究生期间学习成绩靠前，每年都获得了学业奖学金。</p>
</li>
<li>
<p>认为我有较强的学习和抗压能力，比较喜欢学习新鲜事物。<br>
我所理解的数据分析岗位需要同时掌握技术和业务方面的知识，是非常具体有挑战性的。对这个岗位我很有兴趣也有信心，希望能得到这个机会，提升自己的能力并为公司做出自己的贡献。谢谢。</p>
</li>
</ul>
</blockquote>
<h1 id="现在的研究方向">现在的研究方向</h1>
<p>智能感知（深度学习）</p>
<h1 id="数分岗位的理解">数分岗位的理解</h1>
<p>其对应的工作内容应该是<strong>业务数据分析</strong>。，例如业务目标是用户增长、销量增长等。</p>
<p>**你未来的职业规划方向是偏业务还是偏技术？**而我所理解的数据分析岗位本身就是业务方向的，技术方向可发展的领域一是BI，二是数据挖掘的算法研究吧。</p>
<p>退一步看，对于工作中只要求到EXCEL技能的岗位，最多只能称为<strong>数据统计</strong>吧。</p>
<p>进一步看，对于工作中要求到Hadoop,Spark等相关技能的岗位，更应该称作<strong>大数据分析师</strong>或<strong>数据开发工程师</strong>。</p>
<h1 id="自己制定了什么计划以什么样的节奏学习">自己制定了什么计划，以什么样的节奏学习？</h1>
<h1 id="让自己骄傲的事情">让自己骄傲的事情？</h1>
<h1 id="反问">反问</h1>
<p>公司的这个岗位的具体工作内容、薪资结构、 晋升路线 、什么时候可以入职想早点工作</p>
<h1 id="优缺点">优缺点</h1>
<p>缺点：<br>
<strong>在谈到自己缺点的时候，尽量避开三观，性格方面的缺点。最好还是着眼于知识和技能。因为这两点改进空间大，速度快。</strong><br>
<strong>往高处说，挑一个与你目前所在层次相隔较远的能力缺陷来说。</strong><br>
<strong>往远处说：术业有专攻，找一个与你本职工作间隔较远的专业能力缺陷来说。</strong><br>
优点：岗位要求！！！<br>
假如你是应聘一家证券公司的财务岗位，你可以说：“这么多年，我都是在财务领域纵深发展，对行业知识、业务细节的了解和学习还不够，我自己也意识到了这一点，我已经报考了证券从业资格，其实也就是想弥补自己这个不足，对我开展财务工作绝对也是有好处的。”</p>
<blockquote>
<ul>
<li>没有实习经验,</li>
<li>我认为我有较强的学习和抗压能力比较喜欢学习新鲜事物，因此我本科毕业后选择了跨考计算机专业,看到有意思的开源项目喜欢跑一跑，看到新技术也喜欢看看。</li>
</ul>
</blockquote>
<h1 id="理想的工作状态是怎样的">理想的工作状态是怎样的</h1>
<h1 id="你比同龄人的优势">你比同龄人的优势</h1>
<p>即你的哪些条件，比其他求职者更加适合这个职位，比如工作能力、经验、性格、人际沟通等等。</p>
<h1 id="未来1-自我认知-你对自己是否了解了解得足够充分靠谱吗">未来**1. 自我认知。**你对自己是否了解？了解得足够充分靠谱吗?</h1>
<ol>
<li>
<p>自我认知。你对自己是否了解？了解得足够充分靠谱吗?</p>
<p>规划是基于目前的实际情况来设计的，不是凭空想的。</p>
</li>
<li>
<p>动机和价值观。你是否能接受“我们并不一定能给你公平的职业发展机会”这个现实？</p>
<p><strong>不要描述太外在的东西，比如职位、薪酬、管理幅度</strong></p>
</li>
<li>
<p>组织承诺。你到底能在我们这儿踏实干几年？</p>
</li>
</ol>
<p>​       不要表现自己有多么厉害，而要<strong>表现自己靠谱、工作稳定、心态平和</strong></p>
<p>工作方面，突出自己打算通过积极完成工作任务，积累各方面的经验，让自己成为这个领域的专业人士，也希望有机会能够带领团队，成为优秀的管理者，为单位做出更大贡献，获得双赢</p>
<p>学习方面，打算在专业领域做进一步学习和研究，将实践经验与专业知识相结合，为自己的职业成长做好铺垫，打好基础。</p>
<blockquote>
<p>由于我实践经验比较欠缺，所以我觉得我需要静下心来好好学习公司的业务流程，多接触一些实际项目，多向优秀的同事学习。在完成项目后及时复盘，通过不断的改进工作方法，将业务与专业知识相结合，让自己成为优秀的数据分析师，为公司做出更大贡献！</p>
</blockquote>
<h1 id="为什么选择我们这家公司">为什么选择我们这家公司</h1>
<p>1.公司强<br>
2.文化理念<br>
3.学习</p>
<blockquote>
<p>2014年12月26日，中原银行正式成立 ，很年轻很多机会<br>
河南人自己的银行<br>
“科技立行、科技兴行” ， 从2018年起，中原银行开启数字化转型，以打造敏捷银行、未来银行为目标，全面启动科技和数据能力建设。</p>
</blockquote>
<blockquote>
<p>银行在经济发展的过程中扮演了重要角色，浦发银行作为头部企业有着着良好的业绩，重视人才培养，非常吸引我。我认为我的性格较为沉稳，做事认真踏实，且专业素养高，符合公司的用人标准。所以想要加入浦发银行，提高自己的实践能力，为公司的发展做出自己的贡献。</p>
</blockquote>
<h1 id="你对加班的看法">你对加班的看法</h1>
<p>现在加班实属正常现象，加班也能多学点东西。</p>
<h1 id="描述一下所做过的项目中遇到最困难的技术问题是什么最后怎么解决">描述一下所做过的项目中遇到最困难的技术问题是什么，最后怎么解决</h1>
<blockquote>
<p>做研究课题的时候需要从头开始写代码，一开始找到了一个不完整的开源项目，但是整体的流程，和每个函数的功能写的都不是很清晰，改了很久还是不行。最后把整个流程分解，一个模块一个模块的找，重写 。然后再整合起来。我觉得遇到问题，保持心态良好，冷静去思考解决方式，然后再开始行动。</p>
</blockquote>
<p>我之前在某小厂实习时，前期拍好了大量视频素材，领导需要我将这些视频剪辑成一个活动全程的完整视频。我之前从未学习过视频剪辑，对PR一窍不通。除了技术上的陌生，将近4个小时的视频素材也大大增加了这个任务的难度。为了完成这个任务，我通过查找网上教程和视频，在2天之内交出了最终视频。虽然不是那么完美，但也得到了领导的肯定，为活动画上了句号。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python]]></title>
        <id>https://dingtom.github.io/post/python/</id>
        <link href="https://dingtom.github.io/post/python/">
        </link>
        <updated>2020-11-30T08:13:07.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>== 比较值，is比较ID(内存地址）</li>
<li>and\or逻辑比较，&amp;|按位与\或</li>
<li>字符串拼接join()快，用加号拼接字符串因为字符串是不可变对象所以每次都会生成新对象</li>
<li>支持链式比较（两两相比加and）</li>
</ul>
<h1 id="随机数">随机数</h1>
<pre><code>随机种子：random.seed()
随机选择：random.choice(List)
随机打乱：random.shuffle(List)
随机整数：random.randint(a,b),生成区间内的整数
随机采样:random.sample(list18, samples)
随机小数：random.random()
习惯用numpy库，利用np.random.randn(5)生成5个随机小数
</code></pre>
<h1 id="global">global</h1>
<p>在函数声明 修改全局变量</p>
<pre><code>a=4
def f():
    global a 
    a=3 
f()
</code></pre>
<h1 id="内置函数">内置函数</h1>
<h2 id="filter">filter()</h2>
<p>用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表</p>
<pre><code>t = filter(lambda x:True if x&gt;3 else False, [0, 2, 3, 4, 5])
print(list(t))
</code></pre>
<h2 id="map">map()</h2>
<p>接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p>
<pre><code>比如，把这个list所有数字转为字符串：
list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
</code></pre>
<h1 id="reduce">reduce()</h1>
<p>把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是</p>
<pre><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<pre><code># 比方说对一个序列求和，就可以用reduce实现：
from functools import reduce
def add(x, y):
  return x + y
reduce(add, [1, 3, 5, 7, 9])
25
</code></pre>
<h2 id="-zip">-zip()</h2>
<p>会将列表按位组合成元组</p>
<h2 id="any-all">any、all()</h2>
<p>判断可送代对象中是否包含（0,&quot;&quot;,False）的元素</p>
<h1 id="列表推导式-字典推导式-生成器">列表推导式、字典推导式、生成器</h1>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-e3e9887c9e9be645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="闭包装饰器的本质也是闭包">闭包(装饰器的本质也是闭包)</h1>
<p>一个函数在另一个函数里面，外层函数返回的是里层函数，返回的函数还可以访问它的定义所在的作用域，也就是它带着它的环境。这个被称为闭包。</p>
<p>闭包可以保存环境变量</p>
<pre><code>def outer(factor):
    def inner(number):
        return number*factor
    return inner
func_inner = outer(4)
# 第一次获取到内部的函数，之后可以直接使用这个函数
print(func_inner)
value = func_inner(5)
print(value)  # 20
# 或者我们也可以写成一句话：
value = outer(4)(5)
print(value)  # 20
</code></pre>
<h1 id="函数装饰器"><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">函数装饰器</a></h1>
<p>为什么要用装饰器：在写项目的时候不可能一次性把所有的功能都全部写完或则上线前客户需求改变，需要<s>对函数添加新功能（装饰器函数）。</s></p>
<p>开放封闭原则:<br>
<s>对扩展是开放</s>：就是对项目的拓展功能是开放的，可以进行添加新的功能<br>
<s>对修改是封闭的</s>：就是对原函数的源代码和调用方式是封闭的</p>
<p>使用函数装饰器 A() 去装饰另一个函数 B()，其底层执行了如下 2 步操作：<br>
将 B 作为参数传给 A() 函数；将 A() 函数执行完成的返回值反馈回  B。</p>
<pre><code>@A
def B():
=============================
B = A(B)
</code></pre>
<p>多个装饰器的执行顺序</p>
<pre><code>@B
@A
def C()
装饰过程；A-&gt;B
执行过程；B-&gt;A
</code></pre>
<pre><code># @wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。
from functools import wraps
 
def logit(logfile='out.log'):
    def logging_decorator(func):
        @wraps(func)  # 在装饰器里面访问在装饰之前的函数的属性。
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + &quot; was called&quot;
            print(log_string)
            # 打开logfile，并写入内容
            with open(logfile, 'a') as opened_file:
                # 现在将日志打到指定的logfile
                opened_file.write(log_string + '\n')
            return func(*args, **kwargs)
        return wrapped_function
    return logging_decorator
</code></pre>
<pre><code>@logit()
def myfunc1():
    pass
 
myfunc1()
# Output: myfunc1 was called
# 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串
</code></pre>
<pre><code>@logit(logfile='func2.log')
def myfunc2():
    pass
 
myfunc2()
# Output: myfunc2 was called
# 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串
</code></pre>
<h2 id="property">@property</h2>
<p><s>就是负责把一个方法变成属性调用的</s></p>
<h1 id="面向对象">面向对象</h1>
<p>实例的变量名如果以__开头，就变成了一个私有变量（private）。</p>
<p>仍然可以通过_Student__name来访问__name变量，表面上看，外部代码“成功”地设置了“__name”变量，但实际上这个“__name”变量和class内部的__name变量不是一个变量</p>
<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<s>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以</s>了：这就是动态语言的“鸭子类型”</p>
<p>dir()：获得一个对象的所有属性和方法<br>
getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态</p>
<pre><code>hasattr(obj, 'x') # 有属性'x'吗？
setattr(obj, 'y', 19) # 设置一个属性'y'
 getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
</code></pre>
<p>还可以尝试给实例绑定一个方法,但是，<s>给一个实例绑定的方法，对另一个实例是不起作用的</s></p>
<pre><code>def set_age(self, age): # 定义一个函数作为实例方法
  self.age = age
from types import MethodType
给实例绑定一个方法
s.set_age = MethodType(set_age, s) #
</code></pre>
<p>为了给所有实例都绑定方法，可以<s>给class绑定方法：</s></p>
<pre><code>Student.set_age= set_age
</code></pre>
<p>如果我们想要限制实例的属性，比如，只允许对Student实例添加name和age属性。<br>
为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的~~__slots__变量，来限制该class实例能添加的属性,__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的~~：</p>
<pre><code>class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
</code></pre>
<h1 id="实例方法类方法静态方法">实例方法，类方法，静态方法</h1>
<ul>
<li>实例方法， 类对象直接调用实例方法</li>
<li>类方法，使用类名直接调用类方法，不需要实例化，类方法只能调用类属性，不能调用实例属性</li>
<li>静态方法，不需要实例化，其实就是的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。</li>
</ul>
<blockquote>
<p>静态方法<s>没有类似 self、cls 这样的特殊参数</s>，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中<s>无法调用任何类属性和类方法。</s></p>
</blockquote>
<pre><code>#类构造方法，也属于实例方法
def __init__(self):
     self.name = &quot;C语言中文网&quot;
     self.add = &quot;http://c.biancheng.net&quot;
# 下面定义了一个say实例方法
def say(self):
     print(&quot;正在调用 say() 实例方法&quot;)
#下面定义了一个类方法
@classmethod
def info(cls):
     print(&quot;正在调用类方法&quot;,cls)
# 和 self 一样，cls 参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已。
@staticmethod
    def info(name,add):
        print(name,add)
</code></pre>
<h1 id="文件操作">文件操作</h1>
<h2 id="oswalk">os.walk()</h2>
<pre><code> for root, dirs, files in os.walk('.'):  
        print(root) #当前目录路径  
        print(dirs) #当前路径下所有子目录  (不包括子目录)
        print(files) #当前路径下所有非目录子文件(不包括子目录)
        print('*'*10)
</code></pre>
<h2 id="ospathsplitext">os.path.splitext()</h2>
<p>函数将路径拆分为文件名+扩展名</p>
<pre><code>os.path.splitext(“E:/lena.jpg”)
# 将得到”E:/lena“+&quot;.jpg&quot;。
</code></pre>
<h2 id="ospathbasename">os.path.basename</h2>
<p>返回path最后的文件名。如果path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素。</p>
<pre><code>path = '/Users/beazley/Data/data.csv'
os.path.basename(path)
#'data.csv'
</code></pre>
<h2 id="oslistdir">os.listdir()</h2>
<p>所有目录和文件</p>
<pre><code>1.创建目录
os.mkdir(“file”)
2.复制文件：
shutil.copyfile(“oldfile”,”newfile”) #oldfile和newfile都只能是文件
shutil.copy(“oldfile”,”newfile”) #oldfile只能是文件夹，newfile可以是文件，也可以是目标目录
3.复制文件夹：
shutil.copytree(“olddir”,”newdir”) #olddir和newdir都只能是目录，且newdir必须不存在
5.重命名文件(目录)
os.rename(“oldname”,”newname”) #文件或目录都是使用这条命令
6.移动文件(目录)
shutil.move(“oldpos”,”newpos”)
7.删除文件
os.remove(“file”)
8.删除目录
os.rmdir(“dir”) #只能删除空目录
shutil.rmtree(“dir”) #空目录、有内容的目录都可以删
</code></pre>
<h1 id="生成器">生成器</h1>
<pre><code>def foo():
    print(&quot;starting...&quot;)
    while True:
        res = yield 4
        print(&quot;res:&quot;,res)
g = foo()
print(next(g))
print(&quot;*&quot;*20)
print(next(g))
</code></pre>
<pre><code>starting...
4
********************
res: None
4
</code></pre>
<p>1.程序开始执行以后，<s>因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象).</s><br>
2.直到<s>调用next方法，foo函数正式开始执行</s>，先执行foo函数中的print方法，然后进入while循环<br>
3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，<br>
4.程序执行print(&quot;*&quot;<em>20)，输出20个</em><br>
5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，<s>这个时候是从刚才那个next程序停止的地方开始执行的</s>，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,<br>
6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p>
<h1 id="切片">切片</h1>
<p>object[start_index:end_index:step]<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-708a7823d1970cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<pre><code>print(a[::-1]) ### 取从后向前（相反）的元素
a[3::2]# 从索引3开始隔一取一
</code></pre>
<h1 id="格式化字符串">格式化字符串</h1>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-10f11f25f2121404.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="传参">传参</h1>
<p>fun(*args,**kwargs)<br>
*args是用来发送一个非键值对的可变数量的参数列表给一个函数<br>
**kwargs允许你将不定长度的键值对，作为参数传递给一个函数。</p>
<pre><code>def func1(a,b=1,*c,**d):
    print(a,b,c,d)  
    
l = [3,4]
dic = {'@':2,'#':3}

func1(1,2,l,dic)
func1(1,2,*l,**dic)
func1(1,2,3,4,**dic)

# 1 2 ([3, 4], {'@': 2, '#': 3}) {}
# 1 2 (3, 4) {'@': 2, '#': 3}
# 1 2 (3, 4) {'@': 2, '#': 3}
</code></pre>
<h1 id="列表-字典">列表、字典</h1>
<p>字典的合并</p>
<pre><code>dictl={'a':1,'b':2}
dict2={'c':3,'d':4}
dictl.update(dict2)
print(dictl)
</code></pre>
<h1 id="问题">问题</h1>
<h2 id="列表和元组的区别">列表和元组的区别</h2>
<blockquote>
<ol>
<li>列表是动态数组，它们可变且可以重设长度（改变其内部元素的个数）。</li>
<li>元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变。 但是我们可以将两个元组合并成一个新元组。<br>
3.<s>元组缓存于Python运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存</s><br>
Python是一门垃圾收集语言，这意味着当一个变量不再被使用时，Python会将该变量使用的内存释放回操作系统，以供其他程序（变量）使用。然而，对于长度为1~20的元组，<s>即使它们不在被使用，它们的空间也不会立刻还给系统，而是留待未来使用</s>。这意味着当未来需要一个同样大小的新的元组时，我们不再需要向操作系统申请一块内存来存放数据，因为我们已经有了预留的空间。</li>
</ol>
</blockquote>
<h2 id="gll">GlL</h2>
<p>python的全局解释器锁，<s>同一进程中假如有多个线程运行线程在运行python程序的时候会霸占 python解释器（加了一把锁即GlL),使该进程内的其他线程无法运行</s>，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行</p>
<p>多进程中因为每个进程都能被系统分配资源，相当于<s>每个进程有了一个 python解释器</s>所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大</p>
<h2 id="python传参数是传值还是传址">python传参数是传值还是传址？</h2>
<p>Python中函数参数是<s>引用传递</s>（注意不是值传递）。对于不可变类型（数值型、字符串、元组），因变量不能修改，所以运算不会影响到变量自身；而对于可变类型（列表字典）来说，函数体运算可能会更改传入的参数变量。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-afd4b5afada2703d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="python对象销毁垃圾回收">python对象销毁(垃圾回收)</h2>
<blockquote>
<p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 Python 内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， <s>这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是&quot;立即&quot;的</s>， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。<s>Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。</s></p>
</blockquote>
<h2 id="简述乐观锁和悲观锁">简述乐观锁和悲观锁</h2>
<p>悲观锁，就是很悲观，<s>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁</s>，这样别人想拿这个数据就会 block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<br>
乐观锁，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是<s>在更新的时候会判断一下在此期间别人有没有去更新这个数据</s>，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker]]></title>
        <id>https://dingtom.github.io/post/docker/</id>
        <link href="https://dingtom.github.io/post/docker/">
        </link>
        <updated>2020-11-28T14:10:09.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-a16ddde40bfc6f50.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p>ubuntu安装 Docker 的时候需在管理员的账号下操作。<br>
<code>wget -qO- https://get.docker.com/ | sh</code><br>
安装完成之后，以 sudo 启动 Docker 服务。<br>
<code>sudo service docker start</code></p>
<h3 id="容器生命周期管理">容器生命周期管理</h3>
<h4 id="创建一个新的容器并运行一个命令run"><a href="https://www.runoob.com/docker/docker-run-command.html">创建一个新的容器并运行一个命令：run</a></h4>
<p><code>docker run -d(后台运行不阻塞shell） -p 80:80（指定容器端口映射，内部：外部） nginx</code></p>
<blockquote>
<p>-d：后台运行容器<br>
-h: 指定容器的hostname；<br>
-p：主机端口号:容器端口号```容器内外端口映射<br>
--name name：指定容器名称<br>
-v &lt;外部 dir&gt;:&lt; 内部 dir&gt;：目录映射<br>
<mirror name>:<version>：指定映像版本<br>
-it：在容器启动后直接进入<br>
--link：将另一个容器映射到本容器，进行通信<br>
--restart=always：因某种错误而停止运行时，能够自动重启</p>
</blockquote>
<h4 id="启动停止重启容器startstoprestart"><a href="https://www.runoob.com/docker/docker-start-stop-restart-command.html">启动/停止/重启容器：start/stop/restart</a></h4>
<h4 id="杀掉容器kill"><a href="https://www.runoob.com/docker/docker-kill-command.html">杀掉容器：kill</a></h4>
<p>快速停止容器</p>
<h4 id="删除容器rm"><a href="https://www.runoob.com/docker/docker-rm-command.html">删除容器：rm</a></h4>
<p><code>docker rm -f container_id</code></p>
<h4 id="暂停恢复容器中进程pauseunpause"><a href="https://www.runoob.com/docker/docker-pause-unpause-command.html">暂停/恢复容器中进程：pause/unpause</a></h4>
<p>如果只是希望容器暂停工作一段时间，比如对容器的文件系统大打个快照，或者 docker host 需要使用 CPU，这是可以执行 docker pause 将其暂停。处于暂停状态的容器不会占用 CPU，直到通过 docker unpause 恢复运行。</p>
<h4 id="创建容器create"><a href="https://www.runoob.com/docker/docker-create-command.html">创建容器：create</a></h4>
<h4 id="进入容器exec"><a href="https://www.runoob.com/docker/docker-exec-command.html">进入容器：exec</a></h4>
<p><code>docker exec -it container_id bash</code></p>
<h3 id="容器操作">容器操作</h3>
<h4 id="查看正在运行的容器ps"><a href="https://www.runoob.com/docker/docker-ps-command.html">查看正在运行的容器：ps</a></h4>
<p><code>docker ps</code></p>
<h4 id="inspect"><a href="https://www.runoob.com/docker/docker-inspect-command.html">inspect</a></h4>
<h4 id="top"><a href="https://www.runoob.com/docker/docker-top-command.html">top</a></h4>
<h4 id="attach"><a href="https://www.runoob.com/docker/docker-attach-command.html">attach</a></h4>
<h4 id="events"><a href="https://www.runoob.com/docker/docker-events-command.html">events</a></h4>
<h4 id="logs"><a href="https://www.runoob.com/docker/docker-logs-command.html">logs</a></h4>
<h4 id="wait"><a href="https://www.runoob.com/docker/docker-wait-command.html">wait</a></h4>
<h4 id="export"><a href="https://www.runoob.com/docker/docker-export-command.html">export</a></h4>
<h4 id="port"><a href="https://www.runoob.com/docker/docker-port-command.html">port</a></h4>
<h3 id="容器rootfs命令">容器rootfs命令</h3>
<h4 id="从容器创建一个新的镜像commit"><a href="https://www.runoob.com/docker/docker-commit-command.html">从容器创建一个新的镜像：commit</a></h4>
<p><code>docker commit container_id mirror_name</code>我们修改过后的容器保存成镜像，重新运行，它可以保持这个变化</p>
<blockquote>
<p>-a :提交的镜像作者；<br>
-c :使用Dockerfile指令来创建镜像；<br>
-m :提交时的说明文字；<br>
-p :在commit时，将容器暂停。</p>
</blockquote>
<h4 id="cp"><a href="https://www.runoob.com/docker/docker-cp-command.html">cp</a></h4>
<h4 id="diff"><a href="https://www.runoob.com/docker/docker-diff-command.html">diff</a></h4>
<h3 id="镜像仓库">镜像仓库</h3>
<h4 id="login"><a href="https://www.runoob.com/docker/docker-login-command.html">login</a></h4>
<h4 id="拉取或者更新镜像pull"><a href="https://www.runoob.com/docker/docker-pull-command.html">拉取或者更新镜像：pull</a></h4>
<p><code>docker pull nginx（等效于nginx:latest）</code></p>
<h4 id="push"><a href="https://www.runoob.com/docker/docker-push-command.html">push</a></h4>
<h4 id="search"><a href="https://www.runoob.com/docker/docker-search-command.html">search</a></h4>
<p>命令可以搜索 Docker Hub 中的镜像。</p>
<h3 id="本地镜像管理">本地镜像管理</h3>
<h4 id="查看镜像列表images"><a href="https://www.runoob.com/docker/docker-images-command.html">查看镜像列表：images</a></h4>
<p><code>docker images</code></p>
<h4 id="删除镜像rmi"><a href="https://www.runoob.com/docker/docker-rmi-command.html">删除镜像：rmi</a></h4>
<p><code>docker rmi mirror_name</code></p>
<h4 id="tag"><a href="https://www.runoob.com/docker/docker-tag-command.html">tag</a></h4>
<h4 id="使用dockerfile构建镜像build"><a href="https://www.runoob.com/docker/docker-build-command.html">使用Dockerfile构建镜像：build</a></h4>
<p><code>docker build -t mirror_name 存放Dockerfile的文件夹</code></p>
<h4 id="history"><a href="https://www.runoob.com/docker/docker-history-command.html">history</a></h4>
<h4 id="镜像保存为tarsave"><a href="https://www.runoob.com/docker/docker-save-command.html">镜像保存为tar：save</a></h4>
<p><code>docker save mirror_name &gt; .tar</code></p>
<h4 id="从tar加载镜像load"><a href="https://www.runoob.com/docker/docker-load-command.html">从tar加载镜像：load</a></h4>
<p><code>docker load &lt; .tar</code></p>
<h4 id="import"><a href="https://www.runoob.com/docker/docker-import-command.html">import</a></h4>
<h3 id="infoversion">info|version</h3>
<h4 id="info"><a href="https://www.runoob.com/docker/docker-info-command.html">info</a></h4>
<h4 id="version"><a href="https://www.runoob.com/docker/docker-version-command.html">version</a></h4>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-a16ddde40bfc6f50.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p>ubuntu安装 Docker 的时候需在管理员的账号下操作。<br>
<code>wget -qO- https://get.docker.com/ | sh</code><br>
安装完成之后，以 sudo 启动 Docker 服务。<br>
<code>sudo service docker start</code></p>
<h3 id="容器生命周期管理">容器生命周期管理</h3>
<h4 id="创建一个新的容器并运行一个命令run"><a href="https://www.runoob.com/docker/docker-run-command.html">创建一个新的容器并运行一个命令：run</a></h4>
<p><code>docker run -d(后台运行不阻塞shell） -p 80:80（指定容器端口映射，内部：外部） nginx</code></p>
<blockquote>
<p>-d：后台运行容器<br>
-h: 指定容器的hostname；<br>
-p：主机端口号:容器端口号```容器内外端口映射<br>
--name name：指定容器名称<br>
-v &lt;外部 dir&gt;:&lt; 内部 dir&gt;：目录映射<br>
<mirror name>:<version>：指定映像版本<br>
-it：在容器启动后直接进入<br>
--link：将另一个容器映射到本容器，进行通信<br>
--restart=always：因某种错误而停止运行时，能够自动重启</p>
</blockquote>
<h4 id="启动停止重启容器startstoprestart"><a href="https://www.runoob.com/docker/docker-start-stop-restart-command.html">启动/停止/重启容器：start/stop/restart</a></h4>
<h4 id="杀掉容器kill"><a href="https://www.runoob.com/docker/docker-kill-command.html">杀掉容器：kill</a></h4>
<p>快速停止容器</p>
<h4 id="删除容器rm"><a href="https://www.runoob.com/docker/docker-rm-command.html">删除容器：rm</a></h4>
<p><code>docker rm -f container_id</code></p>
<h4 id="暂停恢复容器中进程pauseunpause"><a href="https://www.runoob.com/docker/docker-pause-unpause-command.html">暂停/恢复容器中进程：pause/unpause</a></h4>
<p>如果只是希望容器暂停工作一段时间，比如对容器的文件系统大打个快照，或者 docker host 需要使用 CPU，这是可以执行 docker pause 将其暂停。处于暂停状态的容器不会占用 CPU，直到通过 docker unpause 恢复运行。</p>
<h4 id="创建容器create"><a href="https://www.runoob.com/docker/docker-create-command.html">创建容器：create</a></h4>
<h4 id="进入容器exec"><a href="https://www.runoob.com/docker/docker-exec-command.html">进入容器：exec</a></h4>
<p><code>docker exec -it container_id bash</code></p>
<h3 id="容器操作">容器操作</h3>
<h4 id="查看正在运行的容器ps"><a href="https://www.runoob.com/docker/docker-ps-command.html">查看正在运行的容器：ps</a></h4>
<p><code>docker ps</code></p>
<h4 id="inspect"><a href="https://www.runoob.com/docker/docker-inspect-command.html">inspect</a></h4>
<h4 id="top"><a href="https://www.runoob.com/docker/docker-top-command.html">top</a></h4>
<h4 id="attach"><a href="https://www.runoob.com/docker/docker-attach-command.html">attach</a></h4>
<h4 id="events"><a href="https://www.runoob.com/docker/docker-events-command.html">events</a></h4>
<h4 id="logs"><a href="https://www.runoob.com/docker/docker-logs-command.html">logs</a></h4>
<h4 id="wait"><a href="https://www.runoob.com/docker/docker-wait-command.html">wait</a></h4>
<h4 id="export"><a href="https://www.runoob.com/docker/docker-export-command.html">export</a></h4>
<h4 id="port"><a href="https://www.runoob.com/docker/docker-port-command.html">port</a></h4>
<h3 id="容器rootfs命令">容器rootfs命令</h3>
<h4 id="从容器创建一个新的镜像commit"><a href="https://www.runoob.com/docker/docker-commit-command.html">从容器创建一个新的镜像：commit</a></h4>
<p><code>docker commit container_id mirror_name</code>我们修改过后的容器保存成镜像，重新运行，它可以保持这个变化</p>
<blockquote>
<p>-a :提交的镜像作者；<br>
-c :使用Dockerfile指令来创建镜像；<br>
-m :提交时的说明文字；<br>
-p :在commit时，将容器暂停。</p>
</blockquote>
<h4 id="cp"><a href="https://www.runoob.com/docker/docker-cp-command.html">cp</a></h4>
<h4 id="diff"><a href="https://www.runoob.com/docker/docker-diff-command.html">diff</a></h4>
<h3 id="镜像仓库">镜像仓库</h3>
<h4 id="login"><a href="https://www.runoob.com/docker/docker-login-command.html">login</a></h4>
<h4 id="拉取或者更新镜像pull"><a href="https://www.runoob.com/docker/docker-pull-command.html">拉取或者更新镜像：pull</a></h4>
<p><code>docker pull nginx（等效于nginx:latest）</code></p>
<h4 id="push"><a href="https://www.runoob.com/docker/docker-push-command.html">push</a></h4>
<h4 id="search"><a href="https://www.runoob.com/docker/docker-search-command.html">search</a></h4>
<p>命令可以搜索 Docker Hub 中的镜像。</p>
<h3 id="本地镜像管理">本地镜像管理</h3>
<h4 id="查看镜像列表images"><a href="https://www.runoob.com/docker/docker-images-command.html">查看镜像列表：images</a></h4>
<p><code>docker images</code></p>
<h4 id="删除镜像rmi"><a href="https://www.runoob.com/docker/docker-rmi-command.html">删除镜像：rmi</a></h4>
<p><code>docker rmi mirror_name</code></p>
<h4 id="tag"><a href="https://www.runoob.com/docker/docker-tag-command.html">tag</a></h4>
<h4 id="使用dockerfile构建镜像build"><a href="https://www.runoob.com/docker/docker-build-command.html">使用Dockerfile构建镜像：build</a></h4>
<p><code>docker build -t mirror_name 存放Dockerfile的文件夹</code></p>
<h4 id="history"><a href="https://www.runoob.com/docker/docker-history-command.html">history</a></h4>
<h4 id="镜像保存为tarsave"><a href="https://www.runoob.com/docker/docker-save-command.html">镜像保存为tar：save</a></h4>
<p><code>docker save mirror_name &gt; .tar</code></p>
<h4 id="从tar加载镜像load"><a href="https://www.runoob.com/docker/docker-load-command.html">从tar加载镜像：load</a></h4>
<p><code>docker load &lt; .tar</code></p>
<h4 id="import"><a href="https://www.runoob.com/docker/docker-import-command.html">import</a></h4>
<h3 id="infoversion">info|version</h3>
<h4 id="info"><a href="https://www.runoob.com/docker/docker-info-command.html">info</a></h4>
<h4 id="version"><a href="https://www.runoob.com/docker/docker-version-command.html">version</a></h4>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker安装Hadoop]]></title>
        <id>https://dingtom.github.io/post/docker-an-zhuang-hadoop/</id>
        <link href="https://dingtom.github.io/post/docker-an-zhuang-hadoop/">
        </link>
        <updated>2020-11-28T13:53:36.000Z</updated>
        <content type="html"><![CDATA[<p>Docker、Java、Scala、Hadoop、 Hbase、Spark。<br>
集群共有5台机器，主机名分别为 h01、h02、h03、h04、h05。其中 h01 为 master，其他的为 slave。<br>
JDK 1.8、Scala 2.11.6、Hadoop 3.2.1、Hbase 2.1.3、Spark 2.4.0</p>
<h1 id="ubuntu-安装-docker">Ubuntu 安装 Docker</h1>
<h2 id="在-ubuntu-下安装-docker-的时候需在管理员的账号下操作">在 Ubuntu 下安装 Docker 的时候需在管理员的账号下操作。</h2>
<p><code>wget -qO- https://get.docker.com/ | sh</code></p>
<h2 id="以-sudo-启动-docker-服务">以 sudo 启动 Docker 服务。</h2>
<p><code>sudo service docker start</code></p>
<h2 id="显示-docker-中所有正在运行的容器">显示 Docker 中所有正在运行的容器</h2>
<p><code>sudo docker ps</code><br>
现在的 Docker 网络能够提供 DNS 解析功能，使用如下命令为接下来的 Hadoop 集群单独构建一个虚拟的网络。<br>
<code>sudo docker network create --driver=bridge hadoop</code><br>
以上命令创建了一个名为 Hadoop 的虚拟桥接网络，该虚拟网络内部提供了自动的DNS解析服务。## 查看 Docker 中的网络<br>
<code>sudo docker network ls</code><br>
可以看到刚刚创建的名为 hadoop 的虚拟桥接网络。</p>
<h2 id="查找-ubuntu-容器">查找 ubuntu 容器</h2>
<p><code>sudo docker search ubuntu</code></p>
<h2 id="下载-ubuntu-1604-版本的镜像文件">下载 ubuntu 16.04 版本的镜像文件</h2>
<p><code>sudo docker pull ubuntu:16.04</code></p>
<h2 id="根据镜像启动一个容器">根据镜像启动一个容器</h2>
<p><code>sudo docker run -it ubuntu:16.04 /bin/bash</code><br>
可以看出 shell 已经是容器的 shell 了</p>
<h2 id="退出容器">退出容器</h2>
<p><code>exit</code></p>
<h2 id="查看本机上所有的容器">查看本机上所有的容器</h2>
<p><code>sudo docker ps -a</code></p>
<h2 id="启动容器">启动容器</h2>
<p><code>sudo docker start fab4da838c2f</code></p>
<h2 id="关闭容器">关闭容器</h2>
<p><code>sudo docker stop fab4da838c2f</code></p>
<h1 id="安装-java-与-scala">安装 Java 与 Scala</h1>
<p>在当前容器中将配置配好，导入出为镜像。以此镜像为基础创建五个容器，并赋予 hostname<br>
进入 h01 容器，启动 Hadoop。</p>
<h2 id="进入-ubuntu-容器">进入 Ubuntu 容器</h2>
<p><code>sudo docker exec -it fab4da838c2f /bin/bash</code></p>
<h2 id="修改-apt-源">修改 apt 源</h2>
<p>备份源<br>
<code>cp /etc/apt/sources.list /etc/apt/sources_init.list</code><br>
先删除旧源文件<br>
<code>rm /etc/apt/sources.list</code><br>
这个时候没有 vim 工具，使用 echo 命令将源写入新文件</p>
<pre><code>echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial main
deb-src http://mirrors.aliyun.com/ubuntu/ xenial main
deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main
deb http://mirrors.aliyun.com/ubuntu/ xenial universe
deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe
deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe
deb http://mirrors.aliyun.com/ubuntu/ xenial-security main
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main
deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe&quot;
&gt; /etc/apt/sources.list
</code></pre>
<h2 id="更新源">更新源</h2>
<p><code>apt update</code></p>
<h2 id="安装-jdk-18">安装 jdk 1.8</h2>
<p>​<code>apt install openjdk-8-jdk</code><br>
测试<br>
​<code>java -version</code></p>
<h2 id="安装-scala">安装 Scala</h2>
<p>​<code>apt install scala</code><br>
测试<br>
​<code>scala</code></p>
<h2 id="安装-vim-与-网络工具包">安装 Vim 与 网络工具包</h2>
<p>安装 vim，用来编辑文件<br>
​<code>apt install vim</code><br>
安装 net-tools<br>
​<code>apt install net-tools</code></p>
<h2 id="安装-ssh">安装 SSH</h2>
<p>安装 SSH，并配置免密登录，由于后面的容器之间是由一个镜像启动的，所以在当前容器里配置 SSH 自身免密登录就 OK 了。</p>
<p>安装 SSH<br>
​<code>apt-get install openssh-server</code><br>
安装 SSH 的客户端<br>
​<code>apt-get install openssh-client</code><br>
进入当前用户的用户根目录<br>
​<code>cd ~</code><br>
生成密钥，一直回车就行<br>
​<code>ssh-keygen -t rsa -P &quot;&quot;</code><br>
生成的密钥在当前用户根目录下的 .ssh 文件夹中以 . 开头的文件与文件夹 ls 是看不懂的，需要<code>ls -al</code> 才能查看。</p>
<p>将公钥追加到 authorized_keys 文件中<br>
​<code>cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys</code><br>
启动 SSH 服务<br>
​<code>service ssh start</code><br>
免密登录自己<br>
​<code>ssh 127.0.0.1</code><br>
修改 .bashrc 文件，启动 shell 的时候，自动启动 SSH 服务<br>
​<code>vim ~/.bashrc</code><br>
添加一行<br>
​<code>service ssh start</code></p>
<h1 id="安装-hadoop">安装 Hadoop</h1>
<h2 id="下载-hadoop">下载 Hadoop</h2>
<p>​<code>wget http://mirrors.hust.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz</code></p>
<h2 id="解压">解压</h2>
<p>到 /usr/local 目录下面并重命名文件夹<br>
​<code>tar -zxvf hadoop-3.2.1.tar.gz -C /usr/local/</code><br>
​<code>cd /usr/local/</code><br>
​<code>mv hadoop-3.2.1 hadoop</code></p>
<h2 id="添加环境变量">添加环境变量</h2>
<p><code>vim /etc/profile</code><br>
追加以下内容，JAVA_HOME 为 JDK 安装路径，使用 apt 安装就是这个，用 <code>update-alternatives --config java</code>可查看</p>
<pre><code>#java
export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export JRE_HOME=${JAVA_HOME}/jre    
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib    
export PATH=${JAVA_HOME}/bin:$PATH
#hadoop
export HADOOP_HOME=/usr/local/hadoop
export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin
export HADOOP_COMMON_HOME=$HADOOP_HOME 
export HADOOP_HDFS_HOME=$HADOOP_HOME 
export HADOOP_MAPRED_HOME=$HADOOP_HOME
export HADOOP_YARN_HOME=$HADOOP_HOME 
export HADOOP_INSTALL=$HADOOP_HOME 
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native 
export HADOOP_CONF_DIR=$HADOOP_HOME 
export HADOOP_LIBEXEC_DIR=$HADOOP_HOME/libexec 
export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native:$JAVA_LIBRARY_PATH
export HADOOP_CONF_DIR=$HADOOP_PREFIX/etc/hadoop
export HDFS_DATANODE_USER=root
export HDFS_DATANODE_SECURE_USER=root
export HDFS_SECONDARYNAMENODE_USER=root
export HDFS_NAMENODE_USER=root
export YARN_RESOURCEMANAGER_USER=root
export YARN_NODEMANAGER_USER=root
</code></pre>
<p>使环境变量生效<br>
​<code>source /etc/profile</code></p>
<h2 id="修改配置文件">修改配置文件</h2>
<p>在目录 /usr/local/hadoop/etc/hadoop 下，修改 hadoop-env.sh 文件，在文件末尾添加以下信息<br>
​<code>cd /usr/local/hadoop/etc/hadoop</code><br>
​<code>vim hadoop-env.sh</code></p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export HDFS_NAMENODE_USER=root
export HDFS_DATANODE_USER=root
export HDFS_SECONDARYNAMENODE_USER=root
export YARN_RESOURCEMANAGER_USER=root
export YARN_NODEMANAGER_USER=root
</code></pre>
<p>修改 core-site.xml，修改为<br>
​<code>vim core-site.xml</code></p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;fs.default.name&lt;/name&gt;
        &lt;value&gt;hdfs://h01:9000&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
        &lt;value&gt;/home/hadoop3/hadoop/tmp&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p><code>chmod 777 /home/hadoop3/hadoop/tmp</code><br>
修改 hdfs-site.xml，修改为<br>
​<code>vim hdfs-site.xml</code></p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;2&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;
        &lt;value&gt;/home/hadoop3/hadoop/hdfs/name&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.namenode.data.dir&lt;/name&gt;
        &lt;value&gt;/home/hadoop3/hadoop/hdfs/data&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p>修改 mapred-site.xml，修改为<br>
​<code>vim mapred-site.xml</code></p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
        &lt;value&gt;yarn&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;
        &lt;value&gt;
            /usr/local/hadoop/etc/hadoop,
            /usr/local/hadoop/share/hadoop/common/*,
            /usr/local/hadoop/share/hadoop/common/lib/*,
            /usr/local/hadoop/share/hadoop/hdfs/*,
            /usr/local/hadoop/share/hadoop/hdfs/lib/*,
            /usr/local/hadoop/share/hadoop/mapreduce/*,
            /usr/local/hadoop/share/hadoop/mapreduce/lib/*,
            /usr/local/hadoop/share/hadoop/yarn/*,
            /usr/local/hadoop/share/hadoop/yarn/lib/*
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p>修改 yarn-site.xml，修改为<br>
​<code>vim yarn-site.xml</code></p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
        &lt;value&gt;h01&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p>修改 worker 为<br>
​<code>vim workers</code></p>
<pre><code>h01
h02
h03
h04
h05
</code></pre>
<p>此时，hadoop已经配置好了</p>
<h2 id="在-docker-中启动集群">在 Docker 中启动集群</h2>
<h3 id="将当前容器导出为镜像">将当前容器导出为镜像</h3>
<p>​<code>exit</code><br>
​<code>sudo docker commit -m &quot;hadoop&quot; -a &quot;tomding&quot; fab4da838c2f newuhadoop</code><br>
查看镜像<br>
​<code>sudo docker images</code></p>
<h3 id="启动-5-个终端">启动 5 个终端</h3>
<p>启动 h01 做 master 节点，所以暴露了端口，以供访问 web 页面，--network hadoop 参数是将当前容器加入到名为 hadoop 的虚拟桥接网络中，此网站提供自动的 DNS 解析功能<br>
​<code>sudo docker run -it --network hadoop -h &quot;h01&quot; --name &quot;h01&quot; -p 9870:9870 -p 8088:8088 newuhadoop /bin/bash</code><br>
<code>sudo docker run -it --network hadoop -h &quot;h02&quot; --name &quot;h02&quot; newuhadoop /bin/bash</code><br>
​<code>sudo docker run -it --network hadoop -h &quot;h03&quot; --name &quot;h03&quot; newuhadoop /bin/bash</code><br>
​<code>sudo docker run -it --network hadoop -h &quot;h04&quot; --name &quot;h04&quot; newuhadoop /bin/bash</code><br>
​<code>sudo docker run -it --network hadoop -h &quot;h05&quot; --name &quot;h05&quot; newuhadoop /bin/bash</code></p>
<h3 id="在-h01-主机中启动-haddop-集群">在 h01 主机中，启动 Haddop 集群</h3>
<p>先进行格式化操作，不格式化操作，hdfs会起不来<br>
​<code>cd /usr/local/hadoop/bin</code><br>
​<code>./hadoop namenode -format</code><br>
进入 hadoop 的 sbin 目录<br>
​<code>cd /usr/local/hadoop/sbin/</code><br>
启动<br>
​<code>./start-all.sh</code><br>
查看分布式文件系统的状态<br>
​<code>cd /usr/local/hadoop/bin</code><br>
​<code>./hadoop dfsadmin -report</code></p>
<h2 id="运行内置wordcount例子">运行内置WordCount例子</h2>
<p>把license作为需要统计的文件<br>
<code>cd /usr/local/hadoop</code><br>
<code>cat LICENSE.txt &gt; file1.txt</code><br>
在 HDFS 中创建 input 文件夹<br>
​<code>cd /usr/local/hadoop/bin</code><br>
<code>./hadoop fs -mkdir /input</code><br>
上传 file1.txt 文件到 HDFS 中<br>
<code>./hadoop fs -put ../file1.txt /input</code><br>
查看 HDFS 中 input 文件夹里的内容<br>
<code>./hadoop fs -ls /input</code><br>
运作 wordcount 例子程序<br>
<code>./hadoop jar ../share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar wordcount /input /output</code><br>
查看 HDFS 中的 /output 文件夹的内容<br>
<code>./hadoop fs -ls /output</code><br>
查看 part-r-00000 文件的内容<br>
<code>./hadoop fs -cat /output/part-r-00000</code><br>
Hadoop 部分结束了</p>
<h1 id="安装-hbase">安装 Hbase</h1>
<p>在 Hadoop 集群的基础上安装 Hbase</p>
<h2 id="下载-hbase-213">下载 Hbase 2.1.3</h2>
<p>root@h01:~# <code>wget http://archive.apache.org/dist/hbase/2.1.3/hbase-2.1.3-bin.tar.gz</code></p>
<h2 id="解压-2">解压</h2>
<p>到 /usr/local 目录下面<br>
​<code>tar -zxvf hbase-2.1.3-bin.tar.gz -C /usr/local/</code></p>
<h2 id="修改环境变量文件">修改环境变量文件</h2>
<p>​<code>vim /etc/profile</code></p>
<pre><code>export HBASE_HOME=/usr/local/hbase-2.1.3
export PATH=$PATH:$HBASE_HOME/bin
</code></pre>
<p>​<code>source /etc/profile</code><br>
使用 ssh h02/3/4/5 进入其他四个容器，依次在 /etc/profile 文件后追加那两行环境变量</p>
<p>在目录 /usr/local/hbase-2.1.3/conf 修改配置<br>
​<code>cd /usr/local/hbase-2.1.3/conf</code><br>
修改 hbase-env.sh，追加<br>
​<code>vim hbase-env.sh</code></p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export HBASE_MANAGES_ZK=true
</code></pre>
<h2 id="修改配置文件-2">修改配置文件</h2>
<p>修改 hbase-site.xml 为<br>
​<code>vim hbase-site.xml</code></p>
<pre><code>&lt;configuration&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.rootdir&lt;/name&gt;
                &lt;value&gt;hdfs://h01:9000/hbase&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
                &lt;value&gt;true&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.master&lt;/name&gt;
                &lt;value&gt;h01:60000&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
                &lt;value&gt;h01,h02,h03,h04,h05&lt;/value&gt;
        &lt;/property&gt;
        &lt;property&gt;
                &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
                &lt;value&gt;/home/hadoop/zoodata&lt;/value&gt;
        &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<p>修改 regionservers 文件为<br>
​<code>vim regionservers</code></p>
<pre><code>h01
h02
h03
h04
h05
</code></pre>
<p>使用 scp 命令将配置好的 Hbase 复制到其他 4 个容器中<br>
<code>scp -r /usr/local/hbase-2.1.3 root@h02:/usr/local/</code><br>
<code>scp -r /usr/local/hbase-2.1.3 root@h03:/usr/local/</code><br>
<code>scp -r /usr/local/hbase-2.1.3 root@h04:/usr/local/</code><br>
<code>scp -r /usr/local/hbase-2.1.3 root@h05:/usr/local/</code></p>
<h2 id="启动-hbase">启动 Hbase</h2>
<p><code>cd /usr/local/hbase-2.1.3/bin</code><br>
<code>./start-hbase.sh</code><br>
打开 Hbase 的 shell<br>
<code>hbase shell</code></p>
<h1 id="安装-spark">安装 Spark</h1>
<p>在 Hadoop 的基础上安装 Spark</p>
<h2 id="下载-spark-240">下载 Spark 2.4.0</h2>
<p>​<code>wget https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz</code></p>
<h2 id="解压-3">解压</h2>
<p>到 /usr/local 目录下面<br>
<code>tar -zxvf spark-2.4.0-bin-hadoop2.7.tgz -C /usr/local/</code><br>
修改文件夹的名字<br>
<code>cd /usr/local/</code><br>
<code>mv spark-2.4.0-bin-hadoop2.7 spark-2.4.0</code></p>
<h2 id="修改-环境变量">修改 环境变量</h2>
<p>​<code>vim /etc/profile</code></p>
<pre><code>export SPARK_HOME=/usr/local/spark-2.4.0
export PATH=$PATH:$SPARK_HOME/bin
</code></pre>
<p><code>source /etc/profile</code></p>
<p>使用 ssh h02/3/4/5 可进入其他四个容器，依次在 /etc/profile 文件后追加那两行环境变量</p>
<p>在目录 /usr/local/spark-2.4.0/conf 修改配置<br>
​<code>cd /usr/local/spark-2.4.0/conf</code><br>
修改文件名<br>
​<code>mv spark-env.sh.template spark-env.sh</code><br>
修改 spark-env.sh，追加<br>
​<code>vim spark-env.sh</code></p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export HADOOP_HOME=/usr/local/hadoop
export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop
export SCALA_HOME=/usr/share/scala

export SPARK_MASTER_HOST=h01
export SPARK_MASTER_IP=h01
export SPARK_WORKER_MEMORY=4g
</code></pre>
<p>修改文件名<br>
​<code>mv slaves.template slaves</code><br>
修改 slaves 如下<br>
<code>vim slaves</code></p>
<pre><code>h01
h02
h03
h04
h05
</code></pre>
<p>使用 scp 命令将配置好的 Hbase 复制到其他 4 个容器中<br>
<code>scp -r /usr/local/spark-2.4.0 root@h02:/usr/local/</code><br>
<code>scp -r /usr/local/spark-2.4.0 root@h03:/usr/local/</code><br>
<code>scp -r /usr/local/spark-2.4.0 root@h04:/usr/local/</code><br>
<code>scp -r /usr/local/spark-2.4.0 root@h05:/usr/local/</code></p>
<h2 id="启动-spark">启动 Spark</h2>
<p><code>cd /usr/local/spark-2.4.0/sbin</code><br>
<code>./start-all.sh</code></p>
<p>其他<br>
3.1 HDFS 重格式化问题<br>
参考 https://blog.csdn.net/gis_101/article/details/52821946<br>
<s>重新格式化意味着集群的数据会被全部删除，格式化前需考虑数据备份或转移问题</s>；<br>
先删除主节点（即namenode节点），Hadoop的临时存储目录tmp、namenode存储永久性元数据目录dfs/name、Hadoop系统日志文件目录log 中的内容 （注意是删除目录下的内容不是目录）；<br>
删除所有数据节点(即datanode节点) ，Hadoop的临时存储目录tmp、namenode存储永久性元数据目录dfs/name、Hadoop系统日志文件目录log 中的内容；</p>
<p>格式化一个新的分布式文件系统：<br>
<code>cd /usr/local/hadoop/bin</code><br>
<code>./hadoop namenode -format</code></p>
<p>注意事项</p>
<blockquote>
<p>Hadoop的临时存储目录tmp（即core-site.xml配置文件中的hadoop.tmp.dir属性，默认值是/tmp/hadoop-{user.name}），<br>
如果没有配置hadoop.tmp.dir属性，那么hadoop格式化时将会在/tmp目录下创建一个目录，例如在cloud用户下安装配置hadoop，那么Hadoop的临时存储目录就位于/tmp/hadoop-cloud目录下Hadoop的namenode元数据目录（即hdfs-site.xml配置文件中的dfs.namenode.name.dir属性，默认{hadoop.tmp.dir}/dfs/name），<br>
同样如果没有配置该属性，那么hadoop在格式化时将自行创建。必须注意的是在格式化前必须清楚所有子节点（即DataNode节点）dfs/name下的内容，否则在启动hadoop时子节点的守护进程会启动失败。这是由于，每一次format主节点namenode，dfs/name/current目录下的VERSION文件会产生新的clusterID、namespaceID。<br>
但是如果子节点的dfs/name/current仍存在，hadoop格式化时就不会重建该目录，因此形成子节点的clusterID、namespaceID与主节点（即namenode节点）的clusterID、namespaceID不一致。最终导致hadoop启动失败。</p>
</blockquote>
<p>进入：<br>
<code>​sudo docker run -it --network hadoop -h &quot;h01&quot; --name &quot;h01&quot; -p 9870:9870 -p 8088:8088 master /bin/bash</code><br>
<code>sudo docker run -it --network hadoop -h &quot;h02&quot; --name &quot;h02&quot; slave1 /bin/bash</code><br>
<code>​sudo docker run -it --network hadoop -h &quot;h03&quot; --name &quot;h03&quot; slave2 /bin/bash</code><br>
<code>​sudo docker run -it --network hadoop -h &quot;h04&quot; --name &quot;h04&quot; slave3 /bin/bash</code><br>
<code>​sudo docker run -it --network hadoop -h &quot;h05&quot; --name &quot;h05&quot; slave14 /bin/bash</code><br>
退出：<br>
<code>sudo docker commit -m &quot;master&quot; -a &quot;tomding&quot; h01 master</code><br>
<code>sudo docker commit -m &quot;slave1&quot; -a &quot;tomding&quot; h02 slave1</code><br>
<code>sudo docker commit -m &quot;slave2&quot; -a &quot;tomding&quot; h03 slave2</code><br>
<code>sudo docker commit -m &quot;slave3&quot; -a &quot;tomding&quot; h04 slave3</code><br>
<code>sudo docker commit -m &quot;slave4&quot; -a &quot;tomding&quot; h05 slave4</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[特征统计]]></title>
        <id>https://dingtom.github.io/post/ji-zhong-qu-shi-fen-xi-chi-san-cheng-du-fen-xi/</id>
        <link href="https://dingtom.github.io/post/ji-zhong-qu-shi-fen-xi-chi-san-cheng-du-fen-xi/">
        </link>
        <updated>2020-11-27T09:10:13.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/dingtom/python/blob/master/%E7%BB%9F%E8%AE%A1.ipynb">https://github.com/dingtom/python/blob/master/%E7%BB%9F%E8%AE%A1.ipynb</a><br>
`</p>
<h2 id="特征统计">特征统计</h2>
<p>特征统计可能是数据科学中最常用的统计学概念。它是你在研究数据集时经常使用的统计技术，包括偏差、方差、平均值、中位数、百分数等等。</p>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-f6ad8aaac18ba88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="箱型图" loading="lazy"></figure>
<p>中间的直线表示数据的中位数（对异常值更具有鲁棒性）。<br>
第一个四分位数（即数据中的25%要低于该值）。<br>
第三个四分位数（即数据中的75%要低于该值）。</p>
<ul>
<li>当箱形图很短时，就意味着很多数据点是相似的，因为很多值是在一个很小的范围内分布;</li>
<li>如果中位数接近了底部，那么大部分的数据具有较低的值。基本上，如果中位线不在框的中间，那么就表明了是偏斜数据;</li>
<li>如果框上下两边的线很长表示数据<s>具有很高的标准偏差和方差</s>，意味着这些值被分散了，并且变化非常大。</li>
</ul>
<h1 id="概率分布">概率分布</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-4c7b9565a240309f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="均匀分布" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-34e1e11b3edf40ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正态分布" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-ad02a5cea35a9122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泊松分布" loading="lazy"></p>
<h1 id="频数与频率">频数与频率</h1>
<ul>
<li>预数，指一组数据中类别变量的每个不同取值出现的次数。</li>
<li>频率，指每个类别变量的频数与总次数的比值，通常采用百分数表示。</li>
</ul>
<pre><code># 计算鸢尾花数据集中每个类别出现的频数
frequency = df[&quot;types&quot;].value_counts() / len(df)
print(frequency.shape)
print(frequency)
plt.bar([1, 2, 3], frequency)
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-e6622ef2938a600b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="集中趋势分析">集中趋势分析</h1>
<ul>
<li>均值</li>
<li>中位数</li>
<li>众数</li>
</ul>
<blockquote>
<p>”数值变量”通常使用均值与中值表示集中趋势。<br>
“类别变量”通常使用众数表示集中趋势。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-6c6a67d920539438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
记忆方法：哪边的尾巴长，就叫做 “X偏”。左边的尾巴长，就叫做“左偏”；右边的尾巴长，就叫做“右偏”。并且均值离着尾巴最近，中位数总是在最中间，众数离着尾巴最远。</p>
</blockquote>
<ul>
<li>分位数，将数据从小到大排列，通过n-1个分位数将数据分为n个区间，使得每个区间的数值的个数相等(近似相等)。</li>
</ul>
<pre><code>mean = df[&quot;sepal length (cm)&quot;].mean()  
median = df[&quot;sepal length (cm)&quot;].median() 
print('mean, median',mean, median)  
# 由于series中没有专门计算众数的函数， # scipy的stats模块中，可以计算众数  
from scipy import stats  
t = stats.mode(df[&quot;sepal length (cm)&quot;])  
# 注意：t展示的类字典格式的数据类型，mode展示众数，count用于展示众数出现的次数   
print(t.mode, t.count)  
</code></pre>
<p>mean, median 5.843333333333335 5.8<br>
[5.] [10]</p>
<pre><code>sns.distplot(df[&quot;sepal length (cm)&quot;])  
plt.axvline(mean,ls=&quot;-&quot;,color=&quot;r&quot;,label=&quot;均值&quot;) 
plt.axvline(median,ls=&quot;-&quot;,color=&quot;g&quot;,label=&quot;中值&quot;)
plt.axvline(t.mode,ls=&quot;-&quot;,color=&quot;indigo&quot;,label=&quot;众数&quot;) 
plt.legend(loc=&quot;best&quot;)
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/18339009-8112dca9a0d8c36f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<pre><code># 分位数
x = np.arange(10,20) 
q = np.quantile(x,[0.25,0.5,0.75])
plt.figure(figsize=(15,4))
plt.xticks(x)
plt.plot(x,np.zeros(len(x)),ls=&quot;&quot;,marker=&quot;D&quot;,ms=15,label=&quot;元素值&quot;)
plt.plot(q,np.zeros(len(q)),ls=&quot;&quot;,marker=&quot;X&quot;,ms=15,label=&quot;四分位值&quot;)
for v in q:     
    plt.text(v,0.01,v,fontsize=15)
plt.legend()
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://upload-images.jianshu.io/upload_images/18339009-3e9ebd3e4b3a505e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="离散程度分析">离散程度分析</h1>
<ul>
<li>
<p>极差，极差指一组数据中，最大值与最小值之差。</p>
</li>
<li>
<p>方差，方差体现的是一组数据中，每个元素与均值偏离的大小。</p>
</li>
<li>
<p>标准差，标准差标准差为方差的开方。</p>
</li>
</ul>
<pre><code>sub = df[&quot;sepal length (cm)&quot;].max()  - df[&quot;sepal length (cm)&quot;].min() 
var = df[&quot;sepal length (cm)&quot;].var()
std = df[&quot;sepal length (cm)&quot;].std()
print(sub, var, std)
</code></pre>
<p>3.6000000000000005 0.6856935123042505 0.8280661279778629</p>
<pre><code>plt.figure(figsize=(15,4))
plt.ylim(-0.5,1.5)
plt.plot(df[&quot;sepal length (cm)&quot;],np.zeros(len(df)),ls=&quot;&quot;,marker=&quot;o&quot;,ms=10,color=&quot;g&quot;,label=&quot;花瓣长度&quot;)
plt.plot(df[&quot;sepal width (cm)&quot;],np.ones(len(df)),ls=&quot;&quot;,marker=&quot;o&quot;,ms=10,color=&quot;b&quot;,label=&quot;花瓣宽度&quot;)
         
plt.axvline(df[&quot;sepal length (cm)&quot;].mean(),ls=&quot;--&quot;,color=&quot;g&quot;,label=&quot;花瓣长度均值&quot;)
plt.axvline(df[&quot;sepal width (cm)&quot;].mean(),ls=&quot;-&quot;,color=&quot;b&quot;,label=&quot;花瓣宽度均值&quot;)

plt.legend()
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://upload-images.jianshu.io/upload_images/18339009-1e63ba109f5053ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="分布形状">分布形状</h1>
<ul>
<li>偏度，偏度是统计数据分布偏斜方向和程度的度量，是统计数据分布非对称程度的数字特征。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-1d29f1c0af7f7546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></li>
</ul>
<h2 id="偏度skewness">偏度（Skewness）</h2>
<p>Definition:是描述数据分布形态的统计量，其描述的是某总体取值分布的对称性，<strong>简单来说就是数据的不对称程度。</strong><br>
偏度是三阶中心距计算出来的。<br>
（1）Skewness = 0 ，分布形态与正态分布偏度相同。<br>
（2）Skewness &gt; 0 ，正偏差数值较大，为正偏或右偏。长尾巴拖在右边，数据右端有较多的极端值。<br>
（3）Skewness &lt; 0 ，负偏差数值较大，为负偏或左偏。长尾巴拖在左边，数据左端有较多的极端值。<br>
（4）数值的绝对值越大，表明数据分布越不对称，偏斜程度大。<br>
计算公式：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>k</mi><mi>e</mi><mi>w</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>E</mi><mo>[</mo><mo>(</mo><mo>(</mo><mi>x</mi><mo>−</mo><mi>E</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><msqrt><mrow><mi>D</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msqrt><mo>)</mo><msup><mo>)</mo><mn>3</mn></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">Skewness=E[((x-E(x))/(\sqrt{D(x)}))^3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span><br>
| Skewness| 越大，分布形态偏移程度越大。</p>
<h2 id="峰度kurtosis">峰度（Kurtosis）</h2>
<p>Definition:偏度是描述某变量所有取值分布形态陡缓程度的统计量，<strong>简单来说就是数据分布顶的尖锐程度。</strong><br>
峰度是四阶标准矩计算出来的。<br>
（1）Kurtosis=0 与正态分布的陡缓程度相同。<br>
（2）Kurtosis&gt;0 比正态分布的高峰更加陡峭——尖顶峰<br>
（3）Kurtosis&lt;0 比正态分布的高峰来得平台——平顶峰<br>
计算公式：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>u</mi><mi>r</mi><mi>t</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>s</mi><mo>=</mo><mi>E</mi><mo>[</mo><mo>(</mo><mo>(</mo><mi>x</mi><mo>−</mo><mi>E</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><msqrt><mo>(</mo></msqrt><mi>D</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>)</mo><msup><mo>)</mo><mn>4</mn></msup><mo>]</mo><mo>−</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">Kurtosis=E[ ( (x-E(x))/ (\sqrt(D(x))) )^4 ]-3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mopen" style="padding-left:1em;">(</span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></p>
<ul>
<li>峰度， 峰度是描述总体中所有取值分布形态陡缓程度的统计量，可以讲峰度理解为数据分布的高矮程度，峰度的比较是相对于标准正态分布的。</li>
</ul>
<blockquote>
<p>对于标准正态分布，峰度为0。<br>
如果峰度大于0，说明数据在分布上比标准正态分布密集，方差(标准差)较小。<br>
如果峰度小于0，说明数据在分布上比标准正态分布分散，方差(标准差)较大。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-9828218e64b397ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
</blockquote>
<pre><code>t1 = np.random.randint(1,11,100)
t2 = np.random.randint(11,21,500)
t3 = np.concatenate([t1,t2])
print(t3.shape)
left_skew = pd.Series(t3)

t1 = np.random.randint(1,11,500)
t2 = np.random.randint(11,21,100)
t3 = np.concatenate([t1,t2])
right_skew = pd.Series(t3)
print(left_skew.skew(),right_skew.skew())

sns.kdeplot(standard_normal,label=&quot;标准正态分布&quot;)
sns.kdeplot(df[&quot;sepal length (cm)&quot;],label=&quot;花萼长度&quot;)
sns.kdeplot(df[&quot;sepal width (cm)&quot;],label=&quot;花萼宽度&quot;)

sns.kdeplot(left_skew,shade=True,label=&quot;左偏&quot;) 
sns.kdeplot(right_skew,shade=True,label=&quot;右偏&quot;) 
plt.legend()

print(&quot;Kurtosis: %f&quot; % Train_data['price'].kurt())
sns.distplot(Train_data.kurt(),color='orange',axlabel ='Kurtness')

# fig, axes=plt.subplots(nrows=2, ncols=1, figsize=(14,6)) 
# axes[0].hist(left_skew,label=&quot;左偏&quot;)
# axes[1].hist(right_skew,label=&quot;右偏&quot;)
plt.legend()
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://upload-images.jianshu.io/upload_images/18339009-668cc417ccd32acc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AB测试]]></title>
        <id>https://dingtom.github.io/post/ab-ce-shi/</id>
        <link href="https://dingtom.github.io/post/ab-ce-shi/">
        </link>
        <updated>2020-11-27T07:23:37.000Z</updated>
        <content type="html"><![CDATA[<p>将Web或App界面或流程的两个或多个版本，<s>在同一时间维度</s>，分别让两个或多个属性或组成成分<s>相同（相似）<s>的访客群组访同，收集各群组的</s>用户体验数据和业务数据</s>，最后分析评估出<s>最好版本正式采用</s>。</p>
<h2 id="主要应用场景">主要应用场景：</h2>
<p><s>界面设计、算法优化</s>。</p>
<h2 id="流程">流程：</h2>
<p>1、分析实际业务场景，明确<s>改进关键点。</s><br>
2、与项目经理<s>确定优化目标，设计优化方案。</s><br>
3、根据优化目标及方案搭建<s>数据分析指标体系，明确数据口径。</s><br>
4、由UI设计师或算法工程师根据方案<s>完成样例开发，并设定数据埋点。</s><br>
5、调整流量池，在<s>同一时间内对目标用户开始测试</s>。<br>
6、根据时间进度及时收集数据，并根据数据情况<s>调整流量池或重新进行测试</s><br>
7、经过多次试验取得成功后，确定新版本功能，<s>正式发布。</s></p>
<h2 id="注意事项">注意事项：</h2>
<ul>
<li>
<p>忽略个别异常<br>
AB测试要分析<s>参与测试用户的整体分布情况</s>，而不仅仅是个别用户的情况。<s>如出现了个别异常值，重点是需要保证整体分布没有大的异常即可继续进行AB测试</s>，对于异常值，可以重直关注其产生的根本原因，可能是其他可优化直。</p>
</li>
<li>
<p>数据有效性<br>
正常情况下，在推进AB测试时，<s>前三天的数据波动会比教大，不建议直接使用</s>，测试需要大约7-14天为周期进行推进，切不可心急。对不同行业应用的产品，也要根据用户使用周期进行调整，~~一定要完整覆盖整个户周期。~~如电商平台在进行AB测试时，就需要注意工作日与节假日的影响不同，需要将测试周期定在一周以上。</p>
</li>
<li>
<p>用户反馈反方向发展<br>
在这种情况下，<s>先缩小测试用的流量池</s>，减少测试的用户数量；另一方面，分析目前的用户反馈情况，跟进反馈背后<s>问题的真实原因，优化调整AB测试方案</s>。千万<s>不要着急直接停止AB测试</s>，认真分析问题产生的根源，待情况明确，新方案制定后继续进行AB测试。</p>
</li>
</ul>
<h2 id="灰度测试">灰度测试：</h2>
<p>由于调整版本对企业影响极大，设定目标中的两个版本可能都不是有效版本，故不能将所有用户直接一分为二全部进行AB测试，对此可以采用灰度发布的方式，即<s>只选择其中极小部分用户进行AB測试，并逐步推广到所有用户。</s></p>
<h2 id="abn测试">ABN测试：</h2>
<p>在AB测试设计初期，可能提出了多种优化版本，对此并不一定只能要求其中一种版本进行AB测试，可<s>同时选择类型相同的版本同时进行AB测试，此类方法称为ABN试。</s><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e43f7922afc4d4ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="anb-测试">ANB  测试：</h2>
<p>在进AB测试过程中，可能会有个别特因素对测试结果有异常明确的影响，如遇到有特殊用户刷量等。为了免此类情况的发生对AB测试产生影响，可以考虑进行ANB测试（AA测试的加强版），<s>避免偶然因素对目标产生误差。</s><br>
具体原理如下图：<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e99a4516ae78c68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="多维测试">多维测试</h2>
<p>可以在多个维度内同时推进AB测试，但是<s>一定要保任意两个维度内互不影响</s><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e6099c32a5954649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="数据分析师需要扮演的角色">数据分析师需要扮演的角色：</h2>
<p>1、针对业务场景，<s>制定专题分析，明确分析目标</s><br>
2、AB测试初期，分析业务场景，<s>提出优化方向</s><br>
3、与产品经理沟通设计解决方案，<s>制定数据分析体系，明确数据口径</s><br>
4、与测试人员<s>明确流量分配情况</s>，确保流量分配方式有效。<br>
5、及时<s>收集数据</s>，分析并对测试过程<s>不断优化</s>。<br>
6、跟进试过程，<s>了解测试用户的反馈情况</s>，分析其他优化点。<br>
7、完成测试后，<s>撰写专題报告</s>，整理测试方案、测试数据、测试报告等完成<s>文件归档。</s></p>
<h1 id="例子"><a href="https://github.com/dingtom/python/blob/master/ABtest.ipynb">例子</a></h1>
<p><a href="https://alltodata.cowtransfer.com/s/b6eddb13746642">数据</a><br>
给网站投放广告的时候，一开始给大家看到的落地页是访问课程资料，现在我们又推出了开始免费试学这个落地页，然后想着以后换上新的落地页，这时候就要检测两个落地页的转化效果了，下面是测试的24天，目的是确定使用新落地页，还是使用旧落地页，或是延长测试时<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-2ad2fdd698f4b6f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-ef1626d4bbd41bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<p>结论：由于z_score=1.31小于norm.ppf(1-0.05)=1.64，落在95%的置信区间中，所以无法拒绝原假设，建议延长测试时间，继续观测情况。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试3（计算机基础）]]></title>
        <id>https://dingtom.github.io/post/mian-shi-3ji-suan-ji-ji-chu/</id>
        <link href="https://dingtom.github.io/post/mian-shi-3ji-suan-ji-ji-chu/">
        </link>
        <updated>2020-11-26T06:45:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="按照二叉树的定义4个节点的二叉树有多少种">按照二叉树的定义，4个节点的二叉树有多少种？</h1>
<p>0个节点的二叉树有1种,即f(0)=1;<br>
1个节点的二叉树有1种,即f(1)=1;<br>
2个节点的二叉树有2种，即f(2)=2；<br>
3个节点的二叉树肯定先得固定一个根节点，然后还剩2个节点，这两个节点有三种排列方式，根节点左边两个、根节点左边一个右边一个、根节点右边两个，这样的话就可以用f(0),f(1)和f(2)来求了：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>2</mn><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">f(3)=f(2)*f(0)+f(1)*f(1)+f(0)*f(2)=2*1+1*1+1*2=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>;同理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>4</mn><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>=</mo><mn>5</mn><mo>∗</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>5</mn><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">f(4)=f(3)*f(0)+f(2)*f(1)+f(1)*f(2)+f(0)*f(3)=5*1+2*1+1*2+1*5=14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span>;于是就有了递推公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mn>0</mn><mo>)</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=f(n-1)*f(0)+f(n-2)*f(1)+···+f(1)*f(n-2)+f(0)f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h1 id="网络层">网络层</h1>
<p>OSI中的层</p>
<table>
<thead>
<tr>
<th style="text-align:center">层</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">协议</th>
<th style="text-align:center">设备</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">为操作系统或网络应用程序提供访问网络服务的接口。</td>
<td style="text-align:center">FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">(TCP/IP无)表示层</td>
<td style="text-align:center">数据格式化、转换</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">(TCP/IP无)会话层</td>
<td style="text-align:center">管理主机之间的会话进程</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">提供端对端传输</td>
<td style="text-align:center">CP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）</td>
<td style="text-align:center">网关</td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">路由选择</td>
<td style="text-align:center">IP协议（Internet Protocol，因特网互联协议）;ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;ARP协议（Address Resolution Protocol，地址解析协议）;RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</td>
<td style="text-align:center">路由器</td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">提供可靠的数据传输</td>
<td style="text-align:center">以太网协议</td>
<td style="text-align:center">网桥和交换机</td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">提供一个传输数据的可靠的物理媒体</td>
<td style="text-align:center"></td>
<td style="text-align:center">中继器（Repeater，也叫放大器）和集线器</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-546d626b3b6edd73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实际应用还是 TCP/IP 四层体系结构" loading="lazy"></figure>
<p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。<br>
DNS是域名系统(DomainNameSystem)，将URL转换为IP地址<br>
NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技.</p>
<h1 id="ip地址">IP地址</h1>
<p>255.255.255.255该IP地址指的是受限的广播地址。</p>
<blockquote>
<p>受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。</p>
</blockquote>
<p>localhost</p>
<blockquote>
<p>不联网 ，不使用网卡，不受防火墙和网卡限制 ，本机访问</p>
</blockquote>
<p>127.0.0.0/8</p>
<blockquote>
<p>不联网 ，网卡传输，受防火墙和网卡限制 ，本机访问<br>
用作回环地址，在主机上发送给127开头的IP地址的数据包会被发送的主机自己接收。</p>
</blockquote>
<p>本机IP</p>
<blockquote>
<p>联网 ，网卡传输 ，受防火墙和网卡限制 ，本机或外部访问</p>
</blockquote>
<p>0.0.0.0</p>
<blockquote>
<p>它表示本机中所有的IPV4地址。</p>
</blockquote>
<p>私有地址(private address)</p>
<blockquote>
<p>也叫专用地址，它们不会在全球使用，只具有本地意义。<br>
A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255<br>
B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255<br>
C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p>
</blockquote>
<p>子网掩码</p>
<blockquote>
<p>标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</p>
</blockquote>
<h2 id="子网划分">子网划分</h2>
<p>主机位全0代表网络地址<br>
主机位全1代表广播地址</p>
<blockquote>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-0adf85df2ed8b10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
解析：先判断为C类地址，要五个子网，需要三个1：11100000；剩下五个主机数，2的五次方-2=30&gt;28，所以主机数也够，因此子网掩码应为：255.255.255.224；<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-7e3519e6bee82bd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
</blockquote>
</blockquote>
<h1 id="三次握手">三次握手</h1>
<p>序列号seq：占4个字节，用来<s>标记数据段</s>的顺序<br>
确认号ack：占4个字节，期待收到对方<s>下一个报文段的第一个数据字节的序号</s><br>
确认ACK：占1位，~~仅当ACK=1时，确认号字段ack才有效。~~ACK=0时，确认号无效<br>
同步SYN：连接建立时用于同步序号。<s>当SYN=1，ACK=0时表示：这是一个连接请求报文段</s>。~~若同意连接，则在响应报文段中使得SYN=1，ACK=1。~~因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。<br>
终止FIN：用来释放一个连接。<s>FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</s><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b2e011d8e291b309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-cd177a4f9867fc92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h1 id="四次挥手">四次挥手</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-5410b0192c8199e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-5ea4d776df3a350d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<p>为什么要三次握手呢？主要是为了信息对等和防止出现请求超时导致脏连接。</p>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-72cf315559f0ec3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
只有三次握手之后<s>才能够保证两台服务器都具备发报和收报能力。</s></p>
</blockquote>
<p>为什么会出现脏连接？</p>
<blockquote>
<p>因为TTL 网络报文的生存时间往往都会超 TCP 请求超时时间，如果两次握手就可以创建连接 ，传输数据并释放连接后，第一个超时的连接请求才到达 B 机器的话，B 机器会以为是 A 创建新连接的请求，然后确认同意创建连接。因为 A 机器的状态不是 SYl_SENT ，所以直接丢弃了 B 的确认数据 ，以致最后只是 B 机器单方面创建连接完毕。</p>
</blockquote>
<p>为什么连接的时候是三次握手，关闭的时候却是四次握手</p>
<blockquote>
<p>答：Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
</blockquote>
<p>如果已经建立了连接，但是客户端突然出现故障了怎么办?</p>
<blockquote>
<p>答：<s>TCP还设有一个保活计时器</s>，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
</blockquote>
<h1 id="为什么客户端发出第四次挥手的确认报文后要等2msl的时间才能释放tcp连接">为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h1>
<p>这里同样是要考虑丢包的问题，如果<s>第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL</s>，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<h1 id="http-https">http、https</h1>
<p>HTTP：运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份<br>
HTTPS：身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， 是添加了加密和认证机制的 HTTP。<br>
状态码的类别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational（信息性状态码） 接受的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码） 请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码） 需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码） 服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码） 服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h1 id="tcp和udp有哪些区别">TCP和UDP有哪些区别。</h1>
<h1 id="get和post区别">GET和POST区别</h1>
<p>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。<br>
POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。<br>
PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。<br>
DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</p>
<p><s>Get是不安全的</s>，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p>
<p><s>Get请求提交的url中的数据最多只能是2048字节</s>，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。</p>
<p><s>Get限制Form表单的数据集的值必须为ASCII字符</s>；而Post支持整个ISO10646字符集。</p>
<p><s>Get执行效率却比Post方法好</s>。Get是form提交的默认方法。</p>
<h1 id="对称加密与非对称加密">对称加密与非对称加密</h1>
<p>对称密钥加密是指<s>加密和解密使用同一个密钥的方式</s>，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；<br>
而非对称加密是指使用一对非对称密钥，即<s>公钥和私钥，公钥可以随意发布，但私钥只有自己知道</s>。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。<br>
由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</p>
<h1 id="简述-cookie和-session的区别">简述 cookie？和 session的区别</h1>
<p>cookie是由Web~~服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。~~客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</p>
<p>1, session在服务器端， cookie在客户端（浏览器）<br>
2，session的运行依赖 session id，而 session id是存在 cookie中的，也就是说，如果浏览器禁用了 cookie，同时 session也会失效，存储 Session时，键与 Cookie中的sessionid相同，值是开发人员设置的键值对信息，进行了base64编码，过期时间由开发人员设置<br>
3，cookie安全性比 session差</p>
<h1 id="sql注入">SQL注入</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-b53953def3dedd79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
解決方式：通过传参数方式解决SQL注入<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-cbdf12c3596bc7f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h1 id="关系型数据库和非关系型数据库">关系型数据库和非关系型数据库</h1>
<p>关系模型指的就是二维表格模型，好比Excel文件中的表格，强调用表格的方式存储数据（有字段，表与表之间还有关系）</p>
<blockquote>
<ul>
<li>Oracle</li>
<li>Microsoft SQL Server</li>
<li>MySQL：数据保存在磁盘中，检索的话，会有一定的操作，访问速度相<br>
对慢</li>
<li>SQLite（手机端的）</li>
</ul>
</blockquote>
<p>非关系型数据库,即NoSQL（not only SQL），非关联型的，强调Key-Value的方式存储数据</p>
<blockquote>
<ul>
<li>MongoDB</li>
<li>Redis：内存型，数据保存在内存中，速度快</li>
</ul>
</blockquote>
<h1 id="进程与线程的区别">进程与线程的区别</h1>
<p>1.<s>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位</s></p>
<ol>
<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</li>
<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；<br>
4.调度和切换：线程上下文切换比进程上下文切换要快得多</li>
</ol>
<h1 id="可变数据类型和不可变数据类型">可变数据类型和不可变数据类型</h1>
<p><s>不可变数据类型：数值型、字符串型string和元组tuple</s></p>
<p><s>不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址）</s>，如下图用id()方法可以打印对象的id</p>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-9589825b5b5a5d08.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p>可变数据类型：列表list和字典dict；</p>
<p>允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，~~只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，~~即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/18339009-2f0cc1774c1dc642.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p><s>Python使用乘号复制双层列表，内层数组指向同一个物理地址</s></p>
<pre><code class="language-python">a = [[1]] * 3
print(a)
a[0][0]=2
a
# [[2], [2], [2]]
</code></pre>
<h1 id="深拷贝和浅拷贝的区别">深拷贝和浅拷贝的区别</h1>
<p>在浅拷贝时，拷贝出来的<s>新对象的地址和原对象是不一样</s>的，但是新对象里面的<s>可变元素（如列表）的地址和原对象里的可变元素的地址是相同的</s>，浅拷贝它拷贝的是浅层次的数据结构（不可变元素），对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去。</p>
<p>赋值： 值相等，地址相等<br>
copy浅拷贝：值相等，地址不相等(深层地址相等)<br>
deepcopy深拷贝：值相等，地址不相等</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[markdwon]]></title>
        <id>https://dingtom.github.io/post/markdwon/</id>
        <link href="https://dingtom.github.io/post/markdwon/">
        </link>
        <updated>2020-11-26T00:56:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="生成目录">生成目录</h1>
<pre><code>[TOC]
</code></pre>
<p>[TOC]</p>
<h1 id="to-do-list">To Do List</h1>
<pre><code>- [x] 学习python基础 【减号+[+空格或x+]+空格】
- [ ] 学习python网络编程
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-58fe77302ab071f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h1 id="横线">横线</h1>
<pre><code>---
</code></pre>
<hr>
<h1 id="删除线">删除线</h1>
<pre><code>~~哈哈~~
</code></pre>
<p><s>哈哈</s></p>
<h1 id="列表点号">列表点号</h1>
<pre><code>- 
</code></pre>
<ul>
<li></li>
</ul>
<h1 id="表格">表格</h1>
<pre><code>|Theme name|Value|Directive|
|:-:|:-:|:-:|
|***Default***|default|`&lt;!-- $theme: default --&gt;`
|**Gaia**|gaia|`&lt;!-- $theme: gaia --&gt;`
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">Theme name</th>
<th style="text-align:center">Value</th>
<th style="text-align:left">Directive</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em><strong>Default</strong></em></td>
<td style="text-align:center">default</td>
<td style="text-align:left"><code>&lt;!-- $theme: default --&gt;</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>Gaia</strong></td>
<td style="text-align:center">gaia</td>
<td style="text-align:left"><code>&lt;!-- $theme: gaia --&gt;</code></td>
</tr>
</tbody>
</table>
<pre><code>&lt;table&gt;
    &lt;tr&gt;&lt;th rowspan=4&gt;会员登记表&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th colspan=3&gt;个人信息&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;未婚&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;&lt;td&gt;女&lt;/td&gt;&lt;td&gt;35&lt;/td&gt;&lt;td&gt;已婚&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;王五&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;45&lt;/td&gt;&lt;td&gt;离异&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<h1 id="标注颜色">标注颜色</h1>
<pre><code>==word==
</code></pre>
<p><mark>word</mark></p>
<h1 id="设置背景">设置背景</h1>
<pre><code>![bg](http://img0.imgtn.bdimg.com/it/u=1377132983,1746819781&amp;fm=26&amp;gp=0.jpg)
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://img0.imgtn.bdimg.com/it/u=1377132983,1746819781&amp;fm=26&amp;gp=0.jpg" alt="bg" loading="lazy"></figure>
<h1 id="设置文字背景">设置文字背景</h1>
<pre><code>&lt;span style=&quot;background-color:yellow;&quot;&gt;yellow marker highlight&lt;/span&gt;
</code></pre>
<p><span style="background-color:yellow;">yellow marker highlight</span></p>
<h1 id="区块引用">区块引用</h1>
<pre><code>* python
&gt; 一种编程语言

&gt; 一级引用
&gt;&gt; 二级引用
&gt;&gt;&gt; 三级引用

</code></pre>
<ul>
<li>python</li>
</ul>
<blockquote>
<p>一种编程语言</p>
</blockquote>
<blockquote>
<p>一级引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="链接">链接</h1>
<pre><code>[Yuki Hattori](https://github.com/yhatt)
</code></pre>
<p><a href="https://github.com/yhatt">Yuki Hattori</a></p>
<h1 id="锚点">锚点</h1>
<p>跳转需要按住ctrl</p>
<pre><code># titleA //这是个一级标题，锚点

[titleA](#titleA) //这是锚点引用格式
</code></pre>
<p><a href="#%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95">生成目录</a> //这是锚点引用格式</p>
<h1 id="注脚">注脚</h1>
<pre><code>使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。
[^1]:Markdown是一种纯文本标记语言
[^2]:HyperText Markup Language 超文本标记语言
[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文
</code></pre>
<p>使用 Markdown<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>可以效率的书写文档, 直接转换成 HTML<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>, 你可以使用 Leanote<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 编辑器进行书写。</p>
<h1 id="定义图片尺寸">定义图片尺寸</h1>
<pre><code>&lt;img width = '150' height ='150' src =&quot;https://tse2-mm.cn.bing.net/th?id=OIP.rF3VYN1CRvtyWBPU0I7kyQDMEy&amp;p=0&amp;pid=1.1&quot;/&gt;
</code></pre>
<img width = '150' height ='150' src ="https://tse2-mm.cn.bing.net/th?id=OIP.rF3VYN1CRvtyWBPU0I7kyQDMEy&p=0&pid=1.1"/>
<h1 id="图片居中">图片居中</h1>
<pre><code>&lt;div align=center&gt;&lt;img width = '150' height ='150' src =&quot;https://tse2-mm.cn.bing.net/th?id=OIP.rF3VYN1CRvtyWBPU0I7kyQDMEy&amp;p=0&amp;pid=1.1&quot;/&gt;&lt;/div&gt;
</code></pre>
<div align=center><img width = '150' height ='150' src ="https://tse2-mm.cn.bing.net/th?id=OIP.rF3VYN1CRvtyWBPU0I7kyQDMEy&p=0&pid=1.1"/></div>
<h1 id="插入音乐">插入音乐</h1>
<pre><code>&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=528478901&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;
</code></pre>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=528478901&auto=1&height=66"></iframe>
<h1 id="插入视频">插入视频</h1>
<pre><code>&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=69570770&amp;cid=120575067&amp;page=1&amp;danmaku=0&quot; allowfullscreen=&quot;allowfullscreen&quot; width=&quot;100%&quot; height=&quot;500&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; sandbox=&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;&gt;&lt;/iframe&gt;
</code></pre>
<iframe src="//player.bilibili.com/player.html?aid=69570770&cid=120575067&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>
<h1 id="设置字体">设置字体</h1>
<pre><code>&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;
&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;
&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font》
&lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt;
</code></pre>
<p><font face="黑体">我是黑体字</font><br>
<font face="微软雅黑">我是微软雅黑</font><br>
<font face="STCAIYUN">我是华文彩云</font><br>
<font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font></p>
<h1 id="emoj表情">emoj表情</h1>
<p>https://github.com/guodongxiaren/README/blob/master/emoji.md</p>
<h1 id="首行缩进">首行缩进</h1>
<pre><code>半方大的空白&amp;ensp;或&amp;#8194;
全方大的空白&amp;emsp;或&amp;#8195;
不断行的空白格&amp;nbsp;或&amp;#160;
</code></pre>
<p>半方大的空白 或 <br>
全方大的空白 或 <br>
不断行的空白格 或 </p>
<h1 id="绘图">绘图</h1>
<p><a href="https://blog.csdn.net/qq_18150255/article/details/88043774">https://blog.csdn.net/qq_18150255/article/details/88043774</a><br>
<a href="https://blog.csdn.net/weixin_30307267/article/details/99385290">https://blog.csdn.net/weixin_30307267/article/details/99385290</a></p>
<h1 id="甘特图">甘特图</h1>
<pre><code>gantt
dateFormat YYYY-MM-DD
title “所见”微信小程序-项目进度甘特图
需求分析 :active, des2, 2019-04-10, 5d
可行性分析 :active, des2, 2019-04-13, 4d
项目开发计划 :active, des2, 2019-04-16, 5d
系统设计 :active, des2, 2019-04-19, 7d
开发实现 :active, des2, 2019-04-26, 14d
UI设计 :active, des2, 2019-04-26, 7d
数据库设计 :active, des2, 2019-05-05, 5d
系统测试 :active, des2, 2019-05-10, 5d
操作手册 :active, des2, 2019-05-15, 5d
用户手册 :active, des2, 2019-05-15, 5d
完善项目文档/准备答辩 : des3, after des2, 10d
</code></pre>
<h1 id="流程图">流程图</h1>
<p>流程图代码分两块，上面一块是创建你的流程（创建元素），然后隔一行，创建流程的走向(连接元素)</p>
<p>#####创建流程（元素）：tag=&gt;type: content:&gt;url<br>
<strong>tag 是流程图中的标签</strong>，在第二段连接元素时会用到。名称可以任意，一般为流程的英文缩写和数字的组合。<br>
<strong>type 用来确定标签的类型</strong>，=&gt;后面表示类型。由于标签的名称可以任意指定，所以要依赖type来确定标签的类型<br>
标签有6种类型：start 、end 、operation 、subroutine 、condition 、inputoutput<br>
<strong>content 是流程图文本框中的描述内容</strong>，: 后面表示内容，中英文均可。特别注意，冒号与文本之间一定要有个空格<br>
<strong>url是一个连接</strong>，与框框中的文本相绑定，:&gt;后面就是对应的 url 链接，点击文本时可以通过链接跳转到 url 指定页面</p>
<h5 id="指向流程连接元素标识类别-下一个标识">指向流程(连接元素)：标识（类别）-&gt;下一个标识</h5>
<p>使用 -&gt; 来连接两个元素<br>
对于<strong>condition类型</strong>，有yes和no两个分支，如示例中的cond(yes)和cond(no)<br>
每个元素可以制定分支走向，默认向下，也可以用right指向右边，如示例中cond2(yes,right)。</p>
<p>流程图元素</p>
<pre><code>star1=&gt;start: 开始 
end1=&gt;end: 登录 
in1=&gt;inputoutput: 输入用户名密码 
sub1=&gt;subroutine: 数据库查询子类 
cond1=&gt;condition: 是否有此用户 
cond2=&gt;condition: 密码是否正确 
ope1=&gt;operation: 读入用户信息
star1-&gt;in1-&gt;sub1-&gt;cond1 
cond1(yes,right)-&gt;cond2 
cond1(no)-&gt;in1(right) 
cond2(yes,right)-&gt;ope1-&gt;end1
cond2(no)-&gt;in1
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Markdown是一种纯文本标记语言 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>HyperText Markup Language 超文本标记语言 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>开源笔记平台，支持Markdown和笔记直接发为博文 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql]]></title>
        <id>https://dingtom.github.io/post/mysql/</id>
        <link href="https://dingtom.github.io/post/mysql/">
        </link>
        <updated>2020-11-26T00:38:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<h2 id="win">win</h2>
<blockquote>
<p>https://dev.mysql.com/downloads/mysql/<br>
<a href="http://mirrors.sohu.com/mysql/MySQL-8.0/">http://mirrors.sohu.com/mysql/MySQL-8.0/</a><br>
配置环境变量path<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-6c5c4e1ade3e95ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b6f751a6e0727c08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
新建一个my.ini 用记事本打开</p>
</blockquote>
<pre><code>[mysqld]
# 设置mysql的安装目录
basedir=D:\\software\\java\\mysql-5.7.28-winx64
# 切记此处一定要用双斜杠\\，单斜杠这里会出错。
# 设置mysql数据库的数据的存放目录
datadir=D:\\software\\java\\mysql-5.7.28-winx64\\Data
# 此处同上
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors=10
# 服务端使用的字符集默认为UTF8
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin=mysql_native_password
[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8
[client]
# 设置mysql客户端连接服务端时默认使用的端口
port=3306
default-character-set=utf8
</code></pre>
<p>管理员权限下运行cmd</p>
<pre><code>mysqld -install
# 执行初始化代码（会在根目录创建data文件夹，并创建root用户）
mysqld --initialize-insecure --user=mysql
# 启动mysql服务
net start mysql
</code></pre>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-3b3965a4ecafa1f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
##ubuntu</p>
</blockquote>
<pre><code>sudo apt-get install mysql-server
#sudo apt-get install mysql-client
</code></pre>
<p><s>删除 mysql</s></p>
<pre><code>sudo apt-get autoremove --purge mysql-server
sudo apt-get remove mysql-server
sudo apt-get autoremove mysql-server
sudo apt-get remove mysql-common
</code></pre>
<p><s>清理残留数据</s></p>
<pre><code>dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P
</code></pre>
<p>进入mysql</p>
<pre><code>sudo mysql -uroot -p 
</code></pre>
<p>配置 MySQL 的管理员密码：</p>
<pre><code>sudo mysqladmin -u root password newpassword
</code></pre>
<p>安装MySQL-workbench</p>
<pre><code>sudo apt-get install mysql-workbench
</code></pre>
<p>一旦安装完成，MySQL 服务器应该自动启动。您可以在终端提示符后运行以下命令来检查 MySQL 服务器是否正在运行：</p>
<pre><code>sudo netstat -tap | grep mysql
</code></pre>
<p>当您运行该命令时，您可以看到类似下面的行：<br>
tcp 0 0 localhost.localdomain:mysql <em>:</em> LISTEN -<br>
如果服务器不能正常运行，您可以通过下列命令启动它：</p>
<pre><code>sudo /etc/init.d/mysql restart
</code></pre>
<h1 id="增删改查数据库create-drop-alter-show">增删改查数据库(CREATE、DROP、ALTER、SHOW)</h1>
<h2 id="增加">增加：</h2>
<pre><code>create database 库名 default character utf8;
</code></pre>
<h2 id="删除">删除：</h2>
<pre><code>drop database 库名 ;
</code></pre>
<h2 id="修改">修改：</h2>
<pre><code>alter database 库名  default character gbk;
</code></pre>
<h2 id="查询">查询：</h2>
<pre><code>show databases 
</code></pre>
<h2 id="选择数据库">选择数据库：</h2>
<pre><code>use 库名 ;
</code></pre>
<h1 id="增删改表create-drop-alter-rename">增删改表(CREATE、DROP、ALTER、RENAME)</h1>
<h2 id="新建表">新建表</h2>
<pre><code>CREATE TABLE 表名 (
  id int(10) unsigned NOT NULL COMMENT 'Id',
  username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',
  password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',
  email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'
) COMMENT='用户表';
</code></pre>
<p><s>SELECT  INTO根据已有的表创建新表</s></p>
<pre><code>SELECT * INTO new_表名 FROM 表名
</code></pre>
<h2 id="删除-2">删除：</h2>
<pre><code>DROP TABLE user;
</code></pre>
<h2 id="修改表名称">修改表名称：</h2>
<pre><code>ALTER TABLE user RENAME  user_new;
</code></pre>
<h1 id="增删改查字段add-drop-column-modify-change-desc">增删改查字段（ADD、DROP COLUMN、MODIFY、CHANGE、DESC）</h1>
<h2 id="添加字段">添加字段：</h2>
<pre><code>ALTER TABLE user ADD age int(3);
</code></pre>
<h2 id="删除字段">删除字段:</h2>
<pre><code>ALTER TABLE user DROP COLUMN age;
</code></pre>
<h2 id="修改字段类型">修改字段类型：</h2>
<pre><code>ALTER TABLE user MODIFY 字段名 新的字段类型;
</code></pre>
<p>mysql 设置字段 not null 变成可以null</p>
<pre><code>ALTER TABLE 表名 MODIFY 字段名 VARCHAR(20) DEFAULT NULL
</code></pre>
<h2 id="修改字段名称-change">修改字段名称 ：CHANGE</h2>
<pre><code>ALTER TABLE user CHANGE 旧字段名 新字段名 字段类型;
</code></pre>
<h2 id="显示表字段信息">显示表字段信息：</h2>
<pre><code>DESC user;
</code></pre>
<h1 id="管理数据">管理数据:</h1>
<h3 id="添加主键-add-primary-key">添加主键 ADD PRIMARY KEY</h3>
<pre><code>ALTER TABLE user ADD PRIMARY KEY (id);
</code></pre>
<p><s>删除主键</s></p>
<pre><code>ALTER TABLE user DROP PRIMARY KEY;
</code></pre>
<p>查询表的大小：</p>
<pre><code>use information_schema;  
select data_length,index_length 
from tables 
where table_schema=库 and table_name = 表 ;
</code></pre>
<h2 id="添加数据">添加数据：</h2>
<p>插入完整的行</p>
<pre><code>INSERT INTO user VALUES (10, 'root', 'root', 'xxxx@163.com');
</code></pre>
<p>插入行的一部分</p>
<pre><code>INSERT INTO user(username, password, email) VALUES ('admin', 'admin', 'xxxx@163.com');
</code></pre>
<p><s>插入查询出来的数据</s></p>
<pre><code>INSERT INTO user(字段) SELECT 字段 FROM account;
</code></pre>
<h2 id="删除-3">删除：</h2>
<h3 id="delete-from">DELETE FROM</h3>
<p>1)可以<s>带条件删除</s>2）只能删除表的数据，<s>不能删除表的约束</s>3)删除的数据<s>可以回滚（事务）</s></p>
<pre><code>DELETE FROM user WHERE username='robot';
</code></pre>
<h3 id="truncate">truncate</h3>
<p>1）不能带条件删除 2）即可以删除表的数据，也可以删除表的约束 3）不能回滚</p>
<pre><code>TRUNCATE TABLE user;
</code></pre>
<h2 id="修改update-set">修改：UPDATE SET</h2>
<pre><code>UPDATE user
SET username='robot', password='robot'
WHERE username = 'root';
</code></pre>
<h2 id="查询-2">查询：</h2>
<p>所有字段：</p>
<pre><code>select * from 表;
</code></pre>
<p>指定字段：</p>
<pre><code>select 字段 from 表;
</code></pre>
<p>指定别名：</p>
<pre><code>select 字段1 as 别名 from 表;
</code></pre>
<p>合并列：</p>
<pre><code>select (字段1+字段2) as “和” from 表;
</code></pre>
<p>去重：</p>
<pre><code>select distinct 字段 from 表;
</code></pre>
<h1 id="特殊字符">特殊字符</h1>
<h2 id="逻辑-and-or-in-not-in">逻辑 ：and、 or、in、not  in</h2>
<p><code>select * from 表 where 条件1 and/or 条件2</code><br>
<code>IN (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</code></p>
<h2 id="比较-between-and">比较： &gt; 、 &lt;  、&gt;= 、 &lt;= 、 =、  !=、 &lt;&gt;、 between  and</h2>
<p><code>select * from 表 where 字段&gt;=条件;</code></p>
<h2 id="模糊-like-替换任意个字符-_替换一个字符">模糊： like  、%（替换任意个字符）、  _（替换一个字符）</h2>
<p><code>SELECT * FROM student WHERE NAME LIKE '李%';</code></p>
<h1 id="判断case-when-条件-then-真的操作-else-假的操作-end-if条件-真的操作-假的操作">判断：（case when 条件 then 真的操作 else 假的操作 end）、if(条件, 真的操作, 假的操作)</h1>
<pre><code>SELECT role,
case when building is not null 
THEN &quot;1&quot; else &quot;0&quot; end
as Wheater
FROM employees
GROUP BY role,Wheater;
</code></pre>
<h2 id="聚合函数">聚合函数：</h2>
<p><s>聚合函数要使用的话,有一个前提，那就是是必zhi须要有结果集</s><br>
<code>sum()、avg() 、 max() 、min() 、 count()</code></p>
<h4 id="count">count()</h4>
<p>COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。</p>
<p><code>SELECT SUM(servlet) AS 'servlet的总成绩' FROM student;</code><br>
<code>SELECT COUNT(*) FROM student;</code></p>
<p><code>concat</code>将A和B按顺序连接在一起的字符串<br>
<code>split(str, regex)</code>将string类型数据按regex提取，分隔后转换为array。<br>
<code>substr（str,0,len)</code>截取字符串从0位开始的长度为len个字符。<br>
<code>LOCATE()</code>查找某字符在长字符中的位置<br>
<code>LEFT()、RIGHT()</code>左边或者右边的字符<br>
<code>LOWER()、UPPER()</code>转换为小写或者大写<br>
<code>LTRIM()、RTIM()</code>去除左边或者右边的空格<br>
<code>LENGTH()</code>长度<br>
<code>SOUNDEX()</code>转换为语音值<br>
其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<pre><code>SELECT *
FROM mytable
WHERE SOUNDEX(col1) = SOUNDEX('apple')
</code></pre>
<p>常用的日期提取函数包括 <code>year()/month()/day()/hour()/minute()/second()</code><br>
<code>AddDate()</code>增加一个日期（天、周等）<br>
<code>AddTime()</code>增加一个时间（时、分等）<br>
<code>CurDate()</code>返回当前日期<br>
<code>CurTime()</code>返回当前时间<br>
<code>Date()</code>返回日期时间的日期部分<br>
<code>to_date(&quot;1970-01-01 00:00:00&quot;)</code>把时间的字符串形式转化为时间类型，再进行后续的计算；<br>
<code>datediff(enddate,stratdate)</code>计算两个时间的时间差（day)；<br>
<code>date_sub(stratdate,days)</code>返回开始日期startdate减少days天后的日期。<br>
<code>date_add(startdate,days)</code>返回开始日期startdate增加days天后的日期。<br>
<code>Date_Format()</code>返回一个格式化的日期或时间串<br>
<code>date(paidTime).date_format(paidTime，%Y-%m-d%)</code></p>
<p><code>SIN()</code>正弦<br>
<code>COS()</code>余弦<br>
<code>TAN()</code>正切<br>
<code>ABS()</code>绝对值<br>
<code>SQRT()</code>平方根<br>
<code>MOD()</code>余数<br>
<code>EXP()</code>指数<br>
<code>PI()</code>圆周率<br>
<code>RAND()</code>随机数<br>
<code>percentile()</code> 百分位函数<br>
<code>rank()</code>排序相同时会重复，总数不会变 ，意思是会出现1、1、3这样的排序结果；<br>
<code>dense_rank()</code> 排序相同时会重复，总数会减少，意思是会出现1、1、2这样的排序结果。<br>
<code>row_number()</code> 则在排序相同时不重复，会根据顺序排序。</p>
<h1 id="from-where-group含聚合-having-order-select">from &gt; where &gt; group（含聚合）&gt; having &gt; order &gt; select</h1>
<h2 id="分组查询group-by">分组查询：group by</h2>
<p><s>group by 后可加聚合函数，where 后不能加聚合函数</s>，<s>聚合函数要使用的话,有一个前提，那就是是必zhi须要有结果集</s></p>
<p>把统计函数和GROUP BY结合，那统计结果就是对分组内的数据统计了.</p>
<pre><code>SELECT building,count(*) 
FROM employees
WHERE building!='null'
GROUP BY building
;
</code></pre>
<h2 id="分组后筛选-having">分组后筛选： having</h2>
<p>查询总人数大于2的性别<br>
-- 1) 查询男女的人数<br>
-- 2）筛选出人数大于2的记录(having)<br>
--- 注意： 分组之前条件使用where关键字，分组之前条件使用having关键字<br>
<code>SELECT gender,COUNT(*) FROM student WHERE GROUP BY gender HAVING COUNT(*)&gt;2;</code></p>
<h2 id="distinct-唯一">DISTINCT 唯一</h2>
<p><code>SELECT DISTINCT Director FROM movies ASC;</code></p>
<h2 id="分页查询limit-offset">分页查询：limit offset</h2>
<p>起始行,查询行数起始行从0开始<br>
把结果集分页，每页3条记录。要获取第1页的记录<br>
<code>SELECT * FROM student LIMIT 3 OFFSET 0;</code></p>
<h2 id="排序-order-by">排序： order by</h2>
<p>asc: 正序（默认）desc：反序<br>
按照id顺序排序</p>
<pre><code>SELECT * 
FROM movies 
ORDER BY Director ASC,Year DESC 
LIMIT 10 OFFSET 0;
</code></pre>
<h1 id="连接查询多表查询join-on">连接查询（多表查询）JOIN  ON</h1>
<p>把两个表中具有相同 主键ID的数据连接起来</p>
<p><s>单纯的select * from a,b是笛卡尔乘积</s>。比如a表有5条数据，b表有3条数据，那么最后的结果有5*3=15条数据。但是如果对两个表进行关联:select * from a,b where a.id = b.id 意思就变了，此时就等价于：select * from a inner join b on a.id = b.id。即就是<s>内连接</s>。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-a79c08f891013866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<p>INNER JOIN 产生的结果是AB的交集。<br>
FULL [OUTER] JOIN 产生A和B的并集。<br>
LEFT [OUTER] JOIN 产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代。<br>
RIGHT [OUTER] JOIN 产生表B的完全集，而A表中匹配的则有值，没有匹配的则以null值取代CROSS JOIN 把表A和表B的数据进行一个N*M的组合，即笛卡尔积。<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-93ca0a681c0411c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-315255693cbe1041.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h2 id="内连接查询inner-join只保留两张表中完全匹配的结果集">内连接查询INNER JOIN：只保留两张表中完全匹配的结果集</h2>
<pre><code>SELECT p.LastName, p.FirstName, o.OrderNo
FROM Persons p
INNER JOIN Orders o
ON p.Id_P=o.Id_P and 1=1　　
ORDER BY p.LastName
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-798cff79aafdee78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h2 id="左连接查询left-join返回左表所有的行即使在右表中没有匹配的记录">左连接查询LEFT JOIN：返回左表所有的行，即使在右表中没有匹配的记录。</h2>
<pre><code>SELECT p.LastName, p.FirstName, o.OrderNo
FROM Persons p
LEFT JOIN Orders o
ON p.Id_P=o.Id_P
ORDER BY p.LastName
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/18339009-7951f83402cc6026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h2 id="右连接right-join返回右表所有的行即使在左表中没有匹配的记录">右连接RIGHT JOIN：返回右表所有的行，即使在左表中没有匹配的记录。</h2>
<pre><code>SELECT p.LastName, p.FirstName, o.OrderNo
FROM Persons p
RIGHT JOIN Orders o
ON p.Id_P=o.Id_P
ORDER BY p.LastName
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/18339009-fd7eaa8cc12522ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h2 id="全连接查询full-join-返回左表和右表中所有的行">全连接查询：FULL JOIN ,返回左表和右表中所有的行。</h2>
<pre><code>SELECT p.LastName, p.FirstName, o.OrderNo
FROM Persons p
FULL JOIN Orders o
ON p.Id_P=o.Id_P
ORDER BY p.LastName
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://upload-images.jianshu.io/upload_images/18339009-e11d28c6df0d7187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="union">UNION</h1>
<p>将两个或更多查询的结果组合起来，并生成一个结果集<br>
所有查询的<s>列数和列顺序</s>必须相同。<br>
每个查询中涉及表的<s>列的数据类型</s>必须相同或兼容。<br>
通常<s>返回的列名取自第一个查询。</s><br>
<s>默认会去除相同行</s>，如果需要保留相同行，使用 UNION ALL。<br>
<s>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</s></p>
<h2 id="join-vs-union">JOIN vs UNION</h2>
<p>JOIN 中连接表的列可能不同，但在 UNION 中，<s>所有查询的列数和列顺序必须相同。</s><br>
<s>UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），</s></p>
<h2 id="应用场景">应用场景</h2>
<p><s>在一个查询中从不同的表返回结构数据。</s><br>
<s>对一个表执行多个查询，按一个查询返回数据。<br>
组合查询</s></p>
<pre><code>SELECT cust_name, cust_contact, cust_email
FROM customers
WHERE cust_state IN ('IL', 'IN', 'MI')
UNION
SELECT cust_name, cust_contact, cust_email
FROM customers
WHERE cust_name = 'Fun4All';
</code></pre>
<h1 id="远程连接">远程连接</h1>
<h2 id="查看当前的用户">查看当前的用户</h2>
<p><code>USE mysql;</code><br>
<code>SELECT * FROM user;</code></p>
<h2 id="修改密码">修改密码</h2>
<p>@前用户名@后地址（ % 代表可以任意ip访问）<br>
<code>LTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED BY &quot;root&quot;;</code></p>
<h2 id="创建新用户">创建新用户</h2>
<p><code>CREATE USER 'new_user'@'%' IDENTIFIED BY 'passwd';</code></p>
<h2 id="给用户赋权限">给用户赋权限</h2>
<p>这里我赋的是全部的权限，<em>.</em> 表示数据库库的所有库和表，对应权限存储在mysql.user表中<br>
<code>GRANT ALL ON *.* TO 'new_user'@'%';</code></p>
<p><code>GRANT SELECT, UPDATE ON day16.employee TO 'eric'@'localhost' IDENTIFIED BY '123456';</code></p>
<h2 id="刷新权限">刷新权限</h2>
<p><code>flush privileges;</code></p>
<h2 id="取消远程控制">取消远程控制</h2>
<p><code>update user set host='localhost' where user='用户名';</code></p>
<h2 id="删除用户">删除用户</h2>
<p><code>delete from user where user=&quot;用户名&quot; and host='host权限（localhost/%）';</code></p>
<blockquote>
<p>--开放3306端口--<br>
1.控制面板—系统和安全—windows防火墙—攻击设置—入栈规则<br>
2.新建规则—选择端口<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e649fed7e43e6b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
3.指定开放的端口<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-a40b2644f02b64a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
4.允许连接，一直点下一步即可<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-4610a319e4a4f648.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
</blockquote>
<h1 id="pymysql模块">PyMySQL模块</h1>
<p>是默认开启MySQL的事务功能的，<br>
因此，进行 &quot;增&quot;、 &quot;删&quot;、&quot;改&quot;的时候，一定要使用db.commit()提交事务<br>
一定要使用try…except…语句，因为万一没插入成功，其余代码都无法执行。当语句执行不成功，<br>
我们就db.rollback()回滚到操作之前的状态；当语句执行成功，我们就db.commit()提交事务。</p>
<pre><code>import pymysql 
# 使用pymysql连接上mysql数据库服务器，创建了一个数据库对象；
db=pymysql.connect(host='localhost',user='root', password='',
                   port=3306, db='test', charset='utf8')
# 开启mysql的游标功能，创建一个游标对象；
cursor = db.cursor()

# 建表语句；
sql = &quot;&quot;&quot;create table person(
        id int auto_increment primary key not null,
        name varchar(10) not null,
        age int not null) charset=utf8&quot;&quot;&quot;
# 执行sql语句；
cursor.execute(sql)

# 一次性插入一条数据；
name = &quot;猪八戒&quot;
age = 8000
sql = &quot;&quot;&quot;
insert into person(name,age) values (&quot;猪八戒&quot;,8000)
&quot;&quot;&quot;
try:
    cursor.execute(sql)
    db.commit()
    print(&quot;插入成功&quot;)
except:
    print(&quot;插入失败&quot;)
    db.rollback()

# 要执行的SQL语句；
sql = &quot;select * from person&quot;
# execute(query, args)：执行单条sql语句，接收的参数为sql语句本身和使用的参数列表，返回值为受影响的行数；
# executemany(query, args)：执行单条sql语句，但是重复执行参数列表里的参数，返回值为受影响的行数；
cursor.execute(sql)
# fetchone()：返回一条结果行；
# fetchmany(size)：接收size条返回结果行。如果size的值大于返回的结果行的数量，则会返回cursor.arraysize条数据；
# fetchall()：接收全部的返回结果行；
data = cursor.fetchone()
print(data)
db.close()
</code></pre>
<h1 id="使用pandas">使用pandas</h1>
<p>中的read_sql()方法，将提取到的数据直接转化为DataFrame，进行操作</p>
<pre><code>df1 = pd.read_sql(&quot;select * from student where ssex='男'&quot;,db)
display(df1)
df2 = pd.read_sql(&quot;select * from student where ssex='女'&quot;,db)
display(df2)
</code></pre>
<h1 id="数据约束表约束">数据约束（表约束）</h1>
<pre><code>默认值： default 默认值
非空：   not null
 唯一： unique
主键： primary key （非空+唯一）
 自增长： auto_increment
</code></pre>
<p>######外键： foreign key   约束两种表</p>
<pre><code>CONSTRAINT emlyee_dept_fk 
FOREIGN KEY(deptId) 
REFERENCES dept(id)  
ON UPDATE CASCADE ON DELETE CASCADE  -- ON CASCADE
</code></pre>
<pre><code>ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
</code></pre>
<p>其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。</p>
<pre><code>ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
</code></pre>
<p>注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。</p>
<p>######UPDATE ：级联修改<br>
外键名称                  外键               参考表(参考字段)<br>
注意：<br>
1）被约束的表称为副表，约束别人的表称为主表，外键设置在副表上的！！！<br>
2）主表的参考字段通用为主键！<br>
3）添加数据： 先添加主表，再添加副表<br>
4）修改数据： 先修改副表，再修改主表<br>
5）删除数据： 先删除副表，再删除主表<br>
当有了外键约束的时候，必须先修改或删除副表中的所有关联数据，才能修改或删除主表！但是，我们希望直接修改或删除主表数据，从而影响副表数据。可以使用级联操作实现！！！</p>
<p>存储过程<br>
-- 创建存储过程</p>
<pre><code>DELIMITER $       -- 声明存储过程的结束符
CREATE PROCEDURE pro_test()           --存储过程名称(参数列表)
BEGIN             -- 开始
    -- 可以写多个sql语句;          -- sql语句+流程控制
    SELECT * FROM employee;
END $            -- 结束 结束符
</code></pre>
<p>-- 执行存储过程</p>
<pre><code>CALL pro_test();          -- CALL 存储过程名称(参数);
</code></pre>
<p>-- 删除存储过程</p>
<pre><code>DROP PROCEDURE pro_testOut;
</code></pre>
<ul>
<li>全局变量（内置变量）：mysql数据库内置的变量 （所有连接都起作用）<br>
-- 查看所有全局变量： show variables<br>
-- 查看某个全局变量： select @@变量名<br>
-- 修改全局变量： set 变量名=新值<br>
--  会话变量： 只存在于当前客户端与数据库服务器端的一次连接当中。如果连接断开，那么会话变量全部丢失！<br>
-- 定义会话变量: set @变量=值<br>
-- 查看会话变量： select @变量</li>
</ul>
<p>-- 局部变量： 在存储过程中使用的变量就叫局部变量。只要存储过程执行完毕，局部变量就丢失！！</p>
<ul>
<li>3.3 带有输入输出参数的存储过程</li>
</ul>
<pre><code>  DELIMITER $
  CREATE PROCEDURE pro_testInOut(INOUT n INT)  -- INOUT： 输入输出参数
  BEGIN
   SELECT n;   过程中的变量都是局部变量
   SET n =500;
  END $
  SET @n=10;
  CALL pro_testInOut(@n);
  SELECT @n;
IF num=1    THEN  SET str='星期一';
ELSEIF num=2 THEN  SET str='星期二';
ELSE               SET str='输入错误';
END IF;
</code></pre>
<p>-- 定义一个局部变量</p>
<pre><code>    DECLARE i INT DEFAULT 1;
    DECLARE vsum INT DEFAULT 0;
    WHILE i&lt;=num DO
          SET vsum = vsum+i;
          SET i=i+1;
    END WHILE;
    SET result=vsum;
</code></pre>
<p>-- 3.6 使用查询的结果赋值给变量（INTO）</p>
<pre><code>DELIMITER $
CREATE PROCEDURE pro_findById2(IN eid INT,OUT vname VARCHAR(20) )
BEGIN
    SELECT empName INTO vname FROM employee WHERE id=eid;
END $
CALL pro_findById2(1,@NAME);
SELECT @NAME;
</code></pre>
<p>-- 创建触发器(添加)</p>
<pre><code>CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW    -- 当往员工表插入一条记录时
     INSERT INTO test_log(content) VALUES('员工表插入了一条记录');
</code></pre>
<p>-- 创建触发器(修改)</p>
<pre><code>CREATE TRIGGER tri_empUpd AFTER UPDATE ON employee FOR EACH ROW    -- 当往员工表修改一条记录时
     INSERT INTO test_log(content) VALUES('员工表修改了一条记录');
</code></pre>
<p>-- 创建触发器(删除)</p>
<pre><code>CREATE TRIGGER tri_empDel AFTER DELETE ON employee FOR EACH ROW    -- 当往员工表删除一条记录时
     INSERT INTO test_log(content) VALUES('员工表删除了一条记录');
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安装nvidia显卡驱动]]></title>
        <id>https://dingtom.github.io/post/an-zhuang-nvidia-xian-qia-qu-dong/</id>
        <link href="https://dingtom.github.io/post/an-zhuang-nvidia-xian-qia-qu-dong/">
        </link>
        <updated>2020-11-25T07:17:28.000Z</updated>
        <content type="html"><![CDATA[<p>查看显卡型号<br>
<code>lsb_release -a</code></p>
<p>更新PCI ID数据库<br>
<code>update-pciids</code><br>
<code>lspci | grep -i nvidia</code></p>
<p>驱动安装<br>
<code>wget https://us.download.nvidia.com/XFree86/Linux-x86_64/455.23.04/NVIDIA-Linux-x86_64-455.23.04.run</code><br>
查看TMPDIR目录是否报错<br>
<code>echo $TMPDIR</code></p>
<p>安装驱动</p>
<p><code>sudo bash NVIDIA-Linux-x86_64-455.23.04.run</code></p>
<p>禁用nouveau<br>
<code>lsmod | grep nouveau</code></p>
<p><code>vim /etc/modprobe.d/blacklist.conf</code>添加<br>
<code>blacklist nouveau</code></p>
<p><code>sudo update-initramfs -u</code></p>
<p><code>sudo reboot now</code></p>
<p>查看显卡信息<br>
<code>nvidia-smi</code></p>
<h1 id="安装cuda">安装cuda</h1>
<p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1804&amp;target_type=deblocal">download</a></p>
<h6 id="查看cuda版本">查看cuda版本</h6>
<p><code>nvcc -V</code><br>
不显示</p>
<blockquote>
<p>首先，查看cuda的bin目录下是否有nvcc：<br>
<code>ls /usr/local/cuda/bin</code><br>
如果存在，直接将cuda路径加入系统路径即可：<br>
<code>vim ~/.bashrc</code>进入配置文件；<br>
添加以下两行：<br>
<code>export PATH=/usr/local/cuda/bin:$PATH</code><br>
<code>export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH</code><br>
然后更新配置文件：<br>
<code>source ~/.bashrc</code></p>
</blockquote>
<h1 id="安装cudnn">安装cudnn</h1>
<p><a href="https://developer.nvidia.com/rdp/cudnn-archive">download</a><br>
<code>tar -xvf cudnn-8.0-linux-x64-v5.1.tgz</code><br>
安装cuDNN比较简单，解压后把相应的文件拷贝到对应的CUDA目录下即可</p>
<p><code>sudo cp cuda/include/cudnn.h /usr/local/cuda/include/</code><br>
<code>sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/</code><br>
<code>sudo chmod a+r /usr/local/cuda/include/cudnn.h</code><br>
<code>sudo chmod a+r /usr/local/cuda/lib64/libcudnn*</code></p>
<h1 id="卸载显卡驱动重新安装">卸载显卡驱动重新安装</h1>
<p>命令行界面<br>
Ctrl+Alt+F1</p>
<p><code>sudo apt-get --purge remove nvidia*</code></p>
<p><code>sudo apt autoremove</code></p>
<p>To remove CUDA Toolkit:<br>
<code>sudo apt-get --purge remove &quot;*cublas*&quot; &quot;cuda*&quot;</code><br>
To remove NVIDIA Drivers:<br>
<code>sudo apt-get --purge remove &quot;*nvidia*&quot;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu安装Samba分享文件夹]]></title>
        <id>https://dingtom.github.io/post/ubuntu-an-zhuang-samba-fen-xiang-wen-jian-jia/</id>
        <link href="https://dingtom.github.io/post/ubuntu-an-zhuang-samba-fen-xiang-wen-jian-jia/">
        </link>
        <updated>2020-11-25T07:17:06.000Z</updated>
        <content type="html"><![CDATA[<p>安装samba服务器。<br>
<code>sudo apt-get install samba samba-common</code><br>
创建一个用于分享的samba目录。<br>
<code>sudo mkdir /home/zut_csi/tomding/share</code><br>
给创建的这个目录设置权限<br>
<code>sudo chmod 777 /home/zut_csi/tomding/share</code><br>
添加用户(下面的zut_csi是我的用户名，之后会需要设置samba的密码)。<br>
<code>sudo smbpasswd -a zut_csi</code><br>
配置samba的配置文件。<br>
<code>sudo vim /etc/samba/smb.conf</code></p>
<p>在配置文件smb.conf的最后添加下面的内容：</p>
<pre><code>[share]
comment = share folder
browseable = yes
path = /home/zut_csi/tomding/share
create mask = 0700
directory mask = 0700
valid users = zut_csi
force user = zut_csi
force group = zut_csi
public = yes
browseable = yes
read only = no
available = yes
writable = yes
security = share
</code></pre>
<p>重启samba服务器。<br>
<code>sudo service smbd restart</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell]]></title>
        <id>https://dingtom.github.io/post/shell/</id>
        <link href="https://dingtom.github.io/post/shell/">
        </link>
        <updated>2020-11-25T07:16:54.000Z</updated>
        <content type="html"><![CDATA[<p><code>#!/bin/bash</code> <br>
######! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 <code>chmod +x ./test.sh</code> #使脚本具有执行权限 <code>./test.sh</code> #执行脚本 注意，一定要写成 ./test.sh，而不是 <a href="http://test.sh/">test.sh</a>，运行其它二进制的程序也一样，直接写 <a href="http://test.sh/">test.sh</a>，linux 系统会去 PATH 里寻找有没有叫 <a href="http://test.sh/">test.sh</a> 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <a href="http://test.sh/">test.sh</a> 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
<p><code>/bin/sh test.sh</code> # 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<p>######变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p>#####除了显式地直接赋值，还可以用语句给变量赋值，如： <code>for file in</code>ls /etc`` 或 <code>for file in $(ls /etc)</code> 以上语句将 /etc 下目录的文件名循环出来。</p>
<p>#####使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<pre><code>your_name=&quot;qinjx&quot;
echo $your_name
echo ${your_name}

</code></pre>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<pre><code>for skill in Ada Coffe Action Java; do  echo &quot;I am good at ${skill}Script&quot; ;done

</code></pre>
<p>如果不给skill变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<p>#####使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 readonly myUrl #修改的话执行时会报错</p>
<p>#####使用 unset 命令可以删除变量。unset 命令不能删除只读变量。 unset variable_name 变量被删除后不能再次使用。</p>
<p>#####单引号字符串的限制：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p>
<p>#####双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符</p>
<pre><code>your_name='runoob'
str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;
echo -e $str

</code></pre>
<p>#####拼接字符串</p>
<pre><code>your_name=&quot;runoob&quot;
# 使用双引号拼接
greeting=&quot;hello, &quot;$your_name&quot; !&quot;
greeting_1=&quot;hello, ${your_name} !&quot;
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
输出结果为：

hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !

</code></pre>
<p>#获取字符串长度 string=&quot;abcd&quot; echo ${#string} #输出 4</p>
<p>#提取子字符串 以下实例从字符串第 2 个字符开始截取 4 个字符： string=&quot;runoob is a great site&quot; echo ${string:1:4} # 输出 unoo</p>
<p>#查找子字符串 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： string=&quot;runoob is a great site&quot; <code>echo</code>expr index &quot;$string&quot; io`` # 输出 4</p>
<p>#####定义数组 在 Shell 中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开。 例如： array_name=(value0 value1 value2 value3) 还可以单独定义数组的各个分量： array_name[0]=value0 array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。</p>
<p>#####读取数组元素值的一般格式是：</p>
<pre><code>valuen=${array_name[n]}
使用 @ 符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}

</code></pre>
<p>#####获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<pre><code>length=${#array_name[@]}
或者
length=${#array_name[*]}

</code></pre>
<p>#####遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？ 每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
<p>#####多行注释还可以使用以下格式：</p>
<pre><code>:&lt;&lt;EOF
注释内容...
注释内容...
注释内容...
EOF

</code></pre>
<p>#####Shell 传递参数</p>
<pre><code>echo &quot;Shell 传递参数实例！&quot;
echo &quot;执行的文件名：$0&quot;;！！！！！！！！！！！！！！！！！！！！！！
echo &quot;第一个参数为：$1&quot;;
echo &quot;第二个参数为：$2&quot;;
echo &quot;第三个参数为：$3&quot;;
为脚本设置可执行权限，并执行脚本，输出结果如下所示：
chmod +x test.sh 
./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3

</code></pre>
<pre><code>$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。

</code></pre>
<p>#####另外，还有几个特殊字符用来处理</p>
<pre><code>$# 传递到脚本的参数个数 

$*  以一个单字符串显示所有向脚本传递的参数。如&quot;$*&quot;用「&quot;」
括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。

$$  脚本运行的当前进程ID号 

$!  后台运行的最后一个进程的ID号 

$@  与$*相同，但是使用时加引号，并在引号中返回每个参数。如&quot;$@&quot;用「&quot;」括起来的情况
以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数
 $* 与 $@ 区别：
相同点：都是引用所有参数。
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等
价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。

$- 显示Shell使用的当前选项，与[set命令]
(https://www.runoob.com/linux/linux-comm-set.html)功能相同。 

$?  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 

</code></pre>
<p>#Shell 基本运算符 #####算术运算符</p>
<pre><code>条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成
 [ $a == $b ]。表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，
这与我们熟悉的大多数编程语言不一样。完整的表达式要被 ` ` 包含，注意这个字符不是常用
的单引号，在 Esc 键下边。

</code></pre>
<pre><code>加法	`expr $a + $b` 结果为 30。
减法	`expr $a - $b` 结果为 -10。
乘法	`expr $a \* $b` 结果为  200。!   !  !   !   !
除法	`expr $b / $a` 结果为 2。
取余	`expr $b % $a` 结果为 0。
赋值	a=$b 将把变量 b 的值赋给 a。
相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。
不相等。用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。

</code></pre>
<p>#####关系运算符,关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<pre><code>-eq   检测两个数是否相等，相等返回 true。                 [ $a -eq $b ] 

-ne	检测两个数是否不相等，不相等返回 true。	            [ $a -ne $b ] 

-gt	检测左边的数是否大于右边的，如果是，则返回 true。   	[ $a -gt $b ] 

-lt	检测左边的数是否小于右边的，如果是，则返回 true。   	[ $a -lt $b ] 

-ge	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 

-le	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 

</code></pre>
<p>#####布尔运算符</p>
<pre><code>!	非运算，表达式为 true 则返回 false，否则返回 true。   	[ ! false ] 
-o	或运算，有一个表达式为 true 则返回 true。	                        [ $a -lt 20 -o $b -gt 100 ] 
-a	与运算，两个表达式都为 true 才返回 true。	                        [ $a -lt 20 -a $b -gt 100 ] 

</code></pre>
<p>#####逻辑运算符，表达式外有两个大括号! ! ! ! ! ! ! ! ! ! ! !</p>
<pre><code>&amp;&amp;	逻辑的 AND	[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]     !　！　！！　！！
||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]]   

</code></pre>
<p>##字符串运算符</p>
<pre><code>=	检测两个字符串是否相等，相等返回 true。	        [ $a = $b ] 
!=	检测两个字符串是否相等，不相等返回 true。	     [ $a != $b ] 
-z	检测字符串长度是否为0，为0返回 true。	        [ -z $a ] 
-n	检测字符串长度是否为0，不为0返回 true。	         [ -n &quot;$a&quot; ] 
$	检测字符串是否为空，不为空返回 true。	         [ $a ]   !!!!!!!!!!!

</code></pre>
<p>##文件测试运算符</p>
<pre><code>-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 
-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 
-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 
-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 
-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ]
-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 
-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 
-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 
-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 
-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 
-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 
-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 
-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 
-S: 判断某文件是否 socket。
-L: 检测文件是否存在并且是一个符号链接。

</code></pre>
<p>#echo命令 #####显示变量 read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<pre><code>read name 
echo &quot;$name It is a test&quot;
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出

</code></pre>
<p>#####显示换行 echo -e &quot;OK! \n&quot; # -e 开启转义 echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行 echo -n &quot;haod&quot; #输出后不换行 #####显示结果定向至文件 echo &quot;It is a test&quot; &gt; myfile</p>
<p>#####原样输出字符串，不进行转义或取变量(用单引号) <code>echo '$name\&quot;'</code></p>
<p>##显示命令执行结果 echo <code>date</code> #显示时间</p>
<p>#printf 命令 接下来,我来用一个脚本来体现printf的强大功能：</p>
<pre><code>#!/bin/bash
printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 
printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 
执行脚本，输出结果如下所示：

姓名     性别   体重kg
郭靖     男      66.12
杨过     男      48.65
郭芙     女      47.99

</code></pre>
<p>%s %c %d %f都是格式替代符</p>
<p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
<p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

# format-string为双引号
printf &quot;%d %s\n&quot; 1 &quot;abc&quot;

# 单引号与双引号效果一样 
printf '%d %s\n' 1 &quot;abc&quot; 

# 没有引号也可以输出
printf %s abcdef

# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
printf %s abc def

printf &quot;%s\n&quot; abc def

printf &quot;%s %s %s\n&quot; a b c d e f g h i j

# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
printf &quot;%s and %d \n&quot; 
执行脚本，输出结果如下所示：

1 abc
1 abc
abcdefabcdefabc
def
a b c
d e f
g h i
j  
 and 0

</code></pre>
<p>#####流程控制 <code>if [ $int == $anwser ]; then echo &quot;right&quot;;else echo &quot;wrong&quot;;fi</code></p>
<p><code>for var in item; do command; done</code> item是数组不用写括号</p>
<pre><code>echo '按下 &lt;CTRL-D&gt; 退出'
echo -n '输入你最喜欢的名字: '
while read NAME
do
    echo &quot;是的！$NAME 是一个好名字&quot;
done

</code></pre>
<p>#####while后的条件需要加括号 read 读取键盘输入 <CTRL-D> 退出</p>
<pre><code>#!/bin/bash
int=1
while([ $int -lt 5 ])   ! ! ! !  ! ! ! ! ! !
do
    echo $int
    let int++
done

</code></pre>
<p>let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。 let int++ #case</p>
<pre><code>echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac

</code></pre>
<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<pre><code>funWithReturn(){
    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;
    echo &quot;输入第一个数字: &quot;
    read aNum
    echo &quot;输入第二个数字: &quot;
    read anotherNum
    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;
    return $(($aNum+$anotherNum))
}
funWithReturn
echo &quot;输入的两个数字之和为 $? !&quot;

</code></pre>
<p>#####return返回的值需要两个括号 函数返回值在调用该函数后通过 $? 来获得。 #####输入/输出重定向 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
<pre><code>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：

$ wc -l users
       2 users
也可以将输入重定向到 users 文件：

$  wc -l &lt; users
       2 
注意：上面两个例子的结果不同：第一个例子，会输出文件名；
第二个不会，因为它仅仅知道从标准输入读取内容

</code></pre>
<p>#####重定向深入讲解 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<p>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>如果希望 stderr 重定向到 file，可以这样写：</p>
<p>command &lt; file1 &gt;file2 command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 #Here Document 它的基本的形式如下：</p>
<p>command &lt;&lt; delimiter document delimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<p>注意：</p>
<p>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。</p>
<pre><code>wc -l &lt;&lt; EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行

</code></pre>
<p>#####/dev/null 文件 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-ae38c3e76a5bcb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux命令]]></title>
        <id>https://dingtom.github.io/post/linux-ming-ling/</id>
        <link href="https://dingtom.github.io/post/linux-ming-ling/">
        </link>
        <updated>2020-11-25T05:55:41.000Z</updated>
        <content type="html"><![CDATA[<p>Ctrl+d	键盘输入结束或退出终端<br>
Ctrl+s	暂停当前程序，暂停后按下任意键恢复运行<br>
Ctrl+z	将当前程序放到后台运行，恢复到前台为命令fg<br>
Ctrl+a	将光标移至输入行头，相当于Home键<br>
Ctrl+e	将光标移至输入行末，相当于End键<br>
Ctrl+k	删除从光标所在位置到行末<br>
Alt+Backspace	向前删除一个<strong>单词</strong><br>
命令 --help  查看一些它的某个命令具体参数的作用<br>
man 命令   显示系统手册页中的内容</p>
<p>一行中运行多个命令。<br>
; Command 1 ; Command 2 首先运行Command1，然后运行Command2<br>
&amp;&amp; Command 1 &amp;&amp; Command 2 当Command1运行成功并结束，然后运行Command2<br>
|| Command 1 || Command 2 当Command1运行失败时才运行Command2</p>
<h1 id="文件">文件</h1>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-be4aa0903719bf65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<blockquote>
<p>bin (binaries)存放二进制可执行文件<br>
sbin (super user binaries)存放二进制可执行文件，只有root才能访问<br>
etc (etcetera)存放系统配置文件<br>
usr (unix shared resources)用于存放共享的系统资源<br>
home 存放用户文件的根目录<br>
root 超级用户目录<br>
dev (devices)用于存放设备文件<br>
lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块<br>
mnt (mount)系统管理员安装临时文件系统的安装点<br>
boot 存放用于系统引导时使用的各种文件<br>
tmp (temporary)用于存放各种临时文件<br>
var (variable)用于存放运行时需要改变数据的文件</p>
</blockquote>
<h1 id="文件增删改查">文件增删改查</h1>
<h4 id="mkdir">mkdir</h4>
<blockquote>
<p>创建目录和父目录a,b,c,d<br>
<code>mkdir -p a/b/c/d</code><br>
-p 建立多级目录<br>
-m 在建立目录的时候给目录赋于权限值</p>
</blockquote>
<h4 id="rmdir">rmdir</h4>
<blockquote>
<p>删除空目录<br>
-p 删除多级空目录</p>
</blockquote>
<h4 id="cp">cp</h4>
<blockquote>
<p>拷贝文件夹a到/tmp目录<br>
<code>cp -rvf a/ /tmp/</code><br>
-R 复制整个目录里的内容<br>
-p 复制完后保持目录的权限值<br>
-v 在复制文件的时候显示进度<br>
-f 在复制的时候如果碰到目的文件名有重复就将原先的删除</p>
</blockquote>
<h4 id="mv">mv</h4>
<blockquote>
<p>重命名 <code>mv a.txt b.txt</code><br>
移动文件a到/tmp目录，并重命名为b<br>
<code>mv -vf a /tmp/b</code><br>
-i 如果目的地有相同文件名时会出现提示<br>
-v 在搬移文件时显示进度，在移动多文件时非常有用<br>
-u 当移动时只有源文件比目的文件新的时候才会移动<br>
-f 强制覆盖已有的文件</p>
</blockquote>
<h4 id="touch">touch</h4>
<blockquote>
<p>创建文件<br>
<code>touch asd.txt</code><br>
创建多个文件<br>
<code>touch love_{1..10}_shiyanlou.txt</code></p>
</blockquote>
<h4 id="rm">rm</h4>
<blockquote>
<p>删除机器上的所有文件<br>
rm -rvf /<br>
-i 在删除文件之前需要手工确认<br>
-v 在删除文件的时候显示信息<br>
-r 删除目录<br>
-f 忽略提示</p>
</blockquote>
<h4 id="ls">ls</h4>
<blockquote>
<p>-a 这个选项能显示.开头的隐藏文件<br>
-l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>
-t 将文件依建立时间之先后次序列出<br>
-i 显示每个文件的inode号<br>
-m 所有项目以逗号分隔，并填满整行行宽<br>
-R 同时列出所有子目录层<br>
-h 将列出文件的大小以人性化格式输出<br>
--color=tty(2个-号)显示文件的时候以色彩提示<br>
-full-time显示文件的详细访问时间<br>
-lc查看文件状态修改时间</p>
</blockquote>
<h4 id="cat">cat</h4>
<blockquote>
<p>查看文本文件<br>
如果文件很大的话，cat命令的输出结果会疯狂在终端上输出，可以多次按ctrl+c终止。<br>
-b 显示文件内容的时候显示行数<br>
-n 显示文件内容包括空行<br>
-s 将多个空行合并成一个空行输出</p>
</blockquote>
<h4 id="tr">tr</h4>
<blockquote>
<p>删除、转换一段文本信息中的某些文字<br>
-d	删除匹配的字符，注意不是全词匹配也不是按字符顺序匹配<br>
-s	去除指定的在输入文本中连续并重复的字符<br>
删除 &quot;hello shiyanlou&quot; 中所有的'o','l','h'<br>
<code>echo 'hello shiyanlou' | tr -d 'olh'</code><br>
将&quot;hello&quot; 中的ll,去重为一个l<br>
<code>echo 'hello' | tr -s 'l'</code><br>
将输入文本，全部转换为大写或小写输出<br>
<code>echo 'input some text here' | tr '[:lower:]' '[:upper:]'</code><br>
上面的'[:lower:]' '[:upper:]'你也可以简单的写作'[a-z]' '[A-Z]',当然反过来将大写变小写也是可以的</p>
</blockquote>
<h4 id="jion">jion</h4>
<blockquote>
<p>将两个文件中包含相同内容的那一行合并在一起。<br>
-t	指定分隔符，默认为空格<br>
-i	忽略大小写的差异<br>
-1	指明第一个文件要用哪个字段来对比，默认对比第一个字段<br>
-2	指明第二个文件要用哪个字段来对比，默认对比第一个字段<br>
将/etc/passwd与/etc/group两个文件合并，指定以':'作为分隔符, 分别比对第4和第3个字段<br>
<code>sudo join -t':' -1 4 /etc/passwd -2 3 /etc/group</code></p>
</blockquote>
<h4 id="paste">paste</h4>
<blockquote>
<p>在不对比数据的情况下，简单地将多个文件合并一起，以Tab隔开。<br>
-d	指定合并的分隔符，默认为 Tab<br>
-s	不合并到一行，每个文件为一行</p>
</blockquote>
<h4 id="less">less</h4>
<p>针对比较大的文件，我们就可以使用less命令打开某个文件。</p>
<p>按n(N)向下(上)查找。</p>
<h4 id="more">more</h4>
<p>查看文本文件命令</p>
<p>用空格向下翻页，用b向上翻页</p>
<blockquote>
<p>+行数直接从给定的行数开始显示<br>
-s 将多个空行压缩成一个空行<br>
-p 清除屏幕后再显示</p>
</blockquote>
<h4 id="nano">nano</h4>
<p>文本编辑器<br>
命令格式：nano [选项] [行号] 文件名</p>
<h4 id="head">head</h4>
<p>查看文件头部</p>
<blockquote>
<p>-n &lt;行数&gt; 显示文件的最前指定的行<br>
-c &lt;字节数&gt; 显示文件前N个字节数里的内容<br>
-q 不输出文件头的内容<br>
-v 输出文件头的内容</p>
</blockquote>
<h4 id="tail">tail</h4>
<p>查看文件尾部</p>
<blockquote>
<p>-f 循环读取<br>
-c &lt;字节数&gt; 显示文件前N个字节数里的内容<br>
-q 不输出文件头的内容<br>
-n &lt;行数&gt; 指定所显示的行数<br>
-v 输出文件头的内容</p>
</blockquote>
<p><code>tail -f access.log</code></p>
<h4 id="ln">ln</h4>
<p>生成链接文件</p>
<p>命令格式：ln [选项] 源文件 链接文件</p>
<blockquote>
<p>-f 删除已存在的目的文件<br>
-i 如果碰到有重复名字的提示如何操作<br>
-v 显示操作信息<br>
-s 软链接选项</p>
</blockquote>
<h4 id="file">file</h4>
<p>查看文件的类型</p>
<h4 id="stat">stat</h4>
<p>显示文件或文件系统状态</p>
<p>命令格式：stat [选项] &lt;文件/目录&gt;</p>
<blockquote>
<p>-f:查看指定的文件系统</p>
</blockquote>
<p>stat可查看：<br>
文件名 2. 文件尺寸 3. I节点号 4. 创建时间/访问时间/状态(属 主、组、权限)修改时间 5.权限 6.链接文件个数 7. 属主及属组等</p>
<h4 id="whereis">whereis</h4>
<p>whereis 只能查找2进制程序，文档和源码。</p>
<h4 id="which">which</h4>
<p>查找是否安装某个命令</p>
<h4 id="find">find</h4>
<p>最常用的命令，命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。<br>
<code>sudo find /etc -name sources.list</code></p>
<p>find -size n [c]<br>
查找n值大小的文件,默认单位是块(1块=512字节)</p>
<blockquote>
<ol>
<li>查找大于1500字节的文件<br>
find ~ -size +1500c</li>
</ol>
</blockquote>
<ol>
<li>查找等于1500字节的文件<br>
find ~ -size 1500c</li>
<li>查找小于1500字节的文件<br>
find ~ -size -1500c</li>
<li>查找大于512k字节的文件<br>
find ~ -size +512k</li>
<li>查找等于1M字节的文件<br>
find ~ -size 1M</li>
<li>查找小于1G字节的文件<br>
find ~ -size -1G</li>
<li>查找大于10块的文件<br>
find ~ -size +10</li>
<li>查找等于10块的文件<br>
find ~ -size -10</li>
<li>查找大于10M小于20M的文件<br>
find ./ -size +10M -size -20M</li>
<li>查找小于10块的文件<br>
find ~ -size -10</li>
<li>查找文件/目录字节为0的文件(即空文件)<br>
find / -empty</li>
</ol>
<h4 id="grep">grep</h4>
<p>功能: 通过正则表达式查找文件中的关键字</p>
<blockquote>
<p>-i:忽略大小写<br>
-c:打印匹配的行数<br>
-C:打印出匹配的上下文(上N行,下N行)的多少行-l:列出匹配的文件名<br>
-L:列出不匹配的文件名<br>
-n：打印包含匹配项的行和行标<br>
-w:仅匹配指定的单词而非关键字<br>
-e:索引匹配字串<br>
-r:递归查询<br>
-v:不输出匹配的行<br>
-A &lt;行号&gt;:显示所找的匹配字段，并显示下面指定的行数的信息<br>
-B &lt;行号&gt;:显示所找的匹配字段，并显示上面指定的行数的信息</p>
</blockquote>
<p>查看nginx日志中的POST请求。<br>
<code>grep -rn --color POST access.log</code><br>
看某个异常前后相关的内容<br>
<code>grep -rn --color Exception -A10 -B2 error.log</code></p>
<h4 id="正则表达式表示方法">正则表达式表示方法:</h4>
<blockquote>
<p>\忽略正则表达式中特殊字符的原有含义<br>
^ 匹配正则表达式的开始行<br>
$ 匹配正则表达式的结束行<br>
&lt; 从匹配正则表达式的行开始<br>
到匹配正则表达式的行结束<br>
[ ] 单个字符；如[A] 即A符合要求<br>
[ n - m ] 范围 ；如[A-H]即包含A至H都符合要求<br>
. 所有的单个字符<br>
* 所有字符，长度可以为0</p>
</blockquote>
<h4 id="cut">cut</h4>
<p>打印每一行的某一字段</p>
<blockquote>
<p>-d “n”:定义分界符,即点位<br>
-f 取第几位的字符<br>
-c:仅显示行中指定范围的字符</p>
</blockquote>
<p>打印/etc/passwd文件中以:为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录：<br>
<code>cut /etc/passwd -d ':' -f 1,6</code><br>
前五个（包含第五个）<br>
<code>cut /etc/passwd -c -5</code><br>
前五个之后的（包含第五个）<br>
<code>cut /etc/passwd -c 5-</code></p>
<h4 id="sort">sort</h4>
<p>排序<br>
-r反转<br>
-t参数用于指定字段的分隔符<br>
-k 字段号用于指定对哪一个字段进行排序<br>
-n 按照数字排序,默认情况下是以字典序排序的<br>
<code>cat /etc/passwd | sort -t':' -k 3 -n</code></p>
<h4 id="wc">wc</h4>
<p>计数工具<br>
行数<br>
<code>wc -l /etc/passwd</code><br>
单词数<br>
<code>wc -w /etc/passwd</code><br>
字节数<br>
<code>wc -c /etc/passwd</code><br>
字符数<br>
<code>wc -m /etc/passwd</code><br>
最长行字节数，西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于 2 个字节的，具体数目是由字符编码决定的<br>
<code>wc -L /etc/passwd</code></p>
<h4 id="uniq">uniq</h4>
<p>-c:在数据行前出现的次数<br>
-d:只打印重复的行,重复的行只显示一次<br>
-f:忽略行首的几个字段<br>
-i:忽略大小写<br>
-s:忽略行首的几个字母<br>
-u:只打印唯一的行</p>
<p>用于过滤或者输出重复行。<br>
因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：</p>
<p><code>history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq</code><br>
使用频率前三的命令<br>
<code>history |cut -c 8-|sort|uniq -dc|sort -rn -k1 |head -3</code></p>
<h4 id="下载">下载</h4>
<p><code>wget url</code></p>
<p><code>sudo apt-get install axel</code></p>
<p><code>axel -n 10 -o /tmp/ [http://testdownload.net/test.tar.gz](http://testdownload.net/test.tar.gz)</code><br>
-n 指定线程数<br>
-o 指定另存为目录<br>
-s 指定每秒的最大比特数<br>
-q 静默模式</p>
<h1 id="系统">系统</h1>
<p><code>who am i</code><br>
查看用户<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-f5fab39403516fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<p>输出的第一列表示打开当前伪终端的用户的用户名，第二列的 pts/0 中 pts 表示伪终端，所谓伪是相对于 /dev/tty 设备而言的，还记得上一节讲终端时的那七个使用 [Ctrl]+[Alt]+[F1]～[F7] 进行切换的 /dev/tty 设备么，这是“真终端”，伪终端就是当你在图形用户界面使用 /dev/tty7 时每打开一个终端就会产生一个伪终端，pts/0 后面那个数字就表示打开的伪终端序号，第三列则表示当前伪终端的启动时间。</p>
<h4 id="用户">用户</h4>
<p>sudo passwd lilei  设置用户lilei的密码<br>
sudo adduser lilei 创建新用户lilei，默认为新用户在 /home 目录下创建一个工作目录<br>
su -l lilei   切换到lilei用户<br>
sudo deluser lilei --remove-home  删除用户</p>
<h4 id="groups">groups</h4>
<p>groups shiyanlou<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-190c8e54549c1881.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
其中冒号之前表示用户，后面表示该用户所属的用户组。这里可以看到 shiyanlou 用户属于 shiyanlou 用户组，每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组<br>
<code>cat /etc/group | grep -E &quot;shiyanlou&quot;</code><br>
查看自己属于哪些用户组<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-51df186681c8e87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
group_name:password:GID:user_list</p>
<p><code>sudo usermod -G sudo lilei</code><br>
将其它用户加入 sudo 用户组<br>
以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。</p>
<h2 id="文件权限操作">文件权限操作</h2>
<p><code>ls -l a.txt</code></p>
<p>drwxr-xr-x  2 root root 4.0K  3月  23  2017  a.txt</p>
<blockquote>
<p>第1位：文件类型（d 目录，- 普通文件，l 链接文件）<br>
r 可读权限，w可写权限，x可执行权限（也可以用二进制表示 111 110 100 --&gt; 764）<br>
第2-4位：所属用户权限，用u（user）表示<br>
第5-7位：所属组权限，用g（group）表示<br>
第8-10位：其他用户权限，用o（other）表示<br>
第2-10位：表示所有的权限，用a（all）表示</p>
</blockquote>
<p>2是纯数字 ，表示 文件链接个数<br>
第一个“root” 表示文件的所有者<br>
第二个“root” 表示为文件的所在群组<br>
“4.0K”，表示为文件长度（大小）<br>
“3月  23  2017”，表示文件最后更新（修改）时间<br>
“etc” 表示文件的名称</p>
<h4 id="chown">chown</h4>
<p>改变文件的所属用户和所属组。</p>
<blockquote>
<p>-R 修改指定目录及其子目录</p>
</blockquote>
<p>修改a目录的用户和组为 xjj<br>
<code>chown -R xjj:xjj a</code></p>
<h4 id="chmod">chmod</h4>
<p>改变文件的访问权限。</p>
<blockquote>
<p>u表示当前用户<br>
g表示同组用户<br>
o表示其他用户<br>
a表示所有用户<br>
r表示可读<br>
w表示可写<br>
x表示可执行<br>
用数字来表示权限（r=4，w=2，x=1，-=0）,7：表示可读可写可执行，4+2+1,6：表示可读可写，4+2<br>
-R 修改指定目录及其子目录</p>
</blockquote>
<p>给a.sh文件增加执行权限（这个太常用了)<br>
<code>chmod a+x a.sh</code><br>
g、o 还有 u 分别表示 group（用户组）、others（其他用户） 和 user（用户），+ 和 - 分别表示增加和去掉相应的权限。<br>
<code>chmod go-rw t.txt</code></p>
<p>####df(report file system disk space usage)<br>
显示文件系统磁盘空间的使用情况</p>
<blockquote>
<p>-h 以人类可读的方式显示，KD，Mb，GB等</p>
</blockquote>
<h4 id="du-estimate-file-space-usage">du  (estimate file space usage)</h4>
<p>显示指定的目录及其子目录已使用的磁盘空间的总和</p>
<blockquote>
<p>-s显示指定目录的总和<br>
-a  显示目录中所有文件的大小。<br>
-h以人类可读的方式显示，Kb，Mb，G8等<br>
-d参数指定查看目录的深度 # 只查看1级目录的信息<br>
-d 0 ~<br>
查看文件大小<br>
<code>du -h file</code></p>
</blockquote>
<h4 id="dd">dd</h4>
<p>转换和复制文件,也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。</p>
<p>dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file，输入文件）和of（output file，输出文件）改变。</p>
<p>bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如'K'，'M'，'G'等单位），<br>
count用于指定块数量。<br>
conv=ucase  将输出的英文字符转换为大写再写入文件</p>
<p>输出到test文件<br>
<code>dd of=test bs=10 count=1</code><br>
输出到标准输出<br>
<code>dd if=/dev/stdin of=/dev/stdout bs=10 count=1</code></p>
<h4 id="mount">mount</h4>
<p>-o 操作选项<br>
-t 文件系统类型<br>
-w|--rw|--ro权限</p>
<p>从/dev/zero设备创建一个容量为 256M 的空文件：<br>
<code>dd if=/dev/zero of=virtual.img bs=1M count=256</code><br>
格式化磁盘：<br>
<code>sudo mkfs.ext4 virtual.img</code><br>
挂载我们创建的虚拟磁盘镜像到/mnt目录：<br>
<code>mount -o loop -t ext4 virtual.img /mnt</code></p>
<p>卸载已挂载磁盘<br>
<code>sudo umount /mnt</code></p>
<h4 id="free">free</h4>
<p>显示当前内存和交换空间的使用情况</p>
<h4 id="date">date</h4>
<p>显示系统当前时间</p>
<h4 id="top">top</h4>
<p>显示当前系统中耗费资源最多的进程<br>
查看某个进程中的线程状态<br>
<code>top -H -p pid</code></p>
<h4 id="ps">ps</h4>
<p>较少单独使用，配参数根据需求，ps ef或者ps-aux</p>
<blockquote>
<p>-e 显示所有选程，环境变量<br>
-f 全格式显示<br>
-a 显示所有用户的所有进程（包括其它用户）<br>
-u 按用户名和启动时间的顺序来显示进程<br>
-x 显示无控制终端的进程</p>
</blockquote>
<h4 id="kill">kill</h4>
<blockquote>
<p>-9 kill -9 pid强制杀死一个进程</p>
</blockquote>
<h4 id="ifconfig">ifconfig</h4>
<p>网卡网络配置，常用于查看当前IP地址<br>
ifconfig etho 192.168.12.22 修改系统IP（重品后失效）</p>
<h4 id="ping">ping</h4>
<p>ping baidu.com 测试网络的连通</p>
<h4 id="hostname">hostname</h4>
<p>查看主机名</p>
<h4 id="关机">关机</h4>
<blockquote>
<p><code>sudo shutdown now</code><br>
<code>sudo reboot now</code><br>
<code>shutdown -c</code>取消关机   <br>
<code>shutdown -p</code>立即关机，无提示、延时<br>
<code>shutdown -s</code>关机<br>
<code>shutdown -r</code>重启<br>
<code>shutdown -f</code>强行关闭应用程序<br>
<code>shutdown -l</code>注销当前用户<br>
<code>shutdown -s -t</code> 设置关机倒计时<br>
<code>shutdown -h</code>休眠</p>
</blockquote>
<h4 id="export">export</h4>
<p>设定一些环境变量，env命令能看到当前系统中所有的环境变量。比如，下面设置的就是jdk的。<br>
<code>export PATH=$PATH:/home/xjj/jdk/bin</code><br>
<code>source</code>命令来让其立即生效<br>
set	显示当前 Shell 所有变量，包括<strong>其内建环境变量，用户自定义变量及导出的环境变量。</strong><br>
env	显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。<br>
export	显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</p>
<p>/etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。<br>
<code>unset</code><br>
命令删除一个环境变量</p>
<h1 id="压-解缩">压、解缩</h1>
<h4 id="gzip">gzip</h4>
<blockquote>
<p>压缩文件成者文件夹<br>
-d解压缩文件</p>
</blockquote>
<h4 id="zip">zip</h4>
<blockquote>
<p>将目录 /home/shiyanlou/Desktop 打包成一个文件<br>
<code>zip -r -9 -q -o -l shiyanlou.zip /home/shiyanlou/Desktop</code><br>
-r 参数表示递归打包包含子目录的全部内容，9 压缩级别最大1 最小,<br>
-q 参数表示为安静模式，即不向屏幕输出信息，<br>
-o，表示输出文件,<br>
-l 参数将 LF 转换为 CR+LF 来达到win/linux兼容。</p>
</blockquote>
<h4 id="unzip">unzip</h4>
<blockquote>
<p>将文件解压到指定目录：<br>
<code>unzip -q shiyanlou.zip -d ziptest</code><br>
-q 使用安静模式<br>
-d指定路径<br>
-l 不解压只想查看压缩包的内容<br>
-O（英文字母，大写 o）参数指定编码类型：(win默认会采用 GBK , Linux 默认 UTF-8 )<br>
unzip -O GBK 中文压缩文件.zip</p>
</blockquote>
<h4 id="tar">tar</h4>
<blockquote>
<p><code>tar -xzf shiyanlou.tar.gz -C tardir</code><br>
压缩文件格式<code>-z/*.tar.gz</code>，<code>-J/*.tar.xz</code>	，<code>-j/*tar.bz2</code><br>
-P 保留绝对路径符<br>
-v压缩的过程中显示文件<br>
-c 表示创建一个 tar 包文件<br>
-f 用于指定创建的文件名，件名必须紧跟在 -f 参数之后<br>
-p在其他主机还原时希望保留文件的属性<br>
-h 备份链接指向的源文件而不是链接本身<br>
-x解包一个文件<br>
-C 指定保存路径<br>
-t只查看不解包文件</p>
</blockquote>
<h1 id="vim">VIM</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-de0ac15d12403184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
修改文本<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b6f40fe5095da55e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
定位命令<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-40f8d2a91c245485?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" loading="lazy"><br>
替换和取消命令<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-3192c0b29770869f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
删除命令<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-52358b7bd810c2b8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
常用快捷键<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-c8dc68e3552b4958?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h4 id="alias">alias</h4>
<p><code>alias a='find . -size +10M -type f -print0 | xargs -0 ls -Ssh | sort -z'</code></p>
<h4 id="关闭防火墙">关闭防火墙</h4>
<p>systemctl stop firewalld.service</p>
<h4 id="禁止防火墙开机启动">禁止防火墙开机启动</h4>
<p>systemctl disable firewalld.service</p>
<h4 id="关闭selinux">关闭SELinux</h4>
<p>nano -w /etc/selinux/config<br>
将SELINUX=enforcing改为SELINUX=disabled保存并退出:^x-&gt;y-&gt;回车</p>
<h1 id="计划任务">计划任务</h1>
<p>查看添加了哪些任务<code>crontab -l</code><br>
添加一个计划任务<code>crontab -e</code><br>
删除任务<code>crontab -r</code><br>
<code>分 小时 天 月 星期 user-name command to be executed</code></p>
<p>启动 rsyslog，以便我们可以通过日志中的信息来了解我们的任务是否真正的被执行了<br>
<code>sudo apt-get install -y rsyslog</code><br>
<code>sudo service rsyslog start</code>( Ubuntu 会默认自行启动不需要手动启动)<br>
<code>sudo cron －f &amp;</code>(实验环境中 crontab 也是不被默认启动的，同时不能在后台由 upstart 来管理，所以需要我们来启动它)</p>
<p>每分钟我们会在/home/shiyanlou 目录下创建一个以当前的年月日时分秒为名字的空白文件<br>
<code>*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)</code></p>
<blockquote>
<p>“ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p>
</blockquote>
<p>查看到执行任务命令之后在日志中的信息反馈<br>
<code>sudo tail -f /var/log/syslog</code></p>
<h4 id="有选择的执行命令">有选择的执行命令</h4>
<p><code>which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;</code><br>
<code>&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回 0 则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果</code><br>
<code>||在这里就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为 ≠0($?≠0)时则执行它后面的命令</code><br>
echo $?</p>
]]></content>
    </entry>
</feed>