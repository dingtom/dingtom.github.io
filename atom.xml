<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dingtom.github.io</id>
    <title>Tomding&apos;s Blog</title>
    <updated>2020-11-26T00:39:07.236Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dingtom.github.io"/>
    <link rel="self" href="https://dingtom.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://dingtom.github.io/images/avatar.png</logo>
    <icon>https://dingtom.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Tomding&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[mysql]]></title>
        <id>https://dingtom.github.io/post/mysql/</id>
        <link href="https://dingtom.github.io/post/mysql/">
        </link>
        <updated>2020-11-26T00:38:19.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="安装">安装</h1>
<h2 id="win">win</h2>
<blockquote>
<p>https://dev.mysql.com/downloads/mysql/<br>
<a href="http://mirrors.sohu.com/mysql/MySQL-8.0/">http://mirrors.sohu.com/mysql/MySQL-8.0/</a><br>
配置环境变量path<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-6c5c4e1ade3e95ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b6f751a6e0727c08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
新建一个my.ini 用记事本打开</p>
</blockquote>
<pre><code>[mysqld]
# 设置mysql的安装目录
basedir=D:\\software\\java\\mysql-5.7.28-winx64
# 切记此处一定要用双斜杠\\，单斜杠这里会出错。
# 设置mysql数据库的数据的存放目录
datadir=D:\\software\\java\\mysql-5.7.28-winx64\\Data
# 此处同上
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors=10
# 服务端使用的字符集默认为UTF8
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin=mysql_native_password
[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8
[client]
# 设置mysql客户端连接服务端时默认使用的端口
port=3306
default-character-set=utf8
</code></pre>
<p>管理员权限下运行cmd</p>
<pre><code>mysqld -install
# 执行初始化代码（会在根目录创建data文件夹，并创建root用户）
mysqld --initialize-insecure --user=mysql
# 启动mysql服务
net start mysql
</code></pre>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-3b3965a4ecafa1f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
##ubuntu</p>
</blockquote>
<pre><code>sudo apt-get install mysql-server
#sudo apt-get install mysql-client
</code></pre>
<p><strong>删除 mysql</strong></p>
<pre><code>sudo apt-get autoremove --purge mysql-server
sudo apt-get remove mysql-server
sudo apt-get autoremove mysql-server
sudo apt-get remove mysql-common
</code></pre>
<p><strong>清理残留数据</strong></p>
<pre><code>dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P
</code></pre>
<p>进入mysql</p>
<pre><code>sudo mysql -uroot -p 
</code></pre>
<p>配置 MySQL 的管理员密码：</p>
<pre><code>sudo mysqladmin -u root password newpassword
</code></pre>
<p>安装MySQL-workbench</p>
<pre><code>sudo apt-get install mysql-workbench
</code></pre>
<p>一旦安装完成，MySQL 服务器应该自动启动。您可以在终端提示符后运行以下命令来检查 MySQL 服务器是否正在运行：</p>
<pre><code>sudo netstat -tap | grep mysql
</code></pre>
<p>当您运行该命令时，您可以看到类似下面的行：<br>
tcp 0 0 localhost.localdomain:mysql <em>:</em> LISTEN -<br>
如果服务器不能正常运行，您可以通过下列命令启动它：</p>
<pre><code>sudo /etc/init.d/mysql restart
</code></pre>
<h1 id="增删改查数据库create-drop-alter-show">增删改查数据库(CREATE、DROP、ALTER、SHOW)</h1>
<h2 id="增加">增加：</h2>
<pre><code>create database 库名 default character utf8;
</code></pre>
<h2 id="删除">删除：</h2>
<pre><code>drop database 库名 ;
</code></pre>
<h2 id="修改">修改：</h2>
<pre><code>alter database 库名  default character gbk;
</code></pre>
<h2 id="查询">查询：</h2>
<pre><code>show databases 
</code></pre>
<h2 id="选择数据库">选择数据库：</h2>
<pre><code>use 库名 ;
</code></pre>
<h1 id="增删改表create-drop-alter-rename">增删改表(CREATE、DROP、ALTER、RENAME)</h1>
<h2 id="新建表">新建表</h2>
<pre><code>CREATE TABLE 表名 (
  id int(10) unsigned NOT NULL COMMENT 'Id',
  username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',
  password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',
  email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'
) COMMENT='用户表';
</code></pre>
<p>SELECT  INTO根据已有的表创建新表</p>
<pre><code>SELECT * INTO new_表名 FROM 表名
</code></pre>
<h2 id="删除-2">删除：</h2>
<pre><code>DROP TABLE user;
</code></pre>
<h2 id="修改表名称">修改表名称：</h2>
<pre><code>ALTER TABLE user RENAME  user_new;
</code></pre>
<h1 id="增删改查字段add-drop-column-modify-change-desc">增删改查字段（ADD、DROP COLUMN、MODIFY、CHANGE、DESC）</h1>
<h2 id="添加字段">添加字段：</h2>
<pre><code>ALTER TABLE user ADD age int(3);
</code></pre>
<h2 id="删除字段">删除字段:</h2>
<pre><code>ALTER TABLE user DROP COLUMN age;
</code></pre>
<h2 id="修改字段类型">修改字段类型：</h2>
<pre><code>ALTER TABLE user MODIFY 字段名 新的字段类型;
</code></pre>
<p>mysql 设置字段 not null 变成可以null</p>
<pre><code>ALTER TABLE 表名 MODIFY 字段名 VARCHAR(20) DEFAULT NULL
</code></pre>
<h2 id="修改字段名称-change">修改字段名称 ：CHANGE</h2>
<pre><code>ALTER TABLE user CHANGE 旧字段名 新字段名 字段类型;
</code></pre>
<h2 id="显示表字段信息">显示表字段信息：</h2>
<pre><code>DESC user;
</code></pre>
<h1 id="管理数据">管理数据:</h1>
<h4 id="添加主键">添加主键</h4>
<pre><code>ALTER TABLE user ADD PRIMARY KEY (id);
</code></pre>
<p><strong>删除主键</strong></p>
<pre><code>ALTER TABLE user DROP PRIMARY KEY;
</code></pre>
<p>查询表的大小：</p>
<pre><code>use information_schema;  
select data_length,index_length 
from tables 
where table_schema=库 and table_name = 表 ;
</code></pre>
<h2 id="增加-2">增加：</h2>
<p>插入完整的行</p>
<pre><code>INSERT INTO user VALUES (10, 'root', 'root', 'xxxx@163.com');
</code></pre>
<p>插入行的一部分</p>
<pre><code>INSERT INTO user(username, password, email) VALUES ('admin', 'admin', 'xxxx@163.com');
</code></pre>
<p>插入查询出来的数据</p>
<pre><code>INSERT INTO user(字段) SELECT 字段 FROM account;
</code></pre>
<h2 id="删除-3">删除：</h2>
<h4 id="delete-from">DELETE FROM</h4>
<p>1)可以<strong>带条件删除</strong>2）只能删除表的数据，<strong>不能删除表的约束</strong>3)删除的数据<strong>可以回滚（事务）</strong></p>
<pre><code>DELETE FROM user WHERE username='robot';
</code></pre>
<h4 id="truncate">truncate</h4>
<p>1）不能带条件删除 2）即可以删除表的数据，也可以删除表的约束 3）不能回滚</p>
<pre><code>TRUNCATE TABLE user;
</code></pre>
<h2 id="修改update-set">修改：UPDATE SET</h2>
<pre><code>UPDATE user
SET username='robot', password='robot'
WHERE username = 'root';
</code></pre>
<h2 id="查询-2">查询：</h2>
<p>所有字段：</p>
<pre><code>select * from 表;
</code></pre>
<p>指定字段：</p>
<pre><code>select 字段 from 表;
</code></pre>
<p>指定别名：</p>
<pre><code>select 字段1 as 别名 from 表;
</code></pre>
<p>合并列：</p>
<pre><code>select (字段1+字段2) as “和” from 表;
</code></pre>
<p>去重：</p>
<pre><code>select distinct 字段 from 表;
</code></pre>
<h1 id="特殊字符">特殊字符</h1>
<h2 id="逻辑-and-or-in-not-in">逻辑 ：and、 or、in、not  in</h2>
<p><code>select * from 表 where 条件1 and/or 条件2</code><br>
<code>IN (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</code></p>
<h2 id="比较-between-and">比较： &gt; 、 &lt;  、&gt;= 、 &lt;= 、 =、  !=、 &lt;&gt;、 between  and</h2>
<p><code>select * from 表 where 字段&gt;=条件;</code></p>
<h2 id="模糊-like-替换任意个字符-_替换一个字符">模糊： like  、%（替换任意个字符）、  _（替换一个字符）</h2>
<p><code>SELECT * FROM student WHERE NAME LIKE '李%';</code></p>
<h1 id="判断case-when-条件-then-真的操作-else-假的操作-end-if条件-真的操作-假的操作">判断：（case when 条件 then 真的操作 else 假的操作 end）、if(条件, 真的操作, 假的操作)</h1>
<pre><code>SELECT role,
case when building is not null 
THEN &quot;1&quot; else &quot;0&quot; end
as Wheater
FROM employees
GROUP BY role,Wheater;
</code></pre>
<h2 id="聚合函数">聚合函数：</h2>
<p><strong>聚合函数要使bai用的话du,有一个前提，那就是是必zhi须要有结果集</strong><br>
sum()、avg() 、 max()  、min() 、 count()</p>
<h4 id="count">count()</h4>
<p>COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。</p>
<p><code>SELECT SUM(servlet) AS 'servlet的总成绩' FROM student;</code><br>
<code>SELECT COUNT(*) FROM student;</code></p>
<p>substr(col,0,4)	字符串截取<br>
LOCATE()查找某字符在长字符中的位置<br>
LEFT()、RIGHT()左边或者右边的字符<br>
LOWER()、UPPER()转换为小写或者大写<br>
LTRIM()、RTIM()去除左边或者右边的空格<br>
LENGTH()长度<br>
SOUNDEX()转换为语音值<br>
其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<pre><code>SELECT *
FROM mytable
WHERE SOUNDEX(col1) = SOUNDEX('apple')
</code></pre>
<p>AddDate()增加一个日期（天、周等）<br>
AddTime()增加一个时间（时、分等）<br>
CurDate()返回当前日期<br>
CurTime()返回当前时间<br>
Date()返回日期时间的日期部分<br>
<code>date(paidTime).date_format(paidTime，%Y-%m-d%)</code></p>
<p>DateDiff()计算两个日期之差<br>
Date_Add()高度灵活的日期运算函数<br>
<code>t1.m=date_sub(t2.m, interval 1 month)</code><br>
Date_Format()返回一个格式化的日期或时间串<br>
Day()返回一个日期的天数部分<br>
DayOfWeek()对于一个日期，返回对应的星期几<br>
Hour()返回一个时间的小时部<br>
Minute()返回一个时间的分钟部分<br>
Month()返回一个日期的月份部分<br>
Now()返回当前日期和时间<br>
Second()返回一个时间的秒部分<br>
Time()返回一个日期时间的时间部分<br>
Year()返回一个日期的年份部分</p>
<p>SIN()正弦<br>
COS()余弦<br>
TAN()正切<br>
ABS()绝对值<br>
SQRT()平方根<br>
MOD()余数<br>
EXP()指数<br>
PI()圆周率<br>
RAND()随机数</p>
<h1 id="from-where-group含聚合-having-order-select">from &gt; where &gt; group（含聚合）&gt; having &gt; order &gt; select</h1>
<h2 id="分组查询group-by">分组查询：group by</h2>
<p><strong>group by 后可加聚合函数，where 后不能加聚合函数</strong><br>
把统计函数和GROUP BY结合，那统计结果就是<strong>对分组内的数据统计</strong>了.</p>
<pre><code>SELECT building,count(*) 
FROM employees
WHERE building!='null'
GROUP BY building
;
</code></pre>
<h2 id="分组后筛选-having">分组后筛选： having</h2>
<p>查询总人数大于2的性别<br>
-- 1) 查询男女的人数<br>
-- 2）筛选出人数大于2的记录(having)<br>
--- 注意： 分组之前条件使用where关键字，分组之前条件使用having关键字<br>
<code>SELECT gender,COUNT(*) FROM student WHERE GROUP BY gender HAVING COUNT(*)&gt;2;</code></p>
<h2 id="distinct-唯一">DISTINCT 唯一</h2>
<p><code>SELECT DISTINCT Director FROM movies ASC;</code></p>
<h2 id="分页查询limit-offset">分页查询：limit offset</h2>
<p>起始行,查询行数起始行从0开始<br>
把结果集分页，每页3条记录。要获取第1页的记录<br>
<code>SELECT * FROM student LIMIT 3 OFFSET 0;</code></p>
<h2 id="排序-order-by">排序： order by</h2>
<p>asc: 正序（默认）desc：反序<br>
按照id顺序排序</p>
<pre><code>SELECT * 
FROM movies 
ORDER BY Director ASC,Year DESC 
LIMIT 10 OFFSET 0;
</code></pre>
<h1 id="连接查询多表查询join-on">连接查询（多表查询）JOIN  ON</h1>
<p>主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。借助主键(primary key)（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来</p>
<h2 id="内连接查询只保留id相等的row">内连接查询：只保留id相等的row</h2>
<p><code>t1 INNER JOIN t2 ON t1.id = t2.id</code><br>
需求：存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。</p>
<pre><code>SELECT s.id, s.name,c.name class_name
FROM students s
INNER JOIN classes c
ON s.class_id = c.id;
</code></pre>
<h2 id="左连接查询保留t1的所有row如果某一行在另一个表不存在会用-null来填充结果数据">左连接查询：保留t1的所有row,如果某一行在另一个表不存在，会用 NULL来填充结果数据。</h2>
<p><code>t1 LEFT JOIN t2 ON t1.id = t2.id</code></p>
<pre><code>SELECT d.deptName,e.empName
FROM dept d
          LEFT OUTER JOIN employee e
ON d.id=e.deptId;
</code></pre>
<p>######右连接查询：t1 RIGHT JOIN t2 ON t1.id = t2.id	保留t2的所有row</p>
<h6 id="全连接查询full-join-不管有没有匹配上同时保留a和b里的所有行">全连接查询：FULL JOIN 不管有没有匹配上，同时保留A和B里的所有行</h6>
<h1 id="union">UNION</h1>
<p>将两个或更多查询的结果组合起来，并生成一个结果集</p>
<blockquote>
<p>所有查询的列数和列顺序必须相同。<br>
每个查询中涉及表的列的数据类型必须相同或兼容。<br>
通常返回的列名取自第一个查询。<br>
默认会去除相同行，如果需要保留相同行，使用 UNION ALL。<br>
只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
</blockquote>
<p>应用场景<br>
在一个查询中从不同的表返回结构数据。<br>
对一个表执行多个查询，按一个查询返回数据。<br>
组合查询</p>
<pre><code>SELECT cust_name, cust_contact, cust_email
FROM customers
WHERE cust_state IN ('IL', 'IN', 'MI')
UNION
SELECT cust_name, cust_contact, cust_email
FROM customers
WHERE cust_name = 'Fun4All';
</code></pre>
<p>JOIN vs UNION<br>
JOIN 中连接表的列可能不同，但在 UNION 中，<strong>所有查询的列数和列顺序必须相同。</strong><br>
**UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），**即它构成一个笛卡尔积。</p>
<h1 id="数据约束表约束">数据约束（表约束）</h1>
<pre><code>默认值： default 默认值
非空：   not null
 唯一： unique
主键： primary key （非空+唯一）
 自增长： auto_increment
</code></pre>
<p>######外键： foreign key   约束两种表</p>
<pre><code>CONSTRAINT emlyee_dept_fk 
FOREIGN KEY(deptId) 
REFERENCES dept(id)  
ON UPDATE CASCADE ON DELETE CASCADE  -- ON CASCADE
</code></pre>
<pre><code>ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
</code></pre>
<p>其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。</p>
<pre><code>ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
</code></pre>
<p>注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。</p>
<p>######UPDATE ：级联修改<br>
外键名称                  外键               参考表(参考字段)<br>
注意：<br>
1）被约束的表称为副表，约束别人的表称为主表，外键设置在副表上的！！！<br>
2）主表的参考字段通用为主键！<br>
3）添加数据： 先添加主表，再添加副表<br>
4）修改数据： 先修改副表，再修改主表<br>
5）删除数据： 先删除副表，再删除主表<br>
当有了外键约束的时候，必须先修改或删除副表中的所有关联数据，才能修改或删除主表！但是，我们希望直接修改或删除主表数据，从而影响副表数据。可以使用级联操作实现！！！</p>
<p>存储过程<br>
-- 创建存储过程</p>
<pre><code>DELIMITER $       -- 声明存储过程的结束符
CREATE PROCEDURE pro_test()           --存储过程名称(参数列表)
BEGIN             -- 开始
    -- 可以写多个sql语句;          -- sql语句+流程控制
    SELECT * FROM employee;
END $            -- 结束 结束符
</code></pre>
<p>-- 执行存储过程</p>
<pre><code>CALL pro_test();          -- CALL 存储过程名称(参数);
</code></pre>
<p>-- 删除存储过程</p>
<pre><code>DROP PROCEDURE pro_testOut;
</code></pre>
<ul>
<li>全局变量（内置变量）：mysql数据库内置的变量 （所有连接都起作用）<br>
-- 查看所有全局变量： show variables<br>
-- 查看某个全局变量： select @@变量名<br>
-- 修改全局变量： set 变量名=新值<br>
--  会话变量： 只存在于当前客户端与数据库服务器端的一次连接当中。如果连接断开，那么会话变量全部丢失！<br>
-- 定义会话变量: set @变量=值<br>
-- 查看会话变量： select @变量</li>
</ul>
<p>-- 局部变量： 在存储过程中使用的变量就叫局部变量。只要存储过程执行完毕，局部变量就丢失！！</p>
<ul>
<li>3.3 带有输入输出参数的存储过程</li>
</ul>
<pre><code>  DELIMITER $
  CREATE PROCEDURE pro_testInOut(INOUT n INT)  -- INOUT： 输入输出参数
  BEGIN
   SELECT n;   过程中的变量都是局部变量
   SET n =500;
  END $
  SET @n=10;
  CALL pro_testInOut(@n);
  SELECT @n;
IF num=1    THEN  SET str='星期一';
ELSEIF num=2 THEN  SET str='星期二';
ELSE               SET str='输入错误';
END IF;
</code></pre>
<p>-- 定义一个局部变量</p>
<pre><code>    DECLARE i INT DEFAULT 1;
    DECLARE vsum INT DEFAULT 0;
    WHILE i&lt;=num DO
          SET vsum = vsum+i;
          SET i=i+1;
    END WHILE;
    SET result=vsum;
</code></pre>
<p>-- 3.6 使用查询的结果赋值给变量（INTO）</p>
<pre><code>DELIMITER $
CREATE PROCEDURE pro_findById2(IN eid INT,OUT vname VARCHAR(20) )
BEGIN
    SELECT empName INTO vname FROM employee WHERE id=eid;
END $
CALL pro_findById2(1,@NAME);
SELECT @NAME;
</code></pre>
<p>-- 创建触发器(添加)</p>
<pre><code>CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW    -- 当往员工表插入一条记录时
     INSERT INTO test_log(content) VALUES('员工表插入了一条记录');
</code></pre>
<p>-- 创建触发器(修改)</p>
<pre><code>CREATE TRIGGER tri_empUpd AFTER UPDATE ON employee FOR EACH ROW    -- 当往员工表修改一条记录时
     INSERT INTO test_log(content) VALUES('员工表修改了一条记录');
</code></pre>
<p>-- 创建触发器(删除)</p>
<pre><code>CREATE TRIGGER tri_empDel AFTER DELETE ON employee FOR EACH ROW    -- 当往员工表删除一条记录时
     INSERT INTO test_log(content) VALUES('员工表删除了一条记录');
</code></pre>
<h1 id="远程连接">远程连接</h1>
<h2 id="查看当前的用户">查看当前的用户</h2>
<p><code>USE mysql;</code><br>
<code>SELECT * FROM user;</code></p>
<h2 id="修改密码">修改密码</h2>
<p>@前用户名@后地址（ % 代表可以任意ip访问）<br>
<code>LTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED BY &quot;root&quot;;</code></p>
<h2 id="创建新用户">创建新用户</h2>
<p><code>CREATE USER 'new_user'@'%' IDENTIFIED BY 'passwd';</code></p>
<h2 id="给用户赋权限">给用户赋权限</h2>
<p>这里我赋的是全部的权限，<em>.</em> 表示数据库库的所有库和表，对应权限存储在mysql.user表中<br>
<code>GRANT ALL ON *.* TO 'new_user'@'%';</code></p>
<p><code>GRANT SELECT, UPDATE ON day16.employee TO 'eric'@'localhost' IDENTIFIED BY '123456';</code></p>
<h2 id="刷新权限">刷新权限</h2>
<p><code>flush privileges;</code></p>
<h2 id="取消远程控制">取消远程控制</h2>
<p><code>update user set host='localhost' where user='用户名';</code></p>
<h2 id="删除用户">删除用户</h2>
<p><code>delete from user where user=&quot;用户名&quot; and host='host权限（localhost/%）';</code></p>
<blockquote>
<p><strong>开放3306端口</strong><br>
1.控制面板—系统和安全—windows防火墙—攻击设置—入栈规则<br>
2.新建规则—选择端口<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e649fed7e43e6b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
3.指定开放的端口<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-a40b2644f02b64a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
4.允许连接，一直点下一步即可<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-4610a319e4a4f648.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
</blockquote>
<h1 id="pymysql模块">PyMySQL模块</h1>
<p>是默认开启MySQL的事务功能的，<br>
因此，进行 &quot;增&quot;、 &quot;删&quot;、&quot;改&quot;的时候，一定要使用db.commit()提交事务<br>
一定要使用try…except…语句，因为万一没插入成功，其余代码都无法执行。当语句执行不成功，<br>
我们就db.rollback()回滚到操作之前的状态；当语句执行成功，我们就db.commit()提交事务。</p>
<pre><code>import pymysql 
# 使用pymysql连接上mysql数据库服务器，创建了一个数据库对象；
db=pymysql.connect(host='localhost',user='root', password='',
                   port=3306, db='test', charset='utf8')
# 开启mysql的游标功能，创建一个游标对象；
cursor = db.cursor()

# 建表语句；
sql = &quot;&quot;&quot;create table person(
        id int auto_increment primary key not null,
        name varchar(10) not null,
        age int not null) charset=utf8&quot;&quot;&quot;
# 执行sql语句；
cursor.execute(sql)

# 一次性插入一条数据；
name = &quot;猪八戒&quot;
age = 8000
sql = &quot;&quot;&quot;
insert into person(name,age) values (&quot;猪八戒&quot;,8000)
&quot;&quot;&quot;
try:
    cursor.execute(sql)
    db.commit()
    print(&quot;插入成功&quot;)
except:
    print(&quot;插入失败&quot;)
    db.rollback()

# 要执行的SQL语句；
sql = &quot;select * from person&quot;
# execute(query, args)：执行单条sql语句，接收的参数为sql语句本身和使用的参数列表，返回值为受影响的行数；
# executemany(query, args)：执行单条sql语句，但是重复执行参数列表里的参数，返回值为受影响的行数；
cursor.execute(sql)
# fetchone()：返回一条结果行；
# fetchmany(size)：接收size条返回结果行。如果size的值大于返回的结果行的数量，则会返回cursor.arraysize条数据；
# fetchall()：接收全部的返回结果行；
data = cursor.fetchone()
print(data)
db.close()
</code></pre>
<h1 id="使用pandas">使用pandas</h1>
<p>中的read_sql()方法，将提取到的数据直接转化为DataFrame，进行操作</p>
<pre><code>df1 = pd.read_sql(&quot;select * from student where ssex='男'&quot;,db)
display(df1)
df2 = pd.read_sql(&quot;select * from student where ssex='女'&quot;,db)
display(df2)
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<h2 id="win">win</h2>
<blockquote>
<p>https://dev.mysql.com/downloads/mysql/<br>
<a href="http://mirrors.sohu.com/mysql/MySQL-8.0/">http://mirrors.sohu.com/mysql/MySQL-8.0/</a><br>
配置环境变量path<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-6c5c4e1ade3e95ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b6f751a6e0727c08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
新建一个my.ini 用记事本打开</p>
</blockquote>
<pre><code>[mysqld]
# 设置mysql的安装目录
basedir=D:\\software\\java\\mysql-5.7.28-winx64
# 切记此处一定要用双斜杠\\，单斜杠这里会出错。
# 设置mysql数据库的数据的存放目录
datadir=D:\\software\\java\\mysql-5.7.28-winx64\\Data
# 此处同上
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors=10
# 服务端使用的字符集默认为UTF8
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin=mysql_native_password
[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8
[client]
# 设置mysql客户端连接服务端时默认使用的端口
port=3306
default-character-set=utf8
</code></pre>
<p>管理员权限下运行cmd</p>
<pre><code>mysqld -install
# 执行初始化代码（会在根目录创建data文件夹，并创建root用户）
mysqld --initialize-insecure --user=mysql
# 启动mysql服务
net start mysql
</code></pre>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-3b3965a4ecafa1f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
##ubuntu</p>
</blockquote>
<pre><code>sudo apt-get install mysql-server
#sudo apt-get install mysql-client
</code></pre>
<p><strong>删除 mysql</strong></p>
<pre><code>sudo apt-get autoremove --purge mysql-server
sudo apt-get remove mysql-server
sudo apt-get autoremove mysql-server
sudo apt-get remove mysql-common
</code></pre>
<p><strong>清理残留数据</strong></p>
<pre><code>dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P
</code></pre>
<p>进入mysql</p>
<pre><code>sudo mysql -uroot -p 
</code></pre>
<p>配置 MySQL 的管理员密码：</p>
<pre><code>sudo mysqladmin -u root password newpassword
</code></pre>
<p>安装MySQL-workbench</p>
<pre><code>sudo apt-get install mysql-workbench
</code></pre>
<p>一旦安装完成，MySQL 服务器应该自动启动。您可以在终端提示符后运行以下命令来检查 MySQL 服务器是否正在运行：</p>
<pre><code>sudo netstat -tap | grep mysql
</code></pre>
<p>当您运行该命令时，您可以看到类似下面的行：<br>
tcp 0 0 localhost.localdomain:mysql <em>:</em> LISTEN -<br>
如果服务器不能正常运行，您可以通过下列命令启动它：</p>
<pre><code>sudo /etc/init.d/mysql restart
</code></pre>
<h1 id="增删改查数据库create-drop-alter-show">增删改查数据库(CREATE、DROP、ALTER、SHOW)</h1>
<h2 id="增加">增加：</h2>
<pre><code>create database 库名 default character utf8;
</code></pre>
<h2 id="删除">删除：</h2>
<pre><code>drop database 库名 ;
</code></pre>
<h2 id="修改">修改：</h2>
<pre><code>alter database 库名  default character gbk;
</code></pre>
<h2 id="查询">查询：</h2>
<pre><code>show databases 
</code></pre>
<h2 id="选择数据库">选择数据库：</h2>
<pre><code>use 库名 ;
</code></pre>
<h1 id="增删改表create-drop-alter-rename">增删改表(CREATE、DROP、ALTER、RENAME)</h1>
<h2 id="新建表">新建表</h2>
<pre><code>CREATE TABLE 表名 (
  id int(10) unsigned NOT NULL COMMENT 'Id',
  username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',
  password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',
  email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'
) COMMENT='用户表';
</code></pre>
<p>SELECT  INTO根据已有的表创建新表</p>
<pre><code>SELECT * INTO new_表名 FROM 表名
</code></pre>
<h2 id="删除-2">删除：</h2>
<pre><code>DROP TABLE user;
</code></pre>
<h2 id="修改表名称">修改表名称：</h2>
<pre><code>ALTER TABLE user RENAME  user_new;
</code></pre>
<h1 id="增删改查字段add-drop-column-modify-change-desc">增删改查字段（ADD、DROP COLUMN、MODIFY、CHANGE、DESC）</h1>
<h2 id="添加字段">添加字段：</h2>
<pre><code>ALTER TABLE user ADD age int(3);
</code></pre>
<h2 id="删除字段">删除字段:</h2>
<pre><code>ALTER TABLE user DROP COLUMN age;
</code></pre>
<h2 id="修改字段类型">修改字段类型：</h2>
<pre><code>ALTER TABLE user MODIFY 字段名 新的字段类型;
</code></pre>
<p>mysql 设置字段 not null 变成可以null</p>
<pre><code>ALTER TABLE 表名 MODIFY 字段名 VARCHAR(20) DEFAULT NULL
</code></pre>
<h2 id="修改字段名称-change">修改字段名称 ：CHANGE</h2>
<pre><code>ALTER TABLE user CHANGE 旧字段名 新字段名 字段类型;
</code></pre>
<h2 id="显示表字段信息">显示表字段信息：</h2>
<pre><code>DESC user;
</code></pre>
<h1 id="管理数据">管理数据:</h1>
<h4 id="添加主键">添加主键</h4>
<pre><code>ALTER TABLE user ADD PRIMARY KEY (id);
</code></pre>
<p><strong>删除主键</strong></p>
<pre><code>ALTER TABLE user DROP PRIMARY KEY;
</code></pre>
<p>查询表的大小：</p>
<pre><code>use information_schema;  
select data_length,index_length 
from tables 
where table_schema=库 and table_name = 表 ;
</code></pre>
<h2 id="增加-2">增加：</h2>
<p>插入完整的行</p>
<pre><code>INSERT INTO user VALUES (10, 'root', 'root', 'xxxx@163.com');
</code></pre>
<p>插入行的一部分</p>
<pre><code>INSERT INTO user(username, password, email) VALUES ('admin', 'admin', 'xxxx@163.com');
</code></pre>
<p>插入查询出来的数据</p>
<pre><code>INSERT INTO user(字段) SELECT 字段 FROM account;
</code></pre>
<h2 id="删除-3">删除：</h2>
<h4 id="delete-from">DELETE FROM</h4>
<p>1)可以<strong>带条件删除</strong>2）只能删除表的数据，<strong>不能删除表的约束</strong>3)删除的数据<strong>可以回滚（事务）</strong></p>
<pre><code>DELETE FROM user WHERE username='robot';
</code></pre>
<h4 id="truncate">truncate</h4>
<p>1）不能带条件删除 2）即可以删除表的数据，也可以删除表的约束 3）不能回滚</p>
<pre><code>TRUNCATE TABLE user;
</code></pre>
<h2 id="修改update-set">修改：UPDATE SET</h2>
<pre><code>UPDATE user
SET username='robot', password='robot'
WHERE username = 'root';
</code></pre>
<h2 id="查询-2">查询：</h2>
<p>所有字段：</p>
<pre><code>select * from 表;
</code></pre>
<p>指定字段：</p>
<pre><code>select 字段 from 表;
</code></pre>
<p>指定别名：</p>
<pre><code>select 字段1 as 别名 from 表;
</code></pre>
<p>合并列：</p>
<pre><code>select (字段1+字段2) as “和” from 表;
</code></pre>
<p>去重：</p>
<pre><code>select distinct 字段 from 表;
</code></pre>
<h1 id="特殊字符">特殊字符</h1>
<h2 id="逻辑-and-or-in-not-in">逻辑 ：and、 or、in、not  in</h2>
<p><code>select * from 表 where 条件1 and/or 条件2</code><br>
<code>IN (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</code></p>
<h2 id="比较-between-and">比较： &gt; 、 &lt;  、&gt;= 、 &lt;= 、 =、  !=、 &lt;&gt;、 between  and</h2>
<p><code>select * from 表 where 字段&gt;=条件;</code></p>
<h2 id="模糊-like-替换任意个字符-_替换一个字符">模糊： like  、%（替换任意个字符）、  _（替换一个字符）</h2>
<p><code>SELECT * FROM student WHERE NAME LIKE '李%';</code></p>
<h1 id="判断case-when-条件-then-真的操作-else-假的操作-end-if条件-真的操作-假的操作">判断：（case when 条件 then 真的操作 else 假的操作 end）、if(条件, 真的操作, 假的操作)</h1>
<pre><code>SELECT role,
case when building is not null 
THEN &quot;1&quot; else &quot;0&quot; end
as Wheater
FROM employees
GROUP BY role,Wheater;
</code></pre>
<h2 id="聚合函数">聚合函数：</h2>
<p><strong>聚合函数要使bai用的话du,有一个前提，那就是是必zhi须要有结果集</strong><br>
sum()、avg() 、 max()  、min() 、 count()</p>
<h4 id="count">count()</h4>
<p>COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。</p>
<p><code>SELECT SUM(servlet) AS 'servlet的总成绩' FROM student;</code><br>
<code>SELECT COUNT(*) FROM student;</code></p>
<p>substr(col,0,4)	字符串截取<br>
LOCATE()查找某字符在长字符中的位置<br>
LEFT()、RIGHT()左边或者右边的字符<br>
LOWER()、UPPER()转换为小写或者大写<br>
LTRIM()、RTIM()去除左边或者右边的空格<br>
LENGTH()长度<br>
SOUNDEX()转换为语音值<br>
其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<pre><code>SELECT *
FROM mytable
WHERE SOUNDEX(col1) = SOUNDEX('apple')
</code></pre>
<p>AddDate()增加一个日期（天、周等）<br>
AddTime()增加一个时间（时、分等）<br>
CurDate()返回当前日期<br>
CurTime()返回当前时间<br>
Date()返回日期时间的日期部分<br>
<code>date(paidTime).date_format(paidTime，%Y-%m-d%)</code></p>
<p>DateDiff()计算两个日期之差<br>
Date_Add()高度灵活的日期运算函数<br>
<code>t1.m=date_sub(t2.m, interval 1 month)</code><br>
Date_Format()返回一个格式化的日期或时间串<br>
Day()返回一个日期的天数部分<br>
DayOfWeek()对于一个日期，返回对应的星期几<br>
Hour()返回一个时间的小时部<br>
Minute()返回一个时间的分钟部分<br>
Month()返回一个日期的月份部分<br>
Now()返回当前日期和时间<br>
Second()返回一个时间的秒部分<br>
Time()返回一个日期时间的时间部分<br>
Year()返回一个日期的年份部分</p>
<p>SIN()正弦<br>
COS()余弦<br>
TAN()正切<br>
ABS()绝对值<br>
SQRT()平方根<br>
MOD()余数<br>
EXP()指数<br>
PI()圆周率<br>
RAND()随机数</p>
<h1 id="from-where-group含聚合-having-order-select">from &gt; where &gt; group（含聚合）&gt; having &gt; order &gt; select</h1>
<h2 id="分组查询group-by">分组查询：group by</h2>
<p><strong>group by 后可加聚合函数，where 后不能加聚合函数</strong><br>
把统计函数和GROUP BY结合，那统计结果就是<strong>对分组内的数据统计</strong>了.</p>
<pre><code>SELECT building,count(*) 
FROM employees
WHERE building!='null'
GROUP BY building
;
</code></pre>
<h2 id="分组后筛选-having">分组后筛选： having</h2>
<p>查询总人数大于2的性别<br>
-- 1) 查询男女的人数<br>
-- 2）筛选出人数大于2的记录(having)<br>
--- 注意： 分组之前条件使用where关键字，分组之前条件使用having关键字<br>
<code>SELECT gender,COUNT(*) FROM student WHERE GROUP BY gender HAVING COUNT(*)&gt;2;</code></p>
<h2 id="distinct-唯一">DISTINCT 唯一</h2>
<p><code>SELECT DISTINCT Director FROM movies ASC;</code></p>
<h2 id="分页查询limit-offset">分页查询：limit offset</h2>
<p>起始行,查询行数起始行从0开始<br>
把结果集分页，每页3条记录。要获取第1页的记录<br>
<code>SELECT * FROM student LIMIT 3 OFFSET 0;</code></p>
<h2 id="排序-order-by">排序： order by</h2>
<p>asc: 正序（默认）desc：反序<br>
按照id顺序排序</p>
<pre><code>SELECT * 
FROM movies 
ORDER BY Director ASC,Year DESC 
LIMIT 10 OFFSET 0;
</code></pre>
<h1 id="连接查询多表查询join-on">连接查询（多表查询）JOIN  ON</h1>
<p>主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。借助主键(primary key)（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来</p>
<h2 id="内连接查询只保留id相等的row">内连接查询：只保留id相等的row</h2>
<p><code>t1 INNER JOIN t2 ON t1.id = t2.id</code><br>
需求：存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。</p>
<pre><code>SELECT s.id, s.name,c.name class_name
FROM students s
INNER JOIN classes c
ON s.class_id = c.id;
</code></pre>
<h2 id="左连接查询保留t1的所有row如果某一行在另一个表不存在会用-null来填充结果数据">左连接查询：保留t1的所有row,如果某一行在另一个表不存在，会用 NULL来填充结果数据。</h2>
<p><code>t1 LEFT JOIN t2 ON t1.id = t2.id</code></p>
<pre><code>SELECT d.deptName,e.empName
FROM dept d
          LEFT OUTER JOIN employee e
ON d.id=e.deptId;
</code></pre>
<p>######右连接查询：t1 RIGHT JOIN t2 ON t1.id = t2.id	保留t2的所有row</p>
<h6 id="全连接查询full-join-不管有没有匹配上同时保留a和b里的所有行">全连接查询：FULL JOIN 不管有没有匹配上，同时保留A和B里的所有行</h6>
<h1 id="union">UNION</h1>
<p>将两个或更多查询的结果组合起来，并生成一个结果集</p>
<blockquote>
<p>所有查询的列数和列顺序必须相同。<br>
每个查询中涉及表的列的数据类型必须相同或兼容。<br>
通常返回的列名取自第一个查询。<br>
默认会去除相同行，如果需要保留相同行，使用 UNION ALL。<br>
只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
</blockquote>
<p>应用场景<br>
在一个查询中从不同的表返回结构数据。<br>
对一个表执行多个查询，按一个查询返回数据。<br>
组合查询</p>
<pre><code>SELECT cust_name, cust_contact, cust_email
FROM customers
WHERE cust_state IN ('IL', 'IN', 'MI')
UNION
SELECT cust_name, cust_contact, cust_email
FROM customers
WHERE cust_name = 'Fun4All';
</code></pre>
<p>JOIN vs UNION<br>
JOIN 中连接表的列可能不同，但在 UNION 中，<strong>所有查询的列数和列顺序必须相同。</strong><br>
**UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），**即它构成一个笛卡尔积。</p>
<h1 id="数据约束表约束">数据约束（表约束）</h1>
<pre><code>默认值： default 默认值
非空：   not null
 唯一： unique
主键： primary key （非空+唯一）
 自增长： auto_increment
</code></pre>
<p>######外键： foreign key   约束两种表</p>
<pre><code>CONSTRAINT emlyee_dept_fk 
FOREIGN KEY(deptId) 
REFERENCES dept(id)  
ON UPDATE CASCADE ON DELETE CASCADE  -- ON CASCADE
</code></pre>
<pre><code>ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
</code></pre>
<p>其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。</p>
<pre><code>ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
</code></pre>
<p>注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。</p>
<p>######UPDATE ：级联修改<br>
外键名称                  外键               参考表(参考字段)<br>
注意：<br>
1）被约束的表称为副表，约束别人的表称为主表，外键设置在副表上的！！！<br>
2）主表的参考字段通用为主键！<br>
3）添加数据： 先添加主表，再添加副表<br>
4）修改数据： 先修改副表，再修改主表<br>
5）删除数据： 先删除副表，再删除主表<br>
当有了外键约束的时候，必须先修改或删除副表中的所有关联数据，才能修改或删除主表！但是，我们希望直接修改或删除主表数据，从而影响副表数据。可以使用级联操作实现！！！</p>
<p>存储过程<br>
-- 创建存储过程</p>
<pre><code>DELIMITER $       -- 声明存储过程的结束符
CREATE PROCEDURE pro_test()           --存储过程名称(参数列表)
BEGIN             -- 开始
    -- 可以写多个sql语句;          -- sql语句+流程控制
    SELECT * FROM employee;
END $            -- 结束 结束符
</code></pre>
<p>-- 执行存储过程</p>
<pre><code>CALL pro_test();          -- CALL 存储过程名称(参数);
</code></pre>
<p>-- 删除存储过程</p>
<pre><code>DROP PROCEDURE pro_testOut;
</code></pre>
<ul>
<li>全局变量（内置变量）：mysql数据库内置的变量 （所有连接都起作用）<br>
-- 查看所有全局变量： show variables<br>
-- 查看某个全局变量： select @@变量名<br>
-- 修改全局变量： set 变量名=新值<br>
--  会话变量： 只存在于当前客户端与数据库服务器端的一次连接当中。如果连接断开，那么会话变量全部丢失！<br>
-- 定义会话变量: set @变量=值<br>
-- 查看会话变量： select @变量</li>
</ul>
<p>-- 局部变量： 在存储过程中使用的变量就叫局部变量。只要存储过程执行完毕，局部变量就丢失！！</p>
<ul>
<li>3.3 带有输入输出参数的存储过程</li>
</ul>
<pre><code>  DELIMITER $
  CREATE PROCEDURE pro_testInOut(INOUT n INT)  -- INOUT： 输入输出参数
  BEGIN
   SELECT n;   过程中的变量都是局部变量
   SET n =500;
  END $
  SET @n=10;
  CALL pro_testInOut(@n);
  SELECT @n;
IF num=1    THEN  SET str='星期一';
ELSEIF num=2 THEN  SET str='星期二';
ELSE               SET str='输入错误';
END IF;
</code></pre>
<p>-- 定义一个局部变量</p>
<pre><code>    DECLARE i INT DEFAULT 1;
    DECLARE vsum INT DEFAULT 0;
    WHILE i&lt;=num DO
          SET vsum = vsum+i;
          SET i=i+1;
    END WHILE;
    SET result=vsum;
</code></pre>
<p>-- 3.6 使用查询的结果赋值给变量（INTO）</p>
<pre><code>DELIMITER $
CREATE PROCEDURE pro_findById2(IN eid INT,OUT vname VARCHAR(20) )
BEGIN
    SELECT empName INTO vname FROM employee WHERE id=eid;
END $
CALL pro_findById2(1,@NAME);
SELECT @NAME;
</code></pre>
<p>-- 创建触发器(添加)</p>
<pre><code>CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW    -- 当往员工表插入一条记录时
     INSERT INTO test_log(content) VALUES('员工表插入了一条记录');
</code></pre>
<p>-- 创建触发器(修改)</p>
<pre><code>CREATE TRIGGER tri_empUpd AFTER UPDATE ON employee FOR EACH ROW    -- 当往员工表修改一条记录时
     INSERT INTO test_log(content) VALUES('员工表修改了一条记录');
</code></pre>
<p>-- 创建触发器(删除)</p>
<pre><code>CREATE TRIGGER tri_empDel AFTER DELETE ON employee FOR EACH ROW    -- 当往员工表删除一条记录时
     INSERT INTO test_log(content) VALUES('员工表删除了一条记录');
</code></pre>
<h1 id="远程连接">远程连接</h1>
<h2 id="查看当前的用户">查看当前的用户</h2>
<p><code>USE mysql;</code><br>
<code>SELECT * FROM user;</code></p>
<h2 id="修改密码">修改密码</h2>
<p>@前用户名@后地址（ % 代表可以任意ip访问）<br>
<code>LTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED BY &quot;root&quot;;</code></p>
<h2 id="创建新用户">创建新用户</h2>
<p><code>CREATE USER 'new_user'@'%' IDENTIFIED BY 'passwd';</code></p>
<h2 id="给用户赋权限">给用户赋权限</h2>
<p>这里我赋的是全部的权限，<em>.</em> 表示数据库库的所有库和表，对应权限存储在mysql.user表中<br>
<code>GRANT ALL ON *.* TO 'new_user'@'%';</code></p>
<p><code>GRANT SELECT, UPDATE ON day16.employee TO 'eric'@'localhost' IDENTIFIED BY '123456';</code></p>
<h2 id="刷新权限">刷新权限</h2>
<p><code>flush privileges;</code></p>
<h2 id="取消远程控制">取消远程控制</h2>
<p><code>update user set host='localhost' where user='用户名';</code></p>
<h2 id="删除用户">删除用户</h2>
<p><code>delete from user where user=&quot;用户名&quot; and host='host权限（localhost/%）';</code></p>
<blockquote>
<p><strong>开放3306端口</strong><br>
1.控制面板—系统和安全—windows防火墙—攻击设置—入栈规则<br>
2.新建规则—选择端口<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-e649fed7e43e6b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
3.指定开放的端口<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-a40b2644f02b64a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
4.允许连接，一直点下一步即可<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-4610a319e4a4f648.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
</blockquote>
<h1 id="pymysql模块">PyMySQL模块</h1>
<p>是默认开启MySQL的事务功能的，<br>
因此，进行 &quot;增&quot;、 &quot;删&quot;、&quot;改&quot;的时候，一定要使用db.commit()提交事务<br>
一定要使用try…except…语句，因为万一没插入成功，其余代码都无法执行。当语句执行不成功，<br>
我们就db.rollback()回滚到操作之前的状态；当语句执行成功，我们就db.commit()提交事务。</p>
<pre><code>import pymysql 
# 使用pymysql连接上mysql数据库服务器，创建了一个数据库对象；
db=pymysql.connect(host='localhost',user='root', password='',
                   port=3306, db='test', charset='utf8')
# 开启mysql的游标功能，创建一个游标对象；
cursor = db.cursor()

# 建表语句；
sql = &quot;&quot;&quot;create table person(
        id int auto_increment primary key not null,
        name varchar(10) not null,
        age int not null) charset=utf8&quot;&quot;&quot;
# 执行sql语句；
cursor.execute(sql)

# 一次性插入一条数据；
name = &quot;猪八戒&quot;
age = 8000
sql = &quot;&quot;&quot;
insert into person(name,age) values (&quot;猪八戒&quot;,8000)
&quot;&quot;&quot;
try:
    cursor.execute(sql)
    db.commit()
    print(&quot;插入成功&quot;)
except:
    print(&quot;插入失败&quot;)
    db.rollback()

# 要执行的SQL语句；
sql = &quot;select * from person&quot;
# execute(query, args)：执行单条sql语句，接收的参数为sql语句本身和使用的参数列表，返回值为受影响的行数；
# executemany(query, args)：执行单条sql语句，但是重复执行参数列表里的参数，返回值为受影响的行数；
cursor.execute(sql)
# fetchone()：返回一条结果行；
# fetchmany(size)：接收size条返回结果行。如果size的值大于返回的结果行的数量，则会返回cursor.arraysize条数据；
# fetchall()：接收全部的返回结果行；
data = cursor.fetchone()
print(data)
db.close()
</code></pre>
<h1 id="使用pandas">使用pandas</h1>
<p>中的read_sql()方法，将提取到的数据直接转化为DataFrame，进行操作</p>
<pre><code>df1 = pd.read_sql(&quot;select * from student where ssex='男'&quot;,db)
display(df1)
df2 = pd.read_sql(&quot;select * from student where ssex='女'&quot;,db)
display(df2)
</code></pre>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安装nvidia显卡驱动]]></title>
        <id>https://dingtom.github.io/post/an-zhuang-nvidia-xian-qia-qu-dong/</id>
        <link href="https://dingtom.github.io/post/an-zhuang-nvidia-xian-qia-qu-dong/">
        </link>
        <updated>2020-11-25T07:17:28.000Z</updated>
        <content type="html"><![CDATA[<p>查看显卡型号<br>
<code>lsb_release -a</code></p>
<p>更新PCI ID数据库<br>
<code>update-pciids</code><br>
<code>lspci | grep -i nvidia</code></p>
<p>驱动安装<br>
<code>wget https://us.download.nvidia.com/XFree86/Linux-x86_64/455.23.04/NVIDIA-Linux-x86_64-455.23.04.run</code><br>
查看TMPDIR目录是否报错<br>
<code>echo $TMPDIR</code></p>
<p>安装驱动</p>
<p><code>sudo bash NVIDIA-Linux-x86_64-455.23.04.run</code></p>
<p>禁用nouveau<br>
<code>lsmod | grep nouveau</code></p>
<p><code>vim /etc/modprobe.d/blacklist.conf</code>添加<br>
<code>blacklist nouveau</code></p>
<p><code>sudo update-initramfs -u</code></p>
<p><code>sudo reboot now</code></p>
<p>查看显卡信息<br>
<code>nvidia-smi</code></p>
<h1 id="安装cuda">安装cuda</h1>
<p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1804&amp;target_type=deblocal">download</a></p>
<h6 id="查看cuda版本">查看cuda版本</h6>
<p><code>nvcc -V</code><br>
不显示</p>
<blockquote>
<p>首先，查看cuda的bin目录下是否有nvcc：<br>
<code>ls /usr/local/cuda/bin</code><br>
如果存在，直接将cuda路径加入系统路径即可：<br>
<code>vim ~/.bashrc</code>进入配置文件；<br>
添加以下两行：<br>
<code>export PATH=/usr/local/cuda/bin:$PATH</code><br>
<code>export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH</code><br>
然后更新配置文件：<br>
<code>source ~/.bashrc</code></p>
</blockquote>
<h1 id="安装cudnn">安装cudnn</h1>
<p><a href="https://developer.nvidia.com/rdp/cudnn-archive">download</a><br>
<code>tar -xvf cudnn-8.0-linux-x64-v5.1.tgz</code><br>
安装cuDNN比较简单，解压后把相应的文件拷贝到对应的CUDA目录下即可</p>
<p><code>sudo cp cuda/include/cudnn.h /usr/local/cuda/include/</code><br>
<code>sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/</code><br>
<code>sudo chmod a+r /usr/local/cuda/include/cudnn.h</code><br>
<code>sudo chmod a+r /usr/local/cuda/lib64/libcudnn*</code></p>
<h1 id="卸载显卡驱动重新安装">卸载显卡驱动重新安装</h1>
<p>命令行界面<br>
Ctrl+Alt+F1</p>
<p><code>sudo apt-get --purge remove nvidia*</code></p>
<p><code>sudo apt autoremove</code></p>
<p>To remove CUDA Toolkit:<br>
<code>sudo apt-get --purge remove &quot;*cublas*&quot; &quot;cuda*&quot;</code><br>
To remove NVIDIA Drivers:<br>
<code>sudo apt-get --purge remove &quot;*nvidia*&quot;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu安装Samba分享文件夹]]></title>
        <id>https://dingtom.github.io/post/ubuntu-an-zhuang-samba-fen-xiang-wen-jian-jia/</id>
        <link href="https://dingtom.github.io/post/ubuntu-an-zhuang-samba-fen-xiang-wen-jian-jia/">
        </link>
        <updated>2020-11-25T07:17:06.000Z</updated>
        <content type="html"><![CDATA[<p>安装samba服务器。<br>
<code>sudo apt-get install samba samba-common</code><br>
创建一个用于分享的samba目录。<br>
<code>sudo mkdir /home/zut_csi/tomding/share</code><br>
给创建的这个目录设置权限<br>
<code>sudo chmod 777 /home/zut_csi/tomding/share</code><br>
添加用户(下面的zut_csi是我的用户名，之后会需要设置samba的密码)。<br>
<code>sudo smbpasswd -a zut_csi</code><br>
配置samba的配置文件。<br>
<code>sudo vim /etc/samba/smb.conf</code></p>
<p>在配置文件smb.conf的最后添加下面的内容：</p>
<pre><code>[share]
comment = share folder
browseable = yes
path = /home/zut_csi/tomding/share
create mask = 0700
directory mask = 0700
valid users = zut_csi
force user = zut_csi
force group = zut_csi
public = yes
browseable = yes
read only = no
available = yes
writable = yes
security = share
</code></pre>
<p>重启samba服务器。<br>
<code>sudo service smbd restart</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell]]></title>
        <id>https://dingtom.github.io/post/shell/</id>
        <link href="https://dingtom.github.io/post/shell/">
        </link>
        <updated>2020-11-25T07:16:54.000Z</updated>
        <content type="html"><![CDATA[<p><code>#!/bin/bash</code> <br>
######! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 <code>chmod +x ./test.sh</code> #使脚本具有执行权限 <code>./test.sh</code> #执行脚本 注意，一定要写成 ./test.sh，而不是 <a href="http://test.sh/">test.sh</a>，运行其它二进制的程序也一样，直接写 <a href="http://test.sh/">test.sh</a>，linux 系统会去 PATH 里寻找有没有叫 <a href="http://test.sh/">test.sh</a> 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <a href="http://test.sh/">test.sh</a> 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
<p><code>/bin/sh test.sh</code> # 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<p>######变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p>#####除了显式地直接赋值，还可以用语句给变量赋值，如： <code>for file in</code>ls /etc`` 或 <code>for file in $(ls /etc)</code> 以上语句将 /etc 下目录的文件名循环出来。</p>
<p>#####使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<pre><code>your_name=&quot;qinjx&quot;
echo $your_name
echo ${your_name}

</code></pre>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<pre><code>for skill in Ada Coffe Action Java; do  echo &quot;I am good at ${skill}Script&quot; ;done

</code></pre>
<p>如果不给skill变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<p>#####使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 readonly myUrl #修改的话执行时会报错</p>
<p>#####使用 unset 命令可以删除变量。unset 命令不能删除只读变量。 unset variable_name 变量被删除后不能再次使用。</p>
<p>#####单引号字符串的限制：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p>
<p>#####双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符</p>
<pre><code>your_name='runoob'
str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;
echo -e $str

</code></pre>
<p>#####拼接字符串</p>
<pre><code>your_name=&quot;runoob&quot;
# 使用双引号拼接
greeting=&quot;hello, &quot;$your_name&quot; !&quot;
greeting_1=&quot;hello, ${your_name} !&quot;
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
输出结果为：

hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !

</code></pre>
<p>#获取字符串长度 string=&quot;abcd&quot; echo ${#string} #输出 4</p>
<p>#提取子字符串 以下实例从字符串第 2 个字符开始截取 4 个字符： string=&quot;runoob is a great site&quot; echo ${string:1:4} # 输出 unoo</p>
<p>#查找子字符串 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： string=&quot;runoob is a great site&quot; <code>echo</code>expr index &quot;$string&quot; io`` # 输出 4</p>
<p>#####定义数组 在 Shell 中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开。 例如： array_name=(value0 value1 value2 value3) 还可以单独定义数组的各个分量： array_name[0]=value0 array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。</p>
<p>#####读取数组元素值的一般格式是：</p>
<pre><code>valuen=${array_name[n]}
使用 @ 符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}

</code></pre>
<p>#####获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<pre><code>length=${#array_name[@]}
或者
length=${#array_name[*]}

</code></pre>
<p>#####遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？ 每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
<p>#####多行注释还可以使用以下格式：</p>
<pre><code>:&lt;&lt;EOF
注释内容...
注释内容...
注释内容...
EOF

</code></pre>
<p>#####Shell 传递参数</p>
<pre><code>echo &quot;Shell 传递参数实例！&quot;
echo &quot;执行的文件名：$0&quot;;！！！！！！！！！！！！！！！！！！！！！！
echo &quot;第一个参数为：$1&quot;;
echo &quot;第二个参数为：$2&quot;;
echo &quot;第三个参数为：$3&quot;;
为脚本设置可执行权限，并执行脚本，输出结果如下所示：
chmod +x test.sh 
./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3

</code></pre>
<pre><code>$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。

</code></pre>
<p>#####另外，还有几个特殊字符用来处理</p>
<pre><code>$# 传递到脚本的参数个数 

$*  以一个单字符串显示所有向脚本传递的参数。如&quot;$*&quot;用「&quot;」
括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。

$$  脚本运行的当前进程ID号 

$!  后台运行的最后一个进程的ID号 

$@  与$*相同，但是使用时加引号，并在引号中返回每个参数。如&quot;$@&quot;用「&quot;」括起来的情况
以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数
 $* 与 $@ 区别：
相同点：都是引用所有参数。
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等
价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。

$- 显示Shell使用的当前选项，与[set命令]
(https://www.runoob.com/linux/linux-comm-set.html)功能相同。 

$?  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 

</code></pre>
<p>#Shell 基本运算符 #####算术运算符</p>
<pre><code>条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成
 [ $a == $b ]。表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，
这与我们熟悉的大多数编程语言不一样。完整的表达式要被 ` ` 包含，注意这个字符不是常用
的单引号，在 Esc 键下边。

</code></pre>
<pre><code>加法	`expr $a + $b` 结果为 30。
减法	`expr $a - $b` 结果为 -10。
乘法	`expr $a \* $b` 结果为  200。!   !  !   !   !
除法	`expr $b / $a` 结果为 2。
取余	`expr $b % $a` 结果为 0。
赋值	a=$b 将把变量 b 的值赋给 a。
相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。
不相等。用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。

</code></pre>
<p>#####关系运算符,关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<pre><code>-eq   检测两个数是否相等，相等返回 true。                 [ $a -eq $b ] 

-ne	检测两个数是否不相等，不相等返回 true。	            [ $a -ne $b ] 

-gt	检测左边的数是否大于右边的，如果是，则返回 true。   	[ $a -gt $b ] 

-lt	检测左边的数是否小于右边的，如果是，则返回 true。   	[ $a -lt $b ] 

-ge	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 

-le	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 

</code></pre>
<p>#####布尔运算符</p>
<pre><code>!	非运算，表达式为 true 则返回 false，否则返回 true。   	[ ! false ] 
-o	或运算，有一个表达式为 true 则返回 true。	                        [ $a -lt 20 -o $b -gt 100 ] 
-a	与运算，两个表达式都为 true 才返回 true。	                        [ $a -lt 20 -a $b -gt 100 ] 

</code></pre>
<p>#####逻辑运算符，表达式外有两个大括号! ! ! ! ! ! ! ! ! ! ! !</p>
<pre><code>&amp;&amp;	逻辑的 AND	[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]     !　！　！！　！！
||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]]   

</code></pre>
<p>##字符串运算符</p>
<pre><code>=	检测两个字符串是否相等，相等返回 true。	        [ $a = $b ] 
!=	检测两个字符串是否相等，不相等返回 true。	     [ $a != $b ] 
-z	检测字符串长度是否为0，为0返回 true。	        [ -z $a ] 
-n	检测字符串长度是否为0，不为0返回 true。	         [ -n &quot;$a&quot; ] 
$	检测字符串是否为空，不为空返回 true。	         [ $a ]   !!!!!!!!!!!

</code></pre>
<p>##文件测试运算符</p>
<pre><code>-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 
-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 
-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 
-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 
-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ]
-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 
-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 
-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 
-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 
-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 
-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 
-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 
-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 
-S: 判断某文件是否 socket。
-L: 检测文件是否存在并且是一个符号链接。

</code></pre>
<p>#echo命令 #####显示变量 read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<pre><code>read name 
echo &quot;$name It is a test&quot;
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出

</code></pre>
<p>#####显示换行 echo -e &quot;OK! \n&quot; # -e 开启转义 echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行 echo -n &quot;haod&quot; #输出后不换行 #####显示结果定向至文件 echo &quot;It is a test&quot; &gt; myfile</p>
<p>#####原样输出字符串，不进行转义或取变量(用单引号) <code>echo '$name\&quot;'</code></p>
<p>##显示命令执行结果 echo <code>date</code> #显示时间</p>
<p>#printf 命令 接下来,我来用一个脚本来体现printf的强大功能：</p>
<pre><code>#!/bin/bash
printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 
printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 
printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 
执行脚本，输出结果如下所示：

姓名     性别   体重kg
郭靖     男      66.12
杨过     男      48.65
郭芙     女      47.99

</code></pre>
<p>%s %c %d %f都是格式替代符</p>
<p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
<p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

# format-string为双引号
printf &quot;%d %s\n&quot; 1 &quot;abc&quot;

# 单引号与双引号效果一样 
printf '%d %s\n' 1 &quot;abc&quot; 

# 没有引号也可以输出
printf %s abcdef

# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
printf %s abc def

printf &quot;%s\n&quot; abc def

printf &quot;%s %s %s\n&quot; a b c d e f g h i j

# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
printf &quot;%s and %d \n&quot; 
执行脚本，输出结果如下所示：

1 abc
1 abc
abcdefabcdefabc
def
a b c
d e f
g h i
j  
 and 0

</code></pre>
<p>#####流程控制 <code>if [ $int == $anwser ]; then echo &quot;right&quot;;else echo &quot;wrong&quot;;fi</code></p>
<p><code>for var in item; do command; done</code> item是数组不用写括号</p>
<pre><code>echo '按下 &lt;CTRL-D&gt; 退出'
echo -n '输入你最喜欢的名字: '
while read NAME
do
    echo &quot;是的！$NAME 是一个好名字&quot;
done

</code></pre>
<p>#####while后的条件需要加括号 read 读取键盘输入 <CTRL-D> 退出</p>
<pre><code>#!/bin/bash
int=1
while([ $int -lt 5 ])   ! ! ! !  ! ! ! ! ! !
do
    echo $int
    let int++
done

</code></pre>
<p>let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。 let int++ #case</p>
<pre><code>echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac

</code></pre>
<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<pre><code>funWithReturn(){
    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;
    echo &quot;输入第一个数字: &quot;
    read aNum
    echo &quot;输入第二个数字: &quot;
    read anotherNum
    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;
    return $(($aNum+$anotherNum))
}
funWithReturn
echo &quot;输入的两个数字之和为 $? !&quot;

</code></pre>
<p>#####return返回的值需要两个括号 函数返回值在调用该函数后通过 $? 来获得。 #####输入/输出重定向 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
<pre><code>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：

$ wc -l users
       2 users
也可以将输入重定向到 users 文件：

$  wc -l &lt; users
       2 
注意：上面两个例子的结果不同：第一个例子，会输出文件名；
第二个不会，因为它仅仅知道从标准输入读取内容

</code></pre>
<p>#####重定向深入讲解 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<p>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>如果希望 stderr 重定向到 file，可以这样写：</p>
<p>command &lt; file1 &gt;file2 command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 #Here Document 它的基本的形式如下：</p>
<p>command &lt;&lt; delimiter document delimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<p>注意：</p>
<p>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。</p>
<pre><code>wc -l &lt;&lt; EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行

</code></pre>
<p>#####/dev/null 文件 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-ae38c3e76a5bcb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux命令]]></title>
        <id>https://dingtom.github.io/post/linux-ming-ling/</id>
        <link href="https://dingtom.github.io/post/linux-ming-ling/">
        </link>
        <updated>2020-11-25T05:55:41.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]<br>
Ctrl+d	键盘输入结束或退出终端<br>
Ctrl+s	暂停当前程序，暂停后按下任意键恢复运行<br>
Ctrl+z	将当前程序放到后台运行，恢复到前台为命令fg<br>
Ctrl+a	将光标移至输入行头，相当于Home键<br>
Ctrl+e	将光标移至输入行末，相当于End键<br>
Ctrl+k	删除从光标所在位置到行末<br>
Alt+Backspace	向前删除一个<strong>单词</strong><br>
命令 --help  查看一些它的某个命令具体参数的作用<br>
man 命令   显示系统手册页中的内容</p>
<p>一行中运行多个命令。<br>
; Command 1 ; Command 2 首先运行Command1，然后运行Command2<br>
&amp;&amp; Command 1 &amp;&amp; Command 2 当Command1运行成功并结束，然后运行Command2<br>
|| Command 1 || Command 2 当Command1运行失败时才运行Command2</p>
<h1 id="文件">文件</h1>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/18339009-be4aa0903719bf65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<blockquote>
<p>bin (binaries)存放二进制可执行文件<br>
sbin (super user binaries)存放二进制可执行文件，只有root才能访问<br>
etc (etcetera)存放系统配置文件<br>
usr (unix shared resources)用于存放共享的系统资源<br>
home 存放用户文件的根目录<br>
root 超级用户目录<br>
dev (devices)用于存放设备文件<br>
lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块<br>
mnt (mount)系统管理员安装临时文件系统的安装点<br>
boot 存放用于系统引导时使用的各种文件<br>
tmp (temporary)用于存放各种临时文件<br>
var (variable)用于存放运行时需要改变数据的文件</p>
</blockquote>
<h1 id="文件增删改查">文件增删改查</h1>
<blockquote>
<h4 id="mkdir">mkdir</h4>
<p>创建目录和父目录a,b,c,d<br>
<code>mkdir -p a/b/c/d</code><br>
-p 建立多级目录<br>
-m 在建立目录的时候给目录赋于权限值</p>
</blockquote>
<blockquote>
<h4 id="rmdir">rmdir</h4>
<p>删除空目录<br>
-p 删除多级空目录</p>
</blockquote>
<blockquote>
<h4 id="cp">cp</h4>
<p>拷贝文件夹a到/tmp目录<br>
<code>cp -rvf a/ /tmp/</code><br>
-R 复制整个目录里的内容<br>
-p 复制完后保持目录的权限值<br>
-v 在复制文件的时候显示进度<br>
-f 在复制的时候如果碰到目的文件名有重复就将原先的删除</p>
</blockquote>
<blockquote>
<h4 id="mv">mv</h4>
<p>重命名 <code>mv a.txt b.txt</code><br>
移动文件a到/tmp目录，并重命名为b<br>
<code>mv -vf a /tmp/b</code><br>
-i 如果目的地有相同文件名时会出现提示<br>
-v 在搬移文件时显示进度，在移动多文件时非常有用<br>
-u 当移动时只有源文件比目的文件新的时候才会移动<br>
-f 强制覆盖已有的文件</p>
</blockquote>
<blockquote>
<h4 id="touch">touch</h4>
<p>创建文件<br>
<code>touch asd.txt</code><br>
创建多个文件<br>
<code>touch love_{1..10}_shiyanlou.txt</code></p>
</blockquote>
<blockquote>
<h4 id="rm">rm</h4>
<p>删除机器上的所有文件<br>
rm -rvf /<br>
-i 在删除文件之前需要手工确认<br>
-v 在删除文件的时候显示信息<br>
-r 删除目录<br>
-f 忽略提示</p>
</blockquote>
<h4 id="ls">ls</h4>
<blockquote>
<p>-a 这个选项能显示.开头的隐藏文件<br>
-l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>
-t 将文件依建立时间之先后次序列出<br>
-i 显示每个文件的inode号<br>
-m 所有项目以逗号分隔，并填满整行行宽<br>
-R 同时列出所有子目录层<br>
-h 将列出文件的大小以人性化格式输出<br>
--color=tty(2个-号)显示文件的时候以色彩提示<br>
-full-time显示文件的详细访问时间<br>
-lc查看文件状态修改时间</p>
</blockquote>
<blockquote>
<h4 id="cat">cat</h4>
<p>查看文本文件<br>
如果文件很大的话，cat命令的输出结果会疯狂在终端上输出，可以多次按ctrl+c终止。<br>
-b 显示文件内容的时候显示行数<br>
-n 显示文件内容包括空行<br>
-s 将多个空行合并成一个空行输出</p>
</blockquote>
<blockquote>
<h4 id="tr">tr</h4>
<p>删除、转换一段文本信息中的某些文字<br>
-d	删除匹配的字符，注意不是全词匹配也不是按字符顺序匹配<br>
-s	去除指定的在输入文本中连续并重复的字符<br>
删除 &quot;hello shiyanlou&quot; 中所有的'o','l','h'<br>
<code>echo 'hello shiyanlou' | tr -d 'olh'</code><br>
将&quot;hello&quot; 中的ll,去重为一个l<br>
<code>echo 'hello' | tr -s 'l'</code><br>
将输入文本，全部转换为大写或小写输出<br>
<code>echo 'input some text here' | tr '[:lower:]' '[:upper:]'</code><br>
上面的'[:lower:]' '[:upper:]'你也可以简单的写作'[a-z]' '[A-Z]',当然反过来将大写变小写也是可以的</p>
</blockquote>
<blockquote>
<h4 id="jion">jion</h4>
<p>将两个文件中包含相同内容的那一行合并在一起。<br>
-t	指定分隔符，默认为空格<br>
-i	忽略大小写的差异<br>
-1	指明第一个文件要用哪个字段来对比，默认对比第一个字段<br>
-2	指明第二个文件要用哪个字段来对比，默认对比第一个字段<br>
将/etc/passwd与/etc/group两个文件合并，指定以':'作为分隔符, 分别比对第4和第3个字段<br>
<code>sudo join -t':' -1 4 /etc/passwd -2 3 /etc/group</code></p>
</blockquote>
<blockquote>
<h4 id="paste">paste</h4>
<p>在不对比数据的情况下，简单地将多个文件合并一起，以Tab隔开。<br>
-d	指定合并的分隔符，默认为 Tab<br>
-s	不合并到一行，每个文件为一行</p>
</blockquote>
<h4 id="less">less</h4>
<p>针对比较大的文件，我们就可以使用less命令打开某个文件。</p>
<p>按n(N)向下(上)查找。</p>
<h4 id="more">more</h4>
<p>查看文本文件命令</p>
<p>用空格向下翻页，用b向上翻页</p>
<blockquote>
<p>+行数直接从给定的行数开始显示<br>
-s 将多个空行压缩成一个空行<br>
-p 清除屏幕后再显示</p>
</blockquote>
<h4 id="nano">nano</h4>
<p>文本编辑器<br>
命令格式：nano [选项] [行号] 文件名</p>
<h4 id="head">head</h4>
<p>查看文件头部</p>
<blockquote>
<p>-n &lt;行数&gt; 显示文件的最前指定的行<br>
-c &lt;字节数&gt; 显示文件前N个字节数里的内容<br>
-q 不输出文件头的内容<br>
-v 输出文件头的内容</p>
</blockquote>
<h4 id="tail">tail</h4>
<p>查看文件尾部</p>
<blockquote>
<p>-f 循环读取<br>
-c &lt;字节数&gt; 显示文件前N个字节数里的内容<br>
-q 不输出文件头的内容<br>
-n &lt;行数&gt; 指定所显示的行数<br>
-v 输出文件头的内容</p>
</blockquote>
<p><code>tail -f access.log</code></p>
<h4 id="ln">ln</h4>
<p>生成链接文件</p>
<p>命令格式：ln [选项] 源文件 链接文件</p>
<blockquote>
<p>-f 删除已存在的目的文件<br>
-i 如果碰到有重复名字的提示如何操作<br>
-v 显示操作信息<br>
-s 软链接选项</p>
</blockquote>
<h4 id="file">file</h4>
<p>查看文件的类型</p>
<h4 id="stat">stat</h4>
<p>显示文件或文件系统状态</p>
<p>命令格式：stat [选项] &lt;文件/目录&gt;</p>
<blockquote>
<p>-f:查看指定的文件系统</p>
</blockquote>
<p>stat可查看：<br>
文件名 2. 文件尺寸 3. I节点号 4. 创建时间/访问时间/状态(属 主、组、权限)修改时间 5.权限 6.链接文件个数 7. 属主及属组等</p>
<h4 id="whereis">whereis</h4>
<p>whereis 只能查找2进制程序，文档和源码。</p>
<h4 id="which">which</h4>
<p>查找是否安装某个命令</p>
<h4 id="find">find</h4>
<p>最常用的命令，命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。<br>
<code>sudo find /etc -name sources.list</code></p>
<p>find -size n [c]<br>
查找n值大小的文件,默认单位是块(1块=512字节)</p>
<blockquote>
<ol>
<li>查找大于1500字节的文件<br>
find ~ -size +1500c</li>
</ol>
</blockquote>
<ol start="2">
<li>查找等于1500字节的文件<br>
find ~ -size 1500c</li>
<li>查找小于1500字节的文件<br>
find ~ -size -1500c</li>
<li>查找大于512k字节的文件<br>
find ~ -size +512k</li>
<li>查找等于1M字节的文件<br>
find ~ -size 1M</li>
<li>查找小于1G字节的文件<br>
find ~ -size -1G</li>
<li>查找大于10块的文件<br>
find ~ -size +10</li>
<li>查找等于10块的文件<br>
find ~ -size -10</li>
<li>查找大于10M小于20M的文件<br>
find ./ -size +10M -size -20M</li>
<li>查找小于10块的文件<br>
find ~ -size -10</li>
<li>查找文件/目录字节为0的文件(即空文件)<br>
find / -empty</li>
</ol>
<h4 id="grep">grep</h4>
<p>功能: 通过正则表达式查找文件中的关键字</p>
<blockquote>
<p>-i:忽略大小写<br>
-c:打印匹配的行数<br>
-C:打印出匹配的上下文(上N行,下N行)的多少行-l:列出匹配的文件名<br>
-L:列出不匹配的文件名<br>
-n：打印包含匹配项的行和行标<br>
-w:仅匹配指定的单词而非关键字<br>
-e:索引匹配字串<br>
-r:递归查询<br>
-v:不输出匹配的行<br>
-A &lt;行号&gt;:显示所找的匹配字段，并显示下面指定的行数的信息<br>
-B &lt;行号&gt;:显示所找的匹配字段，并显示上面指定的行数的信息</p>
</blockquote>
<p>查看nginx日志中的POST请求。<br>
<code>grep -rn --color POST access.log</code><br>
看某个异常前后相关的内容<br>
<code>grep -rn --color Exception -A10 -B2 error.log</code></p>
<h4 id="正则表达式表示方法">正则表达式表示方法:</h4>
<blockquote>
<p>\忽略正则表达式中特殊字符的原有含义<br>
^ 匹配正则表达式的开始行<br>
$ 匹配正则表达式的结束行<br>
&lt; 从匹配正则表达式的行开始<br>
到匹配正则表达式的行结束<br>
[ ] 单个字符；如[A] 即A符合要求<br>
[ n - m ] 范围 ；如[A-H]即包含A至H都符合要求<br>
. 所有的单个字符<br>
* 所有字符，长度可以为0</p>
</blockquote>
<h4 id="cut">cut</h4>
<p>打印每一行的某一字段</p>
<blockquote>
<p>-d “n”:定义分界符,即点位<br>
-f 取第几位的字符<br>
-c:仅显示行中指定范围的字符</p>
</blockquote>
<p>打印/etc/passwd文件中以:为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录：<br>
<code>cut /etc/passwd -d ':' -f 1,6</code><br>
前五个（包含第五个）<br>
<code>cut /etc/passwd -c -5</code><br>
前五个之后的（包含第五个）<br>
<code>cut /etc/passwd -c 5-</code></p>
<h4 id="sort">sort</h4>
<p>排序<br>
-r反转<br>
-t参数用于指定字段的分隔符<br>
-k 字段号用于指定对哪一个字段进行排序<br>
-n 按照数字排序,默认情况下是以字典序排序的<br>
<code>cat /etc/passwd | sort -t':' -k 3 -n</code></p>
<h4 id="wc">wc</h4>
<p>计数工具<br>
行数<br>
<code>wc -l /etc/passwd</code><br>
单词数<br>
<code>wc -w /etc/passwd</code><br>
字节数<br>
<code>wc -c /etc/passwd</code><br>
字符数<br>
<code>wc -m /etc/passwd</code><br>
最长行字节数，西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于 2 个字节的，具体数目是由字符编码决定的<br>
<code>wc -L /etc/passwd</code></p>
<h4 id="uniq">uniq</h4>
<p>-c:在数据行前出现的次数<br>
-d:只打印重复的行,重复的行只显示一次<br>
-f:忽略行首的几个字段<br>
-i:忽略大小写<br>
-s:忽略行首的几个字母<br>
-u:只打印唯一的行</p>
<p>用于过滤或者输出重复行。<br>
因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：</p>
<p><code>history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq</code><br>
使用频率前三的命令<br>
<code>history |cut -c 8-|sort|uniq -dc|sort -rn -k1 |head -3</code></p>
<h4 id="下载">下载</h4>
<p><code>wget url</code></p>
<p><code>sudo apt-get install axel</code></p>
<p><code>axel -n 10 -o /tmp/ [http://testdownload.net/test.tar.gz](http://testdownload.net/test.tar.gz)</code><br>
-n 指定线程数<br>
-o 指定另存为目录<br>
-s 指定每秒的最大比特数<br>
-q 静默模式</p>
<h1 id="系统">系统</h1>
<p><code>who am i</code><br>
查看用户<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-f5fab39403516fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<p>输出的第一列表示打开当前伪终端的用户的用户名，第二列的 pts/0 中 pts 表示伪终端，所谓伪是相对于 /dev/tty 设备而言的，还记得上一节讲终端时的那七个使用 [Ctrl]+[Alt]+[F1]～[F7] 进行切换的 /dev/tty 设备么，这是“真终端”，伪终端就是当你在图形用户界面使用 /dev/tty7 时每打开一个终端就会产生一个伪终端，pts/0 后面那个数字就表示打开的伪终端序号，第三列则表示当前伪终端的启动时间。</p>
<h4 id="用户">用户</h4>
<p>sudo passwd lilei  设置用户lilei的密码<br>
sudo adduser lilei 创建新用户lilei，默认为新用户在 /home 目录下创建一个工作目录<br>
su -l lilei   切换到lilei用户<br>
sudo deluser lilei --remove-home  删除用户</p>
<h4 id="groups">groups</h4>
<p>groups shiyanlou<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-190c8e54549c1881.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
其中冒号之前表示用户，后面表示该用户所属的用户组。这里可以看到 shiyanlou 用户属于 shiyanlou 用户组，每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组<br>
<code>cat /etc/group | grep -E &quot;shiyanlou&quot;</code><br>
查看自己属于哪些用户组<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-51df186681c8e87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
group_name:password:GID:user_list</p>
<p><code>sudo usermod -G sudo lilei</code><br>
将其它用户加入 sudo 用户组<br>
以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。</p>
<h2 id="文件权限操作">文件权限操作</h2>
<p><code>ls -l a.txt</code></p>
<p>drwxr-xr-x  2 root root 4.0K  3月  23  2017  a.txt</p>
<blockquote>
<p>第1位：文件类型（d 目录，- 普通文件，l 链接文件）<br>
r 可读权限，w可写权限，x可执行权限（也可以用二进制表示 111 110 100 --&gt; 764）<br>
第2-4位：所属用户权限，用u（user）表示<br>
第5-7位：所属组权限，用g（group）表示<br>
第8-10位：其他用户权限，用o（other）表示<br>
第2-10位：表示所有的权限，用a（all）表示</p>
</blockquote>
<p>2是纯数字 ，表示 文件链接个数<br>
第一个“root” 表示文件的所有者<br>
第二个“root” 表示为文件的所在群组<br>
“4.0K”，表示为文件长度（大小）<br>
“3月  23  2017”，表示文件最后更新（修改）时间<br>
“etc” 表示文件的名称</p>
<h4 id="chown">chown</h4>
<p>改变文件的所属用户和所属组。</p>
<blockquote>
<p>-R 修改指定目录及其子目录</p>
</blockquote>
<p>修改a目录的用户和组为 xjj<br>
<code>chown -R xjj:xjj a</code></p>
<h4 id="chmod">chmod</h4>
<p>改变文件的访问权限。</p>
<blockquote>
<p>u表示当前用户<br>
g表示同组用户<br>
o表示其他用户<br>
a表示所有用户<br>
r表示可读<br>
w表示可写<br>
x表示可执行<br>
用数字来表示权限（r=4，w=2，x=1，-=0）,7：表示可读可写可执行，4+2+1,6：表示可读可写，4+2<br>
-R 修改指定目录及其子目录</p>
</blockquote>
<p>给a.sh文件增加执行权限（这个太常用了)<br>
<code>chmod a+x a.sh</code><br>
g、o 还有 u 分别表示 group（用户组）、others（其他用户） 和 user（用户），+ 和 - 分别表示增加和去掉相应的权限。<br>
<code>chmod go-rw t.txt</code></p>
<p>####df(report file system disk space usage)<br>
显示文件系统磁盘空间的使用情况</p>
<blockquote>
<p>-h 以人类可读的方式显示，KD，Mb，GB等</p>
</blockquote>
<h4 id="du-estimate-file-space-usage">du  (estimate file space usage)</h4>
<p>显示指定的目录及其子目录已使用的磁盘空间的总和</p>
<blockquote>
<p>-s显示指定目录的总和<br>
-a  显示目录中所有文件的大小。<br>
-h以人类可读的方式显示，Kb，Mb，G8等<br>
-d参数指定查看目录的深度 # 只查看1级目录的信息<br>
-d 0 ~<br>
查看文件大小<br>
<code>du -h file</code></p>
</blockquote>
<h4 id="dd">dd</h4>
<p>转换和复制文件,也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。</p>
<p>dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file，输入文件）和of（output file，输出文件）改变。</p>
<p>bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如'K'，'M'，'G'等单位），<br>
count用于指定块数量。<br>
conv=ucase  将输出的英文字符转换为大写再写入文件</p>
<p>输出到test文件<br>
<code>dd of=test bs=10 count=1</code><br>
输出到标准输出<br>
<code>dd if=/dev/stdin of=/dev/stdout bs=10 count=1</code></p>
<h4 id="mount">mount</h4>
<p>-o 操作选项<br>
-t 文件系统类型<br>
-w|--rw|--ro权限</p>
<p>从/dev/zero设备创建一个容量为 256M 的空文件：<br>
<code>dd if=/dev/zero of=virtual.img bs=1M count=256</code><br>
格式化磁盘：<br>
<code>sudo mkfs.ext4 virtual.img</code><br>
挂载我们创建的虚拟磁盘镜像到/mnt目录：<br>
<code>mount -o loop -t ext4 virtual.img /mnt</code></p>
<p>卸载已挂载磁盘<br>
<code>sudo umount /mnt</code></p>
<h4 id="free">free</h4>
<p>显示当前内存和交换空间的使用情况</p>
<h4 id="date">date</h4>
<p>显示系统当前时间</p>
<h4 id="top">top</h4>
<p>显示当前系统中耗费资源最多的进程<br>
查看某个进程中的线程状态<br>
<code>top -H -p pid</code></p>
<h4 id="ps">ps</h4>
<p>较少单独使用，配参数根据需求，ps ef或者ps-aux</p>
<blockquote>
<p>-e 显示所有选程，环境变量<br>
-f 全格式显示<br>
-a 显示所有用户的所有进程（包括其它用户）<br>
-u 按用户名和启动时间的顺序来显示进程<br>
-x 显示无控制终端的进程</p>
</blockquote>
<h4 id="kill">kill</h4>
<blockquote>
<p>-9 kill -9 pid强制杀死一个进程</p>
</blockquote>
<h4 id="ifconfig">ifconfig</h4>
<p>网卡网络配置，常用于查看当前IP地址<br>
ifconfig etho 192.168.12.22 修改系统IP（重品后失效）</p>
<h4 id="ping">ping</h4>
<p>ping baidu.com 测试网络的连通</p>
<h4 id="hostname">hostname</h4>
<p>查看主机名</p>
<h4 id="关机">关机</h4>
<blockquote>
<p><code>sudo shutdown now</code><br>
<code>sudo reboot now</code><br>
<code>shutdown -c</code>取消关机   <br>
<code>shutdown -p</code>立即关机，无提示、延时<br>
<code>shutdown -s</code>关机<br>
<code>shutdown -r</code>重启<br>
<code>shutdown -f</code>强行关闭应用程序<br>
<code>shutdown -l</code>注销当前用户<br>
<code>shutdown -s -t</code> 设置关机倒计时<br>
<code>shutdown -h</code>休眠</p>
</blockquote>
<h4 id="export">export</h4>
<p>设定一些环境变量，env命令能看到当前系统中所有的环境变量。比如，下面设置的就是jdk的。<br>
<code>export PATH=$PATH:/home/xjj/jdk/bin</code><br>
<code>source</code>命令来让其立即生效<br>
set	显示当前 Shell 所有变量，包括<strong>其内建环境变量，用户自定义变量及导出的环境变量。</strong><br>
env	显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。<br>
export	显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</p>
<p>/etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。<br>
<code>unset</code><br>
命令删除一个环境变量</p>
<h1 id="压-解缩">压、解缩</h1>
<blockquote>
<h4 id="gzip">gzip</h4>
<p>压缩文件成者文件夹<br>
-d解压缩文件</p>
</blockquote>
<blockquote>
<h4 id="zip">zip</h4>
<p>将目录 /home/shiyanlou/Desktop 打包成一个文件<br>
<code>zip -r -9 -q -o -l shiyanlou.zip /home/shiyanlou/Desktop</code><br>
-r 参数表示递归打包包含子目录的全部内容，9 压缩级别最大1 最小,<br>
-q 参数表示为安静模式，即不向屏幕输出信息，<br>
-o，表示输出文件,<br>
-l 参数将 LF 转换为 CR+LF 来达到win/linux兼容。</p>
<h4 id="unzip">unzip</h4>
<p>将文件解压到指定目录：<br>
<code>unzip -q shiyanlou.zip -d ziptest</code><br>
-q 使用安静模式<br>
-d指定路径<br>
-l 不解压只想查看压缩包的内容<br>
-O（英文字母，大写 o）参数指定编码类型：(win默认会采用 GBK , Linux 默认 UTF-8 )<br>
unzip -O GBK 中文压缩文件.zip</p>
</blockquote>
<blockquote>
<h4 id="tar">tar</h4>
<p><code>tar -xzf shiyanlou.tar.gz -C tardir</code><br>
压缩文件格式<code>-z/*.tar.gz</code>，<code>-J/*.tar.xz</code>	，<code>-j/*tar.bz2</code><br>
-P 保留绝对路径符<br>
-v压缩的过程中显示文件<br>
-c 表示创建一个 tar 包文件<br>
-f 用于指定创建的文件名，件名必须紧跟在 -f 参数之后<br>
-p在其他主机还原时希望保留文件的属性<br>
-h 备份链接指向的源文件而不是链接本身<br>
-x解包一个文件<br>
-C 指定保存路径<br>
-t只查看不解包文件</p>
</blockquote>
<h1 id="vim">VIM</h1>
<p><img src="https://upload-images.jianshu.io/upload_images/18339009-de0ac15d12403184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
修改文本<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-b6f40fe5095da55e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
定位命令<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-40f8d2a91c245485?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" loading="lazy"><br>
替换和取消命令<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-3192c0b29770869f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
删除命令<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-52358b7bd810c2b8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"><br>
常用快捷键<br>
<img src="https://upload-images.jianshu.io/upload_images/18339009-c8dc68e3552b4958?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h4 id="alias">alias</h4>
<p><code>alias a='find . -size +10M -type f -print0 | xargs -0 ls -Ssh | sort -z'</code></p>
<h4 id="关闭防火墙">关闭防火墙</h4>
<p>systemctl stop firewalld.service</p>
<h4 id="禁止防火墙开机启动">禁止防火墙开机启动</h4>
<p>systemctl disable firewalld.service</p>
<h4 id="关闭selinux">关闭SELinux</h4>
<p>nano -w /etc/selinux/config<br>
将SELINUX=enforcing改为SELINUX=disabled保存并退出:^x-&gt;y-&gt;回车</p>
<h1 id="计划任务">计划任务</h1>
<p>查看添加了哪些任务<code>crontab -l</code><br>
添加一个计划任务<code>crontab -e</code><br>
删除任务<code>crontab -r</code><br>
<code>分 小时 天 月 星期 user-name command to be executed</code></p>
<p>启动 rsyslog，以便我们可以通过日志中的信息来了解我们的任务是否真正的被执行了<br>
<code>sudo apt-get install -y rsyslog</code><br>
<code>sudo service rsyslog start</code>( Ubuntu 会默认自行启动不需要手动启动)<br>
<code>sudo cron －f &amp;</code>(实验环境中 crontab 也是不被默认启动的，同时不能在后台由 upstart 来管理，所以需要我们来启动它)</p>
<p>每分钟我们会在/home/shiyanlou 目录下创建一个以当前的年月日时分秒为名字的空白文件<br>
<code>*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)</code></p>
<blockquote>
<p>“ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p>
</blockquote>
<p>查看到执行任务命令之后在日志中的信息反馈<br>
<code>sudo tail -f /var/log/syslog</code></p>
<h4 id="有选择的执行命令">有选择的执行命令</h4>
<p><code>which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;</code><br>
<code>&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回 0 则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果</code><br>
<code>||在这里就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为 ≠0($?≠0)时则执行它后面的命令</code><br>
echo $?</p>
]]></content>
    </entry>
</feed>